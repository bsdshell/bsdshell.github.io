-------------------------------------------------------------------------------- 
Mon Mar  4 18:40:37 2019 
add int[] long integer, long integer  

add two long integer is trick problem actually, same as multiply two long integers
1. array index and result index are both different
2. array is len, result array is len + 1

1. make two arrays are the same length 
2. add two same length arrays up
3. result array will be (len + 1)
    0 1 2
    0 1 2
  0 1 2 3
    
    int c = 0
    for(int i=0; i<len; i++){
        r = len - 1 - i;
        j = r + 1;

        s = c + (arr1[i] + arr2[i]);
        c = s / 10;
      arr[j] = s % 10;
    }
    arr[0] = c


it is trick problem actually, 
/Users/cat/myfile/bitbucket/java/AddLongIntegerNum.java
-------------------------------------------------------------------------------- 
Mon Mar  4 18:38:09 2019 
read csv file with Opencsv jar file, opencsv-4.0.jar, csv file, write to csv file,

/Users/cat/myfile/bitbucket/java/OpenCSVExample/src/Main.java
-------------------------------------------------------------------------------- 
Sat Mar  2 21:42:02 2019 
runhaskell with profile, haskell profile, haskell profiling

let hpro =  ' +RTS -H32m -S -p -RTS ' 
-------------------------------------------------------------------------------- 
Sat Mar  2 14:11:57 2019 
Install Tensor Flow in Python,

Yep, it is pain of ass
1. I have old version of Python 2.7.0
2. Yep, you need to install Python 3.0, /usr/local/bin/python3
3. You need to set environment variables to point to Python lib
4. You need to install other lib such as 
-------------------------------------------------------------------------------- 
Thu Feb 28 13:12:36 2019 
merge list, merge sorted list, merge array, merge stuff

public static ArrayList<Integer> mergeList(ArrayList<Integer> list1, ArrayList<Integer> list2){
    ArrayList<Integer> list = new ArrayList<>();
    if( list1 != null && list2 != null){
    e    int len1 = list1.size();
        int len2 = list2.size();
        int i = 0, j = 0;
        while(i < len1 || j < len2){
            if(i >= len1){
                list.add(list2.get(j));
                j++;
            }else if(j >= len2){
                list.add(list1.get(i));
                i++;
            }else{
                if(list1.get(i) < list2.get(j)){
                    list.add(list1.get(i));
                    i++;
                }else{
                    list.add(list2.get(j));
                    j++;
                }
                    
            }
        }
    }
    return list;
}
-------------------------------------------------------------------------------- 
Haskell
Category

Functor
    1. There Objects and arrows
Ring 
    1. identity for (+) and (*)
    2. distribution over the (+)

Group
    1. identity => Id + e = e + Id = e
    2. Associativity => a + b + c = a + (b + c)
    3. Inverse => a + a^(-1) = Id

Semigroup
    2. Associativity => a + b + c = a + (b + c)

Monoid
    1, 2
Monad
    Monad is Monoid over Functor
-------------------------------------------------------------------------------- 
    /**
        1. arr = {1}, 
        2. 2 1
             mid = arr[0]
        3. 1 2
             mid = arr[0]

           2 3 4 1  (lo=0, hi=3)
                mid = 1
                    (lo=1, hi =3) -> 3 4 1
                        mid = 2
                            (lo=2, hi=3) -> 4 1
                                mid = 2
                                    arr[2] < arr[2]
                                    max(arr, lo=2, hi=2)  => 4
                            

        rotate sorted string
    */
    public static int max(int[] arr, int lo, int hi){
        if(arr[lo] <= arr[hi]){
            return arr[hi];
        }else{
            int mid = (lo + hi)/2;
            if(arr[lo] < arr[mid]){
                return max(arr, mid, hi);
            }else{
                return max(arr, lo, mid);
            }
        }
    }
-------------------------------------------------------------------------------- 
// better version: http://localhost/html/indexTriesDataStructure.html
// another tries data structure again!
// add: count all the longest paths
class TNode{
    boolean isWord;
    String word;
    TNode[] arr = new TNode[26];
    // use Map<String, TNode> map;
    public TNode(){
        isWord = false;
    }
}

public class try_tries{
    public static void main(String[] args) {
//        a | b | c |
//                d | 
//            e f | 
          

        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        TNode r = new TNode();
        String s = "a";
        String s1 = "ab";
        String s2 = "abc";
        String s3 = "abd";
        String s4 = "aef";
        int inx = 0;
        insert(r, s, inx);
        insert(r, s1, inx);
        insert(r, s2, inx);
        insert(r, s3, inx);
        insert(r, s4, inx);
        Print.pb(contains(r, "a", inx) == true);
        Print.pb(contains(r, "ac", inx) == false);
        Print.pb(contains(r, "ab", inx) == true);
        Print.pb(contains(r, "abc", inx) == true);
        int count = countPath(r);
        Print.pb(count);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        TNode r = new TNode();
        String s = "a";
        String s1 = "ab";
        String s2 = "abc";
        String s3 = "abd";
        String s4 = "aef";
        int inx = 0;
        insert(r, s, inx);
        insert(r, s1, inx);
        insert(r, s2, inx);
        insert(r, s3, inx);
        insert(r, s4, inx);

        String input = "ab";
        List<String> list = autoComplete(r, input, inx);
        Print.pb(list);

        Aron.end();
    }
    public static void insert(TNode r, String s, int inx){
        if (inx < s.length()){
            int index = s.charAt(inx) - 'a';
            if(r.arr[index] == null)
                r.arr[index] = new TNode();
            insert(r.arr[index], s, inx + 1);
        }else{
            r.word = s;
            r.isWord = true;
        }
    }
    public static boolean contains(TNode r, String s, int inx){
        if(inx < s.length()){
            int index = s.charAt(inx) - 'a';
            if(r.arr[index] != null){
                return contains(r.arr[index], s, inx+1);
            }else{
                return false;
            }
        }else{
            return r.isWord;
        }
    }
    /*
    Count the number of paths of Tries
    Input Tries
    Return number of paths or number of words in Tries
    Count the number of longest paths in Tries
    */
    public static int countPath(TNode r){
        if(r != null){
            int s = 0;
            int i = 0;
            for(i=0; i<r.arr.length; i++){
                if(r.arr[i] != null){
                    s += countPath(r.arr[i]);
                }
            }
            if (s == 0) // all nodes are null, we hit the bottom
                return 1;
            else
                return s;
        }else{
            return 0;
        }
    }
    public static void getList(TNode r, List<String> list){
        if(r != null){
            int c = 0;
            for(int i=0; i<r.arr.length; i++){
                if(r.arr[i] != null){
                    getList(r.arr[i], list);
                    c++;
                }
            }
            if(c == 0){
                list.add(r.word); 
            }
        }
    }
    public static List<String> autoComplete(TNode r, String s, int inx){
        if (inx < s.length()){
            int index = s.charAt(inx) - 'a';
            if(r.arr[index] != null){
                return autoComplete(r.arr[index], s, inx + 1);
            }else{
                return new ArrayList<String>();
            }
        }else{
            List<String> list = new ArrayList<String>();
            getList(r, list);
            return list;
        }
    }
} 

-------------------------------------------------------------------------------- 
Wed Feb 20 10:46:03 2019 
String interleaving, string interleav, string inter, in cpp, in C++

#include<iostream>
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 

#include "AronLib.h"

using namespace std;

// The main function that recursively prints all interleavings. 
// The variable iStr is used to store all interleavings (or 
// output strings) one by one. 
// i is used to pass next available place in iStr 
void printRecur (char *str1, char *str2, char *iStr, int m, 
					int n, int i) { 
	// Base case: If all characters of str1 and str2 have been 
	// included in output string, then print the output string 
	if (m==0 && n==0) 
		printf("%s\n", iStr) ; 

	// If some characters of str1 are left to be included, then 
	// include the first character from the remaining characters 
	// and recur for rest 
	if (m != 0){ 
        printf("str1=%c\n", str1[0]);
		iStr[i] = str1[0]; 
		printRecur (str1 + 1, str2, iStr, m-1, n, i+1); 
	} 

	// If some characters of str2 are left to be included, then 
	// include the first character from the remaining characters 
	// and recur for rest 
	if (n != 0) { 
        printf("str2=%c\n", str2[0]);
		iStr[i] = str2[0]; 
		printRecur(str1, str2+1, iStr, m, n-1, i+1); 
	} 
} 

// Allocates memory for output string and uses printRecur() 
// for printing all interleavings 
void printIls (char *str1, char *str2, int m, int n) { 
// allocate memory for the output string 
char *iStr= (char*)malloc((m+n+1)*sizeof(char)); 

// Set the terminator for the output string 
iStr[m+n] = '\0'; 

// print all interleavings using printRecur() 
printRecur (str1, str2, iStr, m, n, 0); 

// free memory to avoid memory leak 
free(iStr); 
} 

// Driver program to test above functions 
int main() { 
	char str1[] = "AB"; 
	char str2[] = "ab"; 
	printIls (str1, str2, strlen(str1), strlen(str2)); 
	return 0; 
} 
-------------------------------------------------------------------------------- 
Wed Feb 20 09:45:18 2019 
Given a string, print all permutation of their characters, interview questions, 
    /**
    abc 
      p(abc)
        a + p(bc)
            b + p(c)
                c + p("")
            c + p(b)
                b + p("")
        b + p(ac)
            a + p(c) 
                c + p("")
            c + p(a)
                a + p("")
        c + p(ab)
            a + p(b)
                b + p("")
            b + p(a)
                a + p("")
    */
    public static void permutation(String prefix, String s){
        if(s.length() == 0){
            Print.pl("perm=" + prefix);
        }else{
            for(int i=0; i<s.length(); i++){
                String ss = "" + s.charAt(i);
                permutation(prefix + ss, remove(i, s));
            }
        }
    }
    public static String remove(int n, String s){
        StringBuffer sb = new StringBuffer(s);
        sb.deleteCharAt(n);
        return sb.toString();
    }
-------------------------------------------------------------------------------- 
Convert number to binary string, interview questions

/**
<pre>
{@literal
    Convert Numbet to Binary String
}
{@code
    numToBinary(4) => "100"
}
</pre>
*/ 
public static String numToBinary(int n){
    String s = "";
    if(n == 0)
       s = "0"; 
    while(n > 0){
        int mod = n % 2;
        int q = n / 2;
        s = mod + s;
        n = q;
    }
    return s;
}
-------------------------------------------------------------------------------- 
Libigl library for Geometry Processing, Thu Feb  7 22:56:53 2019 

https://libigl.github.io/#libigl-example-project 

Libigl seems to be good library for Geometry Processing,
git clone and build, it seems to me that I can build all the tutorials so far.
It is hard to image to build C/C++ code on my system, most of time it is failed
Libigl also depends on many libs/tools such as CMake, CGAL, and Eigen

For C++ project, there is always some issues?.. to build..

If you try to read cmake script, then it will make you fall in sleep right away.
I never understand make file, maybe..
-------------------------------------------------------------------------------- 
Thu Jan 31 11:17:01 2019 
opengl keypress, keypress example, keyboard example
/Users/cat/myfile/bitbucket/haskell/keyboardpress_simple.hs
-------------------------------------------------------------------------------- 
install astyle on MacOS, Vim formater, Sun Jan 27 11:41:12 2019 

brew install astyle
:%!astyle
-------------------------------------------------------------------------------- 
reload Chrome from command line, Sat Jan 19 10:48:16 2019 

# https://stackoverflow.com/questions/17119184/auto-reload-html-file-with-a-browser-via-terminal-command
printc 200 "reload Chrome"
osascript -e 'tell application "Google Chrome" to tell the active tab of its first window to reload'
-------------------------------------------------------------------------------- 
Emacs Org mode

My note -*- mode: org -*-
\( \sqrt{3} \)
#+TAGS: {@HOME(o) @OFFICE(h)} COMPUTER(c) PHONE(p) READER(r)
<2019-01-17 Thu>
*TODO*
1. cat
2. pig
* file
** file
HOME
*** cat
**** fox
***** pig

Haskell literal programming
pandoc converts lhs file to Html file 

pandoc -f markdown+lhs -t html5 --smart myfile.lhs
-------------------------------------------------------------------------------- 
latex color, text color, textcolor, background color, Tue Jan 15 17:24:53 2019 

\textcolor{declared-color}{text} 
{\color{declared-color}some text}
\colorbox{declared-color}{text}
-------------------------------------------------------------------------------- 
Thu Jan 10 11:47:43 2019 
Given the lengths of edges of a triangle ABc, we can compute the area of the triangle
t: Given any square matrix M, there exits a pair of unitary matrix and upper triangle matrix such that
m:                            M = QR

mat:  
   3 4 5
   7 9 9
   6 3 5

mat:
   sin(beta) 3 4 3
   cos(alpha) 4 9 3
   3 4  3 5

eq:
    f'(x) = x^2 + x + 4


m: 
  lim x -> 0  (f(x + h) - f(x)) / h
-------------------------------------------------------------------------------- 
Mon Dec 17 10:11:20 2018 

I have Vectorx class and I want to overload "dot product"
with operator (*:) in Num class

data Vectorx a = Vectorx a a a 

instance (Num a)=>Num(Vectorx a) where
    (+) ...
    (-) ...
    etc ...
    (*:) (Vectorx x0 y0 z0) (Vectorx x1 y1 z1) = x0*x1 + y0*y1 + z0*z1 

It seems to me I can NOT add (*:) operator in the instance of Num

In Java, I can add whatever method that I want when I implement interface or extend abstract class.

Any help would be appreciated.
-------------------------------------------------------------------------------- 
get exit code from process, exitcode in Haskell

import Control.Monad
import System.Directory
import System.Exit
import System.Process

main = do
    (exitCode, _, _) <- readProcessWithExitCode "unrar" ["x", "archivename"] ""
    when (exitCode == ExitSuccess) $ removeFile "archivename" 
-------------------------------------------------------------------------------- 
Mon Dec  3 14:38:14 2018 

Add record to genehtml.hs
make the code looks nice, I guess
-------------------------------------------------------------------------------- 
Sun Dec  2 14:26:34 2018 

1. fix table layout
2. the new index is working so far. 
3. indexNew.html => all the links seems to be OK,
-------------------------------------------------------------------------------- 
Sun Dec  2 00:36:06 2018 

1. Create new index Page  => localhost/indexNew.html
2. Add the code to genehtml.hs file
3. not add url links to indexNew.html yet
4. Need to fix the table layout
5. more..

TODO: ...
------------------------------------------------------------------------------- 
Wed Feb 20 10:22:38 2019  
Find string from a given string, c++ find string, search string, search str, find str 

// string::find
#include <iostream>       // std::cout
#include <string>         // std::string

int main ()
{
  std::string str ("There are two needles in this haystack with needles.");
  std::string str2 ("needle");

  // different member versions of find in the same order as above:
  std::size_t found = str.find(str2);
  if (found!=std::string::npos)
    std::cout << "first 'needle' found at: " << found << '\n';

  found=str.find("needles are small",found+1,6);
  if (found!=std::string::npos)
    std::cout << "second 'needle' found at: " << found << '\n';

  found=str.find("haystack");
  if (found!=std::string::npos)
    std::cout << "'haystack' also found at: " << found << '\n';

  found=str.find('.');
  if (found!=std::string::npos)
    std::cout << "Period found at: " << found << '\n';

  // let's replace the first needle:
  str.replace(str.find(str2),str2.length(),"preposition");
  std::cout << str << '\n';

  return 0;
}
-------------------------------------------------------------------------------- 
// cstr to string, cstring to string, char* to string
// strings and c-strings
#include <iostream>
#include <cstring>
#include <string>

int main ()
{
  std::string str ("Please split this sentence into tokens");

  char * cstr = new char [str.length()+1];
  std::strcpy (cstr, str.c_str());

  // cstr now contains a c-string copy of str

  char * p = std::strtok (cstr," ");
  while (p!=0)
  {
    std::cout << p << '\n';
    p = std::strtok(NULL," ");
  }

  delete[] cstr;
  return 0;
}
-------------------------------------------------------------------------------- 
Mon Nov 26 10:50:44 2018 
-------------------------------------------------------------------------------- 
opencv
Mat img.read(..) 
Mat mat;
Mat mat.create(int rows, int cols, int type)
Mat mat.create(img.rows, img.cols, int type)
/Users/cat/myfile/bitbucket/opencv/ImageBlending.cpp
-------------------------------------------------------------------------------- 
Fri Nov 23 10:44:34 2018 
-------------------------------------------------------------------------------- 
install opencv(3.4x) on My MacOS
brew install opencv
use pkg-config to retrieve lib info 
e.g: pkg-config --cflags --libs opencv
retrieve opencv lib info, it seems to be very useful

you can compile your cpp code with pkg-config,e.g.
g++ $(pkg-config --cflags --libs opencv) -std=c++11  yourFile.cpp -o yourFileProgram
-------------------------------------------------------------------------------- 
Wed Aug 15 17:14:22 2018 
Get error start mysql server on MacOS, mysql 5.7 and mysql 8.0
/**
 * detect file types from file extensions: image(.png, .jpeg, .jpg) and PDF(.pdf)
 *
 * @param fName is name of file.
 * @return image file: "IMG" or pdf file: "PDF", empty otherwise
 *
 */
 static String fileType(String fName){
    String type = "";
    Pattern pdfPattern = Pattern.compile("\\.pdf$", Pattern.CASE_INSENSITIVE);
    Matcher pdfMatcher = pdfPattern.matcher(fName);

    Pattern pattern = Pattern.compile("\\.png|\\.jpeg|\\.jpg$", Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(fName);

    if(matcher.find()){
        Print.pbl("fName=" + fName);
        type = "IMG";
    }else if(pdfMatcher.find()){
        Print.pbl("fName=" + fName);
        type = "PDF";
    }
    return type;
}
==================================================================  
Remove all versions of MySQL (I had 5.7.21, 5.7.22, and 8.0.11) : brew uninstall --force mysql

Confirm Removal and Repair : brew services list and then brew doctor

Rename original MySQL : mv /usr/local/var/mysql /usr/local/var/old.mysql

Install latest MySQL (currently 8.0.11) : brew install mysql

MySQL Secure Install : /usr/local/bin/mysql_secure_installation
==================================================================  
*haskell file manager*  *h file manager*  *file manager* 
ghci add
:m +System.FilePath.Posix
------------------------------------------------------------------ 
A library for FilePath manipulations, using Posix style paths on all platforms. Importing System.FilePath is usually better.

Given the example FilePath: /directory/file.ext

We can use the following functions to extract pieces.

    takeFileName gives "file.ext"  *file_ext*
    takeFileName "dog/cat" => cat
    takeDirectory gives "/directory"  
    takeExtension gives ".ext"
    dropExtension gives "/directory/file"
    takeBaseName gives "file"

And we could have built an equivalent path with the following expressions:

    "/directory" </> "file.ext".
    "/directory/file" <.> "ext".
    "/directory/file.txt" -<.> "ext".
==================================================================  
Remove symbol links in Haskell
------------------------------------------------------------------ 
Hard links
createLink :: FilePath -> FilePath -> IO () Source#

createLink old new creates a new path, new, linked to an existing file, old.

Note: calls link.

removeLink :: FilePath -> IO () Source#

removeLink path removes the link named path.

Note: calls unlink.

Symbolic links
createSymbolicLink :: FilePath -> FilePath -> IO () Source#

createSymbolicLink file1 file2 creates a symbolic link named file2 which points to the file file1.

Symbolic links are interpreted at run-time as if the contents of the link had been substituted into the path being followed to find a file or directory.

Note: calls symlink.
==================================================================  
cabal update
cabal install OpenGL
or runall to see all the installed packages
------------------------------------------------------------------ 
http://hackage.haskell.org/package/OpenGL
OpenGL 3.0.2.2 is Haskell binding for OpenGL system(GL verision 4.6)
and its accompanying utility system GLU, version 1.3
------------------------------------------------------------------ 
cabal update
cabal install OpenGLRaw  (current version is 3.3.1.0)
OpenGLRaw is a raw Haskell binding for the OpenGL 4.6 graphics system and lots of OpenGL extensions. 
It is basically a 1:1 mapping of OpenGL's C API, intended as a basis for a nicer interface.
==================================================================  
Sat Aug 18 11:16:09 2018 
------------------------------------------------------------------ 
type FilePath = String Source#

File and directory names are values of type String, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.

readFile :: FilePath -> IO String Source#

The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents.

writeFile :: FilePath -> String -> IO () Source#

The computation writeFile file str function writes the string str, to the file file.

appendFile :: FilePath -> String -> IO () Source#

The computation appendFile file str function appends the string str, to the file file.

Note that writeFile and appendFile write a literal string to a file. To write a value of any printable type, as with print, use the show function to convert the value to a string first.

main = appendFile "squares" (show [(x,x*x) | x <- [0,0.1..2]])
readIO :: Read a => String -> IO a Source#

The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program.

readLn :: Read a => IO a Source#

The readLn function combines getLine and readIO.

Exception handling in the I/O monad
type IOError = IOException Source#

The Haskell 2010 type for exceptions in the IO monad. Any I/O operation may raise an IOError instead of returning a result. For a more general type of exception, including also those that arise in pure code, see Exception.

In Haskell 2010, this is an opaque type.

ioError :: IOError -> IO a Source#

Raise an IOError in the IO monad.

userError :: String -> IOError Source#
==================================================================  
Wed Aug 22 11:15:59 2018 
OpenGL push and pop matrix, changed to preservingMatrix in Haskell

preservingMatrix :: IO a -> IO a Source#

Push the current matrix stack down by one, duplicating the current matrix, excute the given action, and pop the current matrix stack, replacing the current matrix with the one below it on the stack (i.e. restoring it to its previous state). The returned value is that of the given action. Note that a round-trip to the server is probably required. For a more efficient version, see unsafePreservingMatrix.
==================================================================  
Wed Aug 22 22:09:40 2018 
Set, find the powerset, insert, delete element etc. 
http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html
------------------------------------------------------------------ 
Vim set search ignorecase  noignorecase
:set noignorecase
------------------------------------------------------------------ 
==================================================================  
Thu Aug 23 11:37:33 2018 
package linear, Linear is the linear algebra library for basic linear algebra operation,
I just try to play around with the library, and it seems to me it is pretty "easy to use" library,

1. Install the package
   cabal update
   cabal install linear (my current version is linear-1.20.8)

2. import the module
   import Linear
http://hackage.haskell.org/package/linear-1.20.8/docs/Linear-Matrix.html
------------------------------------------------------------------ 
current Haskell version on my system
/Library/Frameworks/GHC.framework/Versions
7.10.2-x86_64
7.10.3-x86_64
8.4.3-x86_64
Current
------------------------------------------------------------------ 
#Many GHC versions can cause trouble on your MacOS
After install the haddock with 
cabal unregister haddock-api
cabal unregister haddock-library
and sound some strangle issue with old version GHC-7.10.x sth, need to manually remove it, and run cabal install haddock-xxx again
close the shell and reopen the shell again, 
and use 'which' command to find the haddock to verify the haddock it works

It seems to me there are issues when I have many versions of GHC in my MacOS,(three versions now..) 
7.10.2-x86_64
7.10.3-x86_64
8.4.3-x86_64
it causes the haddock does't work initially
==================================================================  
Fri Aug 24 17:21:26 2018 
here-string here string is crazy awesome
Here is how to run GHCi in your command line
ghci -v0 <<< ':r map'
------------------------------------------------------------------ 
Wed Aug 29 16:26:38 2018 
arrow with text above for function above
https://tex.stackexchange.com/questions/103988/rightarrow-with-text-above-it
------------------------------------------------------------------ 
Julia redirect output to file

You can use the @capture_out macro from Suppressor.jl 7, then write it to a file:

using Suppressor

output = @capture_out run(`ls`)

open("/var/log/myprogram.txt", "w") do io
    write(io, output)
end
-------------------------------------------------------------------------------- 
Thu Aug 30 17:53:00 2018 
file image file, png file, detect file type, filetype 
    /**
     * detect file types from file extensions: image(.png, .jpeg, .jpg) and PDF(.pdf)
     *
     * @param fName is name of file.
     * @return image file: "IMG" or pdf file: "PDF", empty otherwise
     *
     */
     static String fileType(String fName){
        String type = "";
        Pattern pdfPattern = Pattern.compile("\\.pdf$", Pattern.CASE_INSENSITIVE);
        Matcher pdfMatcher = pdfPattern.matcher(fName);

        Pattern pattern = Pattern.compile("\\.png|\\.jpeg|\\.jpg$", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(fName);

        if(matcher.find()){
            Print.pbl("fName=" + fName);
            type = "IMG";
        }else if(pdfMatcher.find()){
            Print.pbl("fName=" + fName);
            type = "PDF";
        }
        return type;
    }
-------------------------------------------------------------------------------- 
Fri Aug 31 13:33:30 2018, javadoc, generate javadoc, gene javadoc
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -Dshow=private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -Dshow=private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -private prefix_map.java
------------------------------------------------------------------ 
   /** 
    <pre>
    {@literal
        str = "vi cmd, vi help";
        [key =v]
        [key =vi]
        [key =c]
        [key =cm]
        [key =cmd]
        vi -> [vi cmd]
        c -> [cmd]
        v -> [vi cmd]
        cm -> [cmd]
        cmd -> [cmd]
        [key =v]
        [key =vi]
        [key =h]
        [key =he]
        [key =hel]
        [key =help]
        help -> [help]
        vi -> [vi help, vi cmd]
        c -> [cmd]
        v -> [vi help, vi cmd]
        h -> [help]
        cm -> [cmd]
        cmd -> [cmd]
        he -> [help]
        hel -> [help]
    }
    {@code 
        List<String> list = new ArrayList<>(Arrays.asList("vi cmd, vi help"));
        Map<String, Set<String>> map = new HashMap<>();
        prefixStringMap(list, map);
    }
    </pre>
    */
-------------------------------------------------------------------------------- 
Tue Sep  4 16:37:18 2018 
run shell script on spotlight
chmod +x ShowProcesses.command
You can also leave out the usual #!/bin/sh part on the first line.

Now, when someone double-clicks your script in the Mac Finder, the script will open a new Mac Terminal window, and then run the script inside that window. When it’s finished, the Terminal will display a “Process Completed” message, and the user can close the Terminal.

I did this recently for one of my sisters. She has an HP printer attached to her Mac, and from time to time the printer goes nuts and decides to eat the CPU. I run a top command in a script so she can confirm that this is the problem.

Simple example
As a simple example of this, create a file named Test.command somewhere on your Mac OS X filesystem, such as the Desktop, or a temp folder somewhere. Put some simple commands in the file, like this:

ls -al
pwd
-------------------------------------------------------------------------------- 
Fri Sep 28 17:40:50 2018 
haskell useful command 
ghc-pkg find-module  the module belongs to which packages 
-------------------------------------------------------------------------------- 
Sun Sep 30 15:20:33 2018 
install Pure Script, purescript
    printc 200 "[vimrc] Backup vimrc and bashrc to github "                 RN deprecated bower@1.8.4: We don't recommend using Bower for new projects. Please consider Yarn and Webpack or Parcel. You can read how to migrate legacy project here: https://bower.io/blog/2017/how-to-migrate-away-from-bower/
    /usr/local/bin/bower -> /usr/local/lib/node_modules/bower/bin/bower
    /usr/local/bin/pulp -> /usr/local/lib/node_modules/pulp/index.js

    > fsevents@1.2.4 install /usr/local/lib/node_modules/pulp/node_modules/fsevents
    > node install

    [fsevents] Success: "/usr/local/lib/node_modules/pulp/node_modules/fsevents/lib/binding/Release/node-v48-darwin-x64/fse.node" already installed
    Pass --update-binary to reinstall or --build-from-source to recompile
    /usr/local/lib
-------------------------------------------------------------------------------- 
Mon Oct 15 17:28:46 2018 
Install Agda stuff, it might be usefull in the future?
cabal install Agda failed...:)
stack install Agda-exe.. failed:)
home brew works...:(
==> Pouring agda-2.5.4.1.high_sierra.bottle.tar.gz
==> Caveats
To use the Agda standard library by default:
  mkdir -p ~/.agda
  echo /usr/local/lib/agda/standard-library.agda-lib >>~/.agda/libraries
  echo standard-library >>~/.agda/defaults

Emacs Lisp files have been installed to:
  /usr/local/share/emacs/site-lisp/agda
==> Summary
🍺  /usr/local/Cellar/agda/2.5.4.1: 1,369 files, 120MB
==> Caveats
==> emacs
Please try the Cask for a better-supported Cocoa version:
  brew cask install emacs

To have launchd start emacs now and restart at login:
  brew services start emacs
Or, if you don't want/need a background service you can just run:
  emacs
==> agda
To use the Agda standard library by default:
  mkdir -p ~/.agda
  echo /usr/local/lib/agda/standard-library.agda-lib >>~/.agda/libraries
  echo standard-library >>~/.agda/defaults

Emacs Lisp files have been installed to:
  /usr/local/share/emacs/site-lisp/agda
-------------------------------------------------------------------------------- 
import java.io.*;

abstract class Abst
{
	int n;
 	public Abst()
	{
	}
	abstract void face();
	public void print()
	{
		System.out.println("print");
	}
}

class myclass extends Abst
{
	void face()
	{
		System.out.println("face");
	}
}


class Abstract
{
	public static void main(String args[])
	{
		myclass a = new myclass();
		a.face();
		a.print();
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Add 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr1={9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
		int[] Arr2={9, 7};
		int[] Arr = new int[3];
		Arr = Add(Arr1, Arr2);
		for(int i=0; i<Arr1.length; i++)
			System.out.print(Arr1[i]+" ");
		System.out.println();

		for(int i=0; i<Arr2.length; i++)
			System.out.print(Arr2[i]+" ");
		System.out.println();

		for(int i=0; i<Arr.length; i++)
			System.out.print(Arr[i]+" ");
		System.out.println();
	}
	public static int[] Multiple(int[] Arr1, int[] Arr2)
	{

		return null;
	}
	public static int[] Add(int[] Arr1, int[] Arr2)
	{
		int[] Arr = null;
		int mod=0; int c=0;
		if(Arr1 != null && Arr1 != null)
		{
			int len1 = Arr1.length;
			int len2 = Arr2.length;
			Arr = new int[len1>len2?len1+1:len2+1];
			if(len1 > 0 && len2 > 0 && len1 >= len2)
			{
				for(int i=0; i<len1; i++)
				{
					if(len2-1-i >= 0)
					{
						mod = (c + Arr1[len1-1-i] + Arr2[len2-1-i])%10;
						c = (c + Arr1[len1-1-i] + Arr2[len2-1-i])/10;
					}
					else
					{
						mod = (c + Arr1[len1-1-i])%10;
						c = (c + Arr1[len1-1-i])/10;
					}
					Arr[len1+1-1-i]=mod;
				}
				if(c>0)
					Arr[0]=c;
			}
			else if(len1 > 0 && len2 > 0 && len2 > len1)
			{
				for(int i=0; i<len2; i++)
				{
					if(len1-1-i >= 0)
					{
						mod = (c + Arr1[len1-1-i] + Arr2[len2-1-i])%10;
						c = (c + Arr1[len1-1-i] + Arr2[len2-1-i])/10;
					}
					else
					{
						mod = (c + Arr1[len2-1-i])%10;
						c = (c + Arr1[len2-1-i])/10;
					}
					Arr[len2+1-1-i]=mod;
				}
				if(c>0)
					Arr[0]=c;
			}
		}
		if(c == 0)
		{
			int[] A = new int[Arr.length-1];
			for(int i=1; i<Arr.length; i++)
				A[i-1]=Arr[i];
			Arr=null;
			Arr = new int[A.length];
			for(int i=0; i<A.length; i++)
				Arr[i]=A[i];
		}
		return Arr;
	}
}
public class AddMultiString 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        System.out.println("9+98");
        System.out.println(Add("0", "1"));
    }
    public static String Add(String s1, String s2)
    {
        String ret = "0";
        if(s1 != null && s2 != null)
        {
            if(s1 == "0" && s2 == "0")
                return ret; 

            int len1 = s1.length();
            int len2 = s2.length();
            int maxlen = len1 > len2 ? len1 : len2;
            int[] A1 = new int[maxlen];
            int[] A2 = new int[maxlen];

            for(int i=0; i<maxlen; i++)
                A1[i] = A2[i] = 0;

            int index1 = 0, index2 = 0;
            while(index1 < len1)
            {
                A1[(maxlen-len1)+index1] = s1.charAt(index1)-'0';
                index1++;
            }

            while(index2 < len2)
            {
                A2[(maxlen-len2)+index2] = s2.charAt(index2)-'0';
                index2++;
            }

            int[] sum = new int[maxlen+1];
            int s=0, carry = 0, i=0;
            for(i=maxlen-1; i >= 0; i--)
            {
                s = A1[i] + A2[i] + carry;    
                sum[i+1] = s % 10;
                carry = s / 10;
            }
            if(carry > 0)
            {
                sum[0] = carry;
            }
            
            for(int j=0; j<maxlen+1; j++)
            {
                if((j == 0 && sum[j] > 0) || j > 0)
                    ret += sum[j] + "";
            }
        }
        return ret;
    }
}
import java.util.*;

class AddRemoveRandomClass
{
   Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
   int lastIndex;
   int max;
   int[] array;
   public AddRemoveRandomClass(int max)
   {
       lastIndex= 0;
       this.max = max;
       array = new int[max];
   }
   public void add(Integer num)
   {
       if(!map.containsKey(num) && lastIndex < max)
       {
           map.put(num, lastIndex);
           array[lastIndex] = num;
           lastIndex++;
       }
   }
   public void remove(int num)
   {
       Integer value = null;
       if((value = map.get(num)) != null)
       {
            map.remove(num);
            map.put(array[lastIndex], value);
            array[value] = array[lastIndex];
            lastIndex--;
       }
   } 
   public Integer getRandom()
   {
       if(lastIndex > 0)
       {
           Random ran = new Random(); 
           int index = ran.nextInt(lastIndex);
           return array[index];
       }
       else 
       {
           return -1;
       }
   }
   public void print()
   {
       for(int i=0; i < lastIndex; i++)
       {
            System.out.println("["+i+"]=["+array[i]+"]");
       }
   }
}

public class AddRemoveRandom 
{
				public static void main(String[] args)
				{
                    AddRemoveRandomClass stuff = new AddRemoveRandomClass(100);
                    stuff.add(20);
                    stuff.add(40);
                    stuff.add(2);
                    stuff.add(0);
                    stuff.print();
                    stuff.remove(40);
                    stuff.remove(2);
                    stuff.remove(0);
                    stuff.remove(20);
                    System.out.println();
                    stuff.print();
                    System.out.println("random=" + stuff.getRandom());
				}
}
public class AdjacentMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("AdjacentMatrix");
        int array[][] = new int[][]{
        { 0, 2, 3, 4, 5 },
        { 0, 0, 1, 2, 9 },
        { 0, 0, 0, 6, 5 },
        { 0, 0, 0, 0, 7 },
        { 0, 0, 0, 0, 0 }
        };
        int row = 0;
        int max = findMinPath(array, row);
        System.out.println("max=" + max);
    }
    static int findMinPath(int[][] array, int row)
    {
        int max = 0;
        if(array != null)
        {
            int height = array.length;
            int width  = array[0] != null ? array[0].length : 0;
            //System.out.println("height=" + height);
            //System.out.println("width=" + width);

            if(row < height)
            {
                int currMax = 0;
                for(int col=0; col < width; col++)
                {
                    if(array[row][col] != 0)
                    {
                        System.out.println("("+row+")"+array[row][col]+"->("+col+")");
                        int subMax = findMinPath(array, col) + array[row][col];
                        if(subMax > currMax) 
                            currMax = subMax;
                    }
                }
                //System.out.println("max=" + currMax);
                max = currMax;
            }
        }
        return max;
    }
}
public class AllSquareNumber 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SquareNumber(10);
    }
    //(X-1)^2 = X^2 -2X + 1
    //=>   X^2= (X-1)^2 + 2X + 1
    //=>   X^2= (X-1)^2 + (X-1) + X 
    static void SquareNumber(int n)
    {
        int prev = 0;
        int prevSquare = 0;   
        for(int curr=1; curr<=n; curr++)
        {
            prevSquare = prevSquare + prev + curr;
            System.out.println("["+prevSquare+"]");
            prev = curr;
        }
    }
}
import java.util.*;

public class AllUniqueSubPalindrome 
{
    public static void main(String[] args)
    {
        System.out.println("Palindrome With Space");
        int count = allUniqueSubPalindrome("aabaa");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);
        count = allUniqueSubPalindrome("a");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);
        count = allUniqueSubPalindrome("aa");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);

        System.out.println("count=" + count);
        boolean b = isPalindrome("abc");
        System.out.println("abc=" + b);
         b = isPalindrome("aba");
        System.out.println("aba=" + b);
        b = isPalindrome("a");
        System.out.println("a=" + b);
        b = isPalindrome("ab");
        System.out.println("ab=" + b);
        b = isPalindrome("aabbccee");
        System.out.println("aabbccee=" + b);
        System.out.println("================================================");

        List<String> list = allSubString("abcdefg");
        for(String str:list){
            System.out.println(str);
        }
        System.out.println("================================================");
        List<String> list1 = mySubstring("helloworld", "world");
        for(String str:list1){
            System.out.println(str);
        }

    } 
    public static boolean isPalindrome(String str) {
        boolean ret = true; 
        if( str != null){
            int len = str.length();
            for(int i=0; i<len/2 && ret; i++){
                if(str.charAt(i) != str.charAt(len-1-i)){
                    ret = false; 
                }
            }
        }
        return ret;
    }

    public static List<String> mySubstring(String str1, String str2) {
        List<String> list = new ArrayList<String>();
        int len1 = str1.length();
        int len2 = str2.length();
        for(int i=0; i<len1 - len2 + 1; i++){
            String str = str1.substring(i, i+len2);
            list.add(str);
        }
        return list;
    }
    public static List<String> allSubString(String str) {
        List<String> list = new ArrayList<String>(); 
        int len = str.length();
        for(int i=0; i<len; i++){
            for(int j=i; j<len; j++){
                String substr = str.substring(i, j+1);
                list.add(substr);
            }
        }
        return list;
    }
    public static int allUniqueSubPalindrome(String str) {
        Set<String> set = new HashSet<String>();
        if(str != null){
            int len = str.length();
            for(int i=0; i<len; i++){
                for(int j=i; j<len; j++){
                    String substr = str.substring(i, j+1);
                    if(!set.contains(substr) && isPalindrome(substr)){
                        set.add(substr);
                    }
                }
            }
        }
        return set.size();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.List;

public class AmazonLocker{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test();
    }

    static int countOp(long n){
        List<Long> list = new ArrayList<Long>();
        if(n == 0)
            list.add((long)0);
        else if(n > 0){
            while(n > 0){
                long r = n % 2;
                list.add(r);
                n = n/2;
            }
        }

        int sum = 0;
        for(int i=0; i<list.size(); i++){
            if(list.get(i) == 1)
                sum += i+1;
        }
        return sum;
    }
    static void test(){
        System.out.println(countOp(5));
        System.out.println(countOp(3));
        System.out.println(countOp(6));
    }

    
    // amazon locker, locker, problem, manhattan problem,
    static int[][] getLockerDistanceGrid(int cityLength, int cityWidth, int[] lockerXCoordinates, int[] lockerYCoordinates) {
        int[][] gridArray = new int[cityLength][cityWidth];
        
        for (int i = 0; i < cityLength; i++) {
            for (int j = 0; j < cityWidth; j++) {
                for (int k = 0; k < lockerXCoordinates.length; k++) {
                    int distance1 = Math.abs(lockerXCoordinates[k] - i + 1 );
                    int distance2 = Math.abs(lockerYCoordinates[k] - j + 1 );
                    int sumDistance = distance1 + distance2;
                    
                    if (k == 0) {
                        gridArray[i][j] = sumDistance;
                    } else {
                        if (sumDistance < gridArray[i][j]) {
                            gridArray[i][j] = sumDistance;
                        }
                    }
                }
            }
        }
        return gridArray;
    }
}
import java.util.*;
import java.math.BigInteger;


final class Sortkey{
    //[ file=sortkeyanagram.html title=""
    //================================================================================ 
    // java anagram 
    // Use sort technic to solve anagrams problem 
    // Use sorted str as key
    // {dog, god}
    // dgo->{dog, god}
    // -------------------------------------------------------------------------------- 
    static String sortStr(String s) {
        char[] clist = s.toCharArray();
        Arrays.sort(clist);
        return String.valueOf(clist);
    }
    static List<String> anagrams(List<String> list, String input) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();

        if(list != null && input != null) {

            for(String str : list) {
                String key = sortStr(str);
                List<String> l = map.get(key);
                if(l != null) {
                    l.add(str);
                    map.put(key, l);
                } else {
                    List<String> ll = new ArrayList<String>();
                    ll.add(str);
                    map.put(key, ll);
                }
            }
        }
        return map.get(sortStr(input));
    }
    //]
}

final class Better {
    public  static List<Integer> genePrima(int count) {
        List<Integer> list = new LinkedList<Integer>();
        list.add(2);
        Integer prime=3;
        int c=0;
        while(c < count) {
            boolean isPrime = true;
            for(Integer p : list) {
                if(prime % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(prime);
                c++;
            }
            prime = prime + 1;
        }
        return list;
    }
    public  static Map<Character, BigInteger> generate() {
        Map<Character, BigInteger> map = new HashMap<Character, BigInteger>();
        List<Integer> plist = genePrima(25);

        char ch = 'a';
        for(int i=0; i<26; i++) {
            Character chara = new Character(ch);
            BigInteger big = BigInteger.valueOf((plist.get(i).intValue()));
            map.put(chara, big);
            ch = (char)(ch + 1);
        }
        return map;
    }
    public  static Map<BigInteger, List<String>> anagram(List<String> list) {
        Map<Character, BigInteger> map = generate();
        Map<BigInteger, List<String>> wordMap = new HashMap<BigInteger, List<String>>();
        for(String word:list) {
            BigInteger product = BigInteger.valueOf(1);
            for(int i=0; i<word.length(); i++) {
                char ch = word.charAt(i);
                if(map.containsKey(ch))
                    product = product.multiply(map.get(ch));
            }
            if(wordMap.containsKey(product)) {
                List<String> wordList = wordMap.get(product);
                wordList.add(word);
                wordMap.put(product, wordList);
            } else {
                List<String> wordList = new ArrayList<String>();
                wordList.add(word);
                wordMap.put(product, wordList);
            }
            product = BigInteger.valueOf(1);
        }
        return wordMap;
    }
}

final class Basic {
    public static List<Integer> getPrime(int n) {
        int k = 0;
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int num = 3;
        while(k < n) {
            boolean isPrime = true;
            for(Integer p : list) {
                if( num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(num);
                k++;
            }
            num++;
        }
        return list;
    }

    //[ file=anagrambasic.html title=""
    public static Map<String, Integer> primeMap() {
        List<Integer> list = getPrime(26);
        Map<String, Integer> map = new HashMap<String, Integer>();
        char ch = 'a';
        for(Integer p : list) {
            map.put(ch + "", p);
            ch += 1;
        }
        return map;
    }

    public static Integer getProduct(String str) {
        Map<String, Integer> map = primeMap();
        int p = 1;
        for(int i=0; i<str.length(); i++) {
            p *= map.get((str.charAt(i) + "").toLowerCase());
        }
        return p;
    }

    public static List<String> anagrams(List<String> list, String str) {
        Map<Integer, List<String> > map = new HashMap<Integer, List<String>>();

        for(String s : list) {
            List<String> l = map.get(getProduct(s));
            if(l != null) {
                l.add(s);
                map.put(getProduct(s), l);
            } else {
                List<String> ll = new ArrayList<String>();
                ll.add(s);
                map.put(getProduct(s), ll);
            }
        }
        return map.get(getProduct(str));
    }
    //]
}

public class Anagram {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test0();
        test1();
        test2();
        test3();
    }

    public static void test0() {
        System.out.println("test1()");
        List<String> list = new ArrayList<String>() {
            {
                add("dog");
                add("god");
                add("nice");
                add("debitcard");
                add("badcredit");
            }
        };
        Map<BigInteger, List<String>> wordMap = Better.anagram(list);
        for(BigInteger big: wordMap.keySet()) {
            List<String> wordlist = wordMap.get(big);
            System.out.println(big);
            for(String word: wordlist) {
                System.out.println(word);
            }
            System.out.println();
        }
    }

    public static void test1(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        words.add("God");
        words.add("Barack");
        words.add("Obama");
        List<String> list = Basic.anagrams(words, "dog");
        for(String s : list){
            System.out.println(s);
        }
    }

    public static void test2(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        List<String> list = Basic.anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }

    public static void test3(){
        List<String> words = new ArrayList<String>();
        words.add("");
        List<String> list = Basic.anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Anagrams2{

    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        words.add("God");
        words.add("Barack");
        words.add("Obama");
        List<String> list = anagrams(words, "dog");
        for(String s : list){
            System.out.println(s);
        }
    }

    static void test1(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        List<String> list = anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }

    static void test2(){
        List<String> words = new ArrayList<String>();
        words.add("");
        List<String> list = anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }


    //[file=anagram2.html title=""
    static List<Integer> getPrime(int n){
        int k = 0;
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int num = 3;
        while(k < n){
            boolean isPrime = true;
            for(Integer p : list){
                if( num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime){
                list.add(num);
                k++;
            }
            num++;
        }
        return list;
    }

    static Map<String, Integer> primeMap(){
        List<Integer> list = getPrime(26);
        Map<String, Integer> map = new HashMap<String, Integer>();
        char ch = 'a';
        for(Integer p : list){
            map.put(ch + "", p);
            ch += 1;
        }
        return map;
    }

    static Integer getProduct(String str){
        Map<String, Integer> map = primeMap();
        int p = 1;
        for(int i=0; i<str.length(); i++){
            p *= map.get((str.charAt(i) + "").toLowerCase());
        }
        return p;
    }

    static List<String> anagrams(List<String> list, String str){
        Map<Integer, List<String> > map = new HashMap<Integer, List<String>>();

        for(String s : list){
            List<String> l = map.get(getProduct(s));
            if(l != null){
                l.add(s);
                map.put(getProduct(s), l);
            }else{
                List<String> ll = new ArrayList<String>();
                ll.add(s);
                map.put(getProduct(s), ll);
            }
        }
        return map.get(getProduct(str));
    }
    //]
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

// amazon test anagram amazontest amazon_test
public class AnagramIndex{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();

        String haystack = "abdcghbaabcdij";
        String needle = "bcda";
        List<Integer> list = getAnagramIndices1(haystack, needle);
        Print.pbl(list);
        Aron.end();
    }

    static void test1(){
        Aron.beg();

        String haystack = "bbbababaaabbbb";
        String needle = "ab";
        List<Integer> list = getAnagramIndices1(haystack, needle);
        Print.pbl(list);

        Aron.end();
    }

    public static List<Integer> getAnagramIndices1(String haystack, String needle) {
        List<Integer> list = new ArrayList<Integer>(); 
        int len = needle.length();
        int hlen = haystack.length();
        String sortNeedle = Aron.sortStr(needle);
        for(int i=0; i<hlen; i++){
            if(len  + i <= hlen){
                String subStr = haystack.substring(i, len + i); 
                String s1 = Aron.sortStr(subStr);
                if(s1.equals(sortNeedle)){
                    list.add(i);
                }
                Print.pbl(subStr);
            }
        }
        return list;
    }
} 


import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class MyNode{
    String data;
    int count;
    public MyNode(String data, int count){
        this.data = data;
        this.count = count;
    }
}

class TextMap{

    public TextMap(){
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }
}

public class AnimalLogic{
    public static void main(String[] args) {
//        test0();
//        test1();
        //test2();
//        test3();
//        test4();
//        test5();
//        test00();
//        test11();
//        test12();
        test13();
    }

    static void test00(){
        Aron.beg();
        
        int n = random(1);
        Print.pbl("n=" + n);

        for(int i=0; i<10; i++){
            int n1 = random(2);
            Print.pbl("n1=" + n1);
        }

        Aron.end();
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public static void test12(){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }

    public static void test13(){
        Aron.beg();

        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        Map<Map<String, String>, Map<Integer, String>> revMap = createBiMap(map);

        String seedFirst = "one";
        String seedSecond = "two";
        int numWords = 10;
        List<String> wordList = generateText(numWords, seedFirst, seedSecond, map, revMap);
        Aron.printList(wordList);
    }

    public static List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }

//    public static Map<String, String> newKeyMap(Map<String, String> map, String newWord){
//        map.get
//    }

    public static Map<Map<String, String>, Map<Integer, String>> createBiMap(Map<Map<String, String>, Map<String, Integer>> map){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 
        return revMap;
    }

    public static void test11(){
        Aron.beg();
        String[] arr = {"dog", 
                        "cat", 
                        "cow", 
                        "dog", 
                        "cat", 
                        "cow", 
                        "rat", 
                        "pig"}; 

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();

        List<String> list = getWords("./text/animal_logic.txt"); 
        //Map<Map<String, String>, Map<String, Integer>> map = createMap(arr); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }


    public static Map<Map<String, String>, Map<String, Integer>> createMap(List<String> list){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        for(int i=0; i<list.size() - 2; i++){
            Map<String, String> key = new HashMap<String, String>(); 
            Map<String, Integer> value = new HashMap<String, Integer>(); 
            key.put(list.get(i), list.get(i+1)); 
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key); 
            if(v == null){
                map.put(key, value);
            }else{
                Integer n = v.get(list.get(i+2));
                if(n == null){
                    v.put(list.get(i+2), 1);
                }else{
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    public static Map<Map<String, String>, Map<String, Integer>> createMap(String[] arr){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        List<String> list = Arrays.asList(arr); 
        map = createMap(list);
        return map;
    }
    public static void test0(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");

        String fileName = "text/myfile.txt";
        List<String> list = getWords(fileName); 

        for(String s : list){
            List<String> pairList = pair(s); 
            for(String k : pairList){
                if(map.containsKey(k)){
                    int count = map.get(k);
                    count++;
                    map.put(k, count);
                }else{
                    map.put(k, 1);
                }
            }
        }
        
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        } 
        
        Aron.printList(list);

        Aron.end();
    }
    public static List<String> pair(String s){
        List<String> list = new ArrayList<String>(); 
        if(s.length() > 1){
            for(int k=0; k < s.length(); k++){
                for(int i=0; i < s.length()-(1 + k); i++){
                    list.add(s.substring(i, i+(2 + k)));
                }
            }
        }
        return list;
    }

    // read a text file capture all words
    // word: non-whitespace char 
    public static List<String> getWordsNonWhiteSpace(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)\\S+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read a text file and capture all words
    // word: a-z char
    public static List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }
    public static void test1(){
        Aron.beg();
        
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
                
        String fileName = "text/textfile.txt";
        List<String> list = getWordsNonWhiteSpace(fileName);
        Aron.printList(list);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        String s = "abc";                
        int len = s.length();

            // "abc" [ "" -> "abc"]
            //       [ "a" -> "bc"]
            //       [ "ab"-> "c" ]
            for(int j=0; j<len-1; j++){
                    String prefix = s.substring(0, j);
                    String suffix = s.substring(j, len);
                    Print.pbl("prefix=" + prefix);
                    Print.pbl("suffix=" + suffix);
            }

        Aron.end();
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public static Map<Integer, String> inverseMap(Map<String, Integer> map){

        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        return revMap;
    }
    public static void test5(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        Map<Integer, String> revMap = inverseMap(map); 

        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        String s = "abc";                
        
        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        
        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        // 1 -> k1
        // 2 -> k2
        // 3 -> k2

        Aron.end();
    }
} 

import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;


// Markov chain algorithm, markov chain generate text, random text, rand text, 
// random markov chain text
//
// java javafx, javaui, java ui, java ui api, javafx ui, javafx api
// javafx textarea textfield, javafx messagebox, javafx control, javavx vbox hbox, javafx button
// animal logic task, animal logic project, animallogic, animal_logic task
final class TextMap {
    String fileName;
    Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() { }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read file line by line to list
    public List<String> readFile(String fileName) {
        List<String> list = new ArrayList<String>();
        try {
            BufferedReader in = new BufferedReader(new FileReader(fileName));
            String str;
            while((str = in.readLine()) != null) {
                list.add(str.trim());
            }
            in.close();
        } catch(IOException io) {
            io.printStackTrace();
        }
        return list;
    }


    // generate map from prefix -> suffix, e.g.  <my, dog> -> <is, 1>
    public Map<Map<String, String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            Map<String, String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.put(list.get(i), list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    // generate list of words from prefix, suffix
    public List<String> generateText(int numWords, String prefix, String suffix, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {
        List<String> list = new ArrayList<String>();

        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {
                        int ranKey = random(revValueMap.size());
                        String newSuffix = revValueMap.get(ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }

    // generate map: <prefix, suffix> -> <frequency, word>
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<Map<String, String>, Map<String, Integer>> map) {
        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);
            }
        }
        return tableMap;
    }

    public List<String> textGeneMap() {
        List<String> list = getWords();
        map = prefixSuffixMap(list);

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                str += keyEntry.getKey() + " " + keyEntry.getValue() + " => ";

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                str += "\n";
            }
            retList.add(str);
        }
        return retList;
    }

    // generate list of words from user inputs: maximum number of words, prefix, and suffix
    public List<String> processFile(int maxWords, String prefix, String suffix) {
        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class AnimalLogicTask  extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");
        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                if(fileName != null) {

                    String[] prefixArr = prefixTF.getText().trim().split("\\s+");
                    String[] suffixArr = suffixTF.getText().trim().split("\\s+");
                    if(prefixArr.length == 2 && suffixArr.length == 1) {
                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }
                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }
                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 1000, 800));
        primaryStage.show();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.stream.Collectors;

class Animal{
    public void speak(){
    }
    public String getType(){
        return "generic animal";
    }
};

class Cat extends Animal{
    @Override
    public void speak(){
    }
    @Override
    public String getType(){
        return "cat animal";
    }
};

// subtype and generic type in Java
// List<Object> lo = new ArrayList<Object>(); 
// List<String> ls = new ArrayList<String>();
// lo = ls; // error


// create your own annotation

@interface MyDefault{
    boolean value() default true;
}


public class AnnotationExample{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        
        // immutable list
        List<Integer> list = Arrays.asList(1, 2, 3);
        
        Set<String> set1 = new HashSet<String>(Arrays.asList("cat", "dog"));

        Print.pp(arr2d);


        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        List<Object> lo = new ArrayList<Object>();
        List<String> ls = new ArrayList<String>();
        lo.add("dog");
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import java.util.List;
import java.util.function.Predicate;
import java.util.ArrayList;

import classfile.*;

class Employee {
    public int id;
    public String name;
    public int sal;
    public Employee(int id,String name,int sal  ) {
        this.id = id;
        this.name = name;
        this.sal = sal;
    }
    public static List<Employee> getEmpList() {
        List<Employee> list = new ArrayList<>();
        list.add(new Employee(1, "A", 2000));
        list.add(new Employee(2, "B", 3000));
        list.add(new Employee(3, "C", 4000));
        list.add(new Employee(4, "D", 5000));
        return list;
    }
}

public class AnyMatch {
    public static void main(String[] args) {
        Predicate<Employee> p1 = e -> e.id < 10 && e.name.startsWith("A");
        Predicate<Employee> p2 = e -> e.sal < 10000;
        List<Employee> list = Employee.getEmpList();
        //using allMatch
        boolean b1 = list.stream().allMatch(p1);
        System.out.println(b1);
        boolean b2 = list.stream().allMatch(p2);
        System.out.println(b2);
        //using anyMatch
        boolean b3 = list.stream().anyMatch(p1);
        System.out.println(b3);
        boolean b4 = list.stream().anyMatch(p2);
        System.out.println(b4);
        //using noneMatch
        boolean b5 = list.stream().noneMatch(p1);
        System.out.println(b5);
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class AutoComplete{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        List<String> list = Arrays.asList("cat", "cow"); 
        Map<String, List<String>> map = autocomplete(list);
        Aron.printMap(map);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        List<String> list = Arrays.asList("cat", "cow", "ban", "ball", "banana", "b"); 
        Map<String, List<String>> map = autocomplete(list);
        Aron.printMap(map);

        Aron.end();
    }

    //[ file=autocomplete.html title=""
    // auto complete, autocomplete
    // 1:01 - 1:34
    //-------------------------------------------------------------------------------- 
    // cat
    // cow
    // c -> [at, ow]
    // ca ->[t]
    // co ->[w] 
    public static Map<String, List<String>> autocomplete(List<String> list){
        Map<String, List<String>> map = new HashMap<>();
        for(String s : list){
            int len = s.length();
            for(int i=0; i<len; i++){
                String prefix = s.substring(0, i);
                String suffix = s.substring(i, len);

                if(prefix.length() > 0){
                    List<String> l = map.get(prefix);
                    if( l != null){
                        l.add(suffix);
                        map.put(prefix, l);
                    }else{
                        List<String> ll = new ArrayList<>();
                        ll.add(suffix);
                        map.put(prefix, ll);
                    }
                }
            }
        }
        return map;
    }
    //]


}

import java.util.*;
import classfile.*;

class BSTDict{
    public Node root;
    public BSTDict() {
        root = null;
    }

    public void insert(int n) {
        if(root == null) {
            root = new Node(n);
        } else {
            Node curr = root;
            boolean end = false;
            while(curr != null && !end) {
                if(n < curr.data) {
                    if(curr.left == null) {
                        curr.left = new Node(n);
                        end = true;
                    } else
                        curr = curr.left;
                } else {
                    if(curr.right == null) {
                        curr.right = new Node(n);
                        end = true;
                    } else
                        curr = curr.right;
                }
            }
        }
    }
    public void OneQueue(Node curr) {
        if(curr != null) {
            Queue<Node> q = new LinkedList<Node>();
        }
    }
    public void inorder(Node curr) {
        if(curr != null) {
            inorder(curr.left);
            System.out.println("[" + curr.data + "]");
            inorder(curr.right);
        }
    }
    public boolean findNode(int n) {
        Node curr = root;
        boolean ret = false;
        if(curr != null) {
            if(n < curr.data)
                curr = curr.left;
            else if(n > curr.data)
                curr = curr.right;
            else
                ret = true;
        }
        return ret;
    }
    public boolean findSum(Node r, int n) {
        boolean ret = false;
        if(r == null) {
            if(n == 0)
                ret = true;
        } else if(r != null) {
            boolean bl = findSum(r.left, n - r.data);
            boolean br = findSum(r.right, n - r.data);
            ret = (bl || br);
        }
        return ret;
    }
}

public class BSTDictionary{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        String str1 = "tenny";
        String str2 = "tea";
        String str3 = "ten";
        String str4 = "tee";
        Print.p(str1.hashCode());
        Print.p(str2.hashCode());
        Print.p(str3.hashCode());
        Print.p(str4.hashCode());

        BSTDict bst = new BSTDict();
        bst.insert(str1.hashCode());
        bst.insert(str2.hashCode());
        bst.insert(str3.hashCode());
        bst.insert(str4.hashCode());
        
        Aron.end();
    }
}

import java.io.*;
import java.lang.String;
import java.util.*;

// preorder to inorder
// convert preorder to inorder
class Node {
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST {
	Node root;
	public BST()
	{ root = null;};
	public void insert(int n) {
		if(root == null) { 
            root = new Node(n); 
        }
		else { 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end) {
				if(n < cur.data) { 
					if(cur.left == null) { 
                        cur.left = new Node(n);  
                        break;
                    }
                    else 
                        cur = cur.left;
				}else {
					if(cur.right == null) { 
                        cur.right = new Node(n); 
                        break;
                    }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur) {
		if(cur != null) {
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public boolean Find(int n) {
		Node cur = root;
		boolean ret = false;
		if(cur != null) {
			if(n < cur.data)
				cur = cur.left;
			else if(n > cur.data)
				cur = cur.right;
			else
				ret = true;
		}
		return ret;
	}
	public boolean findSum(Node r, int n) {
		boolean ret = false;
		if(r == null) { 
			if(n == 0)
				ret = true;
		}
		else if(r != null) {
			boolean bl = findSum(r.left, n - r.data);
			boolean br = findSum(r.right, n - r.data);
			ret = (bl || br);
		}
		return ret;
	}
	
	public void LevelOrder() {
		Node cur = root;
		Queue<Node> Q1 = new LinkedList<Node>();
		Queue<Node> Q2 = new LinkedList<Node>();
		Q1.offer(cur);
		while(Q1.peek() != null || Q2.peek() != null) {
			while(Q1.peek() != null) {
				Node top = Q1.poll();
				System.out.print(top.data + " ");
				if(top.left != null)
					Q2.offer(top.left);
				if(top.right != null)
					Q2.offer(top.right);
			}
			System.out.println();
			while(Q2.peek() != null) {
				Node top = Q2.poll();
				
				System.out.print(top.data + " ");
				if(top.left != null)
					Q1.offer(top.left);
				if(top.right != null)
					Q1.offer(top.right);
			}
			System.out.println();
		}
	}
	public Node getRoot() { 
        return root;
    }
}
class BSTfromPreOrderInOrder {
	public static void main(String args[]) {
		int[] pArr = {10, 5, 1, 7, 15, 12, 20};
		int[] iArr = {1, 5, 7, 10, 12, 15, 20};
		
		ArrayList<Node> preArr = new ArrayList<Node>();
		ArrayList<Node> inArr = new ArrayList<Node>();
		for(int i=0; i<pArr.length; i++) {
			preArr.add(new Node(pArr[i]));
			inArr.add(new Node(iArr[i]));
		}
		Node root = buildBST(preArr, inArr);
		Inorder(root);

	}
	public static void split(ArrayList<Node> preArr, ArrayList<Node> inArr, ArrayList<Node> preL_tree,ArrayList<Node> preR_tree,ArrayList<Node> inL_tree, ArrayList<Node> inR_tree) {
	if(preArr != null && inArr != null && preL_tree != null && preR_tree != null && inL_tree != null && inR_tree != null) {
			int prelen = preArr.size(), inlen = inArr.size();	
			if(prelen > 0) {
				boolean L = true;
				Node root = preArr.get(0);
				for(int i=0; i<inlen; i++) {
					if(L == true && inArr.get(i).data != root.data)
						inL_tree.add(inArr.get(i));
					else if(inArr.get(i).data == root.data)
						L = false;
					else if(L == false && inArr.get(i).data != root.data) {
						inR_tree.add(inArr.get(i));
					}
				}
				for(int i=1; i<prelen; i++) {
					if(i < (inL_tree.size() + 1))
						preL_tree.add(preArr.get(i));	
					else
						preR_tree.add(preArr.get(i));	
				}
			}
		}
	}	

	public static Node buildBST(ArrayList<Node> preArr, ArrayList<Node> inArr) {
		Node parent = null;
		if( preArr != null && inArr != null) {
			int prelen = preArr.size(), inlen= inArr.size();
			if(prelen > 0) {
				parent = new Node(preArr.get(0).data);
				ArrayList<Node> preL_tree = new ArrayList<Node>();
				ArrayList<Node> preR_tree = new ArrayList<Node>();

				ArrayList<Node> inL_tree = new ArrayList<Node>();
				ArrayList<Node> inR_tree = new ArrayList<Node>();
				split(preArr, inArr, preL_tree, preR_tree, inL_tree, inR_tree);
				parent.left 	= buildBST(preL_tree, inL_tree);
				parent.right 	= buildBST(preR_tree, inR_tree);
			}
		}
		return parent;
	}	

	public static void Inorder(Node root) {
		if(root != null) {
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

// select dep.name from Department where id = 100 
// select dep.id   from Department where name = "David"
class Department{
    Map<Integer, String> map;
    public Department(Map<Integer, String> map){
        this.map = map;
    }
}

class DB{

}

public class BaiduDatabase{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;

public class BalanceBracket 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        String s = "[12(3)4[5)]";
        char prev = 'a';
        int[] arr = new int[1];
        arr[0] = 0;
        boolean ret = balanceBracket(s);
        System.out.println("ret="+ret);
    }
    public static boolean balanceBracket(String s)
    {
        boolean ret = true;
        Stack<Character> stack = new Stack<Character>();        
        if(s != null)
        {
            for(int i=0; i<s.length(); i++)
            {
                char ch = s.charAt(i);
                if(ch == '[' || ch == '(')
                {
                    stack.push(ch);
                }
                else if(ch == ']' || ch == ')')
                {
                    Character left = stack.pop();
                    if(!(left == '[' && ch == ']' || left == '(' && ch == ')'))
                        ret = false;
                }
                else if(!('0' <= ch && ch <= '9'))
                {
                    ret = false;
                }

            }
            if(!stack.empty())
                ret = false;
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class BinDeleteNode{
    static Node prevNode = null;
    public static void main(String[] args) {
//        test9();
//        test10();
//        test11();
//        test12();
//        test13();
        test14();
    }
    
    static void test9(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 15;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test11(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        int n = 7;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test12(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test13(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 12;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test14(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test15(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 13;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }


    public static Node findMin(Node r){
        Node curr = r;
        while(r != null && curr.left != null){
            curr = curr.left;
        }
        return curr;
    }

    // gf http://quiz.geeksforgeeks.org/binary-search-tree-set-2-delete/
    public static Node delete(Node r, int n){
        if(r != null){
            if(n < r.data)
                r.left = delete(r.left, n);
            else if(n > r.data)
                r.right = delete(r.right, n);
            else{
                if(r.left == null)
                    return r.right;
                else if(r.right == null)
                    return r.left;
                else{
                    Node min = findMin(r.right);
                    r.data = min.data;
                    r.right = delete(r.right, min.data);
                }

            }
            return r;
        }
        return null;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class BinDict{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        Aron.beg();
        BST bst = new BST();

        // read dictionary file
        List<String> list = Aron.readFile("text/words.txt"); 

        // add dictionary file to list
        int count = 0;
        while(count < list.size()){
            Random ran = new Random();
            int index = ran.nextInt(list.size());
            //Print.p("index=[" + index + " " + list.size());
            bst.insert(list.indexOf(index));
            list.remove(index);
            //Print.p(list.indexOf(index));
        }

          Aron.inorder(bst.root);
//        Test.t(bst.contains("cat".hashCode()));
//
//        Print.pl("level=" + Aron.level(bst.root));

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(1);
        bst.insert(2);
        bst.insert(3);

        Test.t(Aron.height(bst.root) == 2);
        Test.t(Aron.level(bst.root) == 3);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        
        Aron.end();
    } 
} 
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

//[ file=binite.html title=""
// binary iterator
class BinaryIterator {
    Node curr;
    Stack<Node> stack;
    public BinaryIterator(Node root) {
        curr = root;
        stack = new Stack<Node>();
    }

    public boolean hasNext() {
        return (curr != null || stack.isEmpty() == false);
    }

    public Node next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node;
            }
        }
        return null;
    }
}
//]

public class BinIterator {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    
    static void test0() {
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);

        BinaryIterator bi = new BinaryIterator(bst.root);
        System.out.println("\n---------------------------------");
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------");
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);

        BinaryIterator bi = new BinaryIterator(bst.root);
        System.out.println("\n---------------------------------");
        Aron.inorder(bst.root);
        System.out.println();
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(20);
        bst.insert(18);

        BinaryIterator bi = new BinaryIterator(bst.root);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------");
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class BinToCircularDll 
{

	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);

		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
        
		Node r = b1.getRoot();
		//Node t = BinToDLL(r);
        Inorder(r);
        System.out.println("");
        BinToCircularDll(r);
        int k=0;
        if(head != null)
        {
            Node curr = head;
            Node right = head.right;
            if(curr == right) //one node
                System.out.print(curr.data + " ");
            else
            {
                System.out.print(head.data + " ");
                while(head != right)
                {
                    System.out.print(right.data + " ");
                    right = right.right;
                }
            }
        }
	}

    static Node head = null;
    static Node prev = null;
    public static void BinToCircularDll(Node curr)
    {
        if(curr != null)
        {
            BinToCircularDll(curr.left);
            if(prev == null)
                head = curr;
            else
            {
                prev.right = curr;
                curr.left = prev;
            }
            prev = curr;
            Node right = curr.right;
            if(head != null)
            {
                head.left = curr;
                curr.right = head;
            }
            BinToCircularDll(right);
        }
    }


    public static void Inorder(Node r)
    {
        if(r != null)
        {
            Inorder(r.left);
            System.out.print("["+r.data+"]");
            Inorder(r.right);
        }
    }
	public static Node BinToDLL(Node r)
	{
		Node h=null, t=null, cur=null;
		Queue<Node> queue = new LinkedList<Node>();
		if(r != null)
		{
			queue.offer(r);
			while(queue.peek() != null)
			{
				Node no = queue.remove();
				if(no != null && no.left != null)
				{queue.offer(no.left); no.left=null;}

				if(no != null && no.right!= null)
				{queue.offer(no.right); no.right=null;}

				if(h == null)
				{ h = cur = no; }
				else 
				{ no.left = cur;
					cur.right = no;
					cur = cur.right;
				}
			}
			t = cur;
		}
		return t;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
	
	public Node getRoot()
	{ return root;}
}
class BinToDLLRecur 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(1);
		b1.Insert(2);
		b1.Insert(3);
		b1.Insert(4);
		b1.Insert(5);
		b1.Insert(6);
		b1.Insert(7);
		b1.Insert(8);
		b1.Inorder(b1.getRoot());

		Node r = BinToDLL(b1.getRoot());
		boolean bool = isCircularList(r);
		System.out.println("bool=" + bool);
        Node first = r;
        Node left = r.left;
        while( first != left)
        {
		    System.out.println("left=" + left.data);
            left = left.left;
        }

	}
	public static boolean isCircularList(Node r)
	{
		boolean ret = false;
		if(r != null)
		{
			Node cur = r;
			Node next = cur.right;

			while(next != null && cur != next)
			{
				System.out.print("cur="+cur.data + " ");
				if(cur != null)
				cur = cur.right;
				
				next = next.right;
				if(next != null)
					next = next.right;
			}
			if(cur == next)
			{
				System.out.print("cur="+cur.data + " ");
				ret = true;
			}
		}
		return ret;
	}
    
    //convert bst to double
	static Node prev=null;
	static Node head=null;
	public static Node BinToDLL(Node r)
	{
		if(r != null)
		{
			BinToDLL(r.left);
			
			if(prev != null)
			{ 
                prev.right= r;
            }
			else
				head = r;
			r.left = prev;
            prev = r;
			Node right = r.right;

            if(head != null)
                head.left = r;
			r.right = head;

			BinToDLL(right);
		}
		return head;
	}
	public static boolean isBST(Node r)
	{

		if(r == null)
			return true;
		else
		{
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	public static boolean equalBinaryTree(Node r1, Node r2)
	{
		if(r1==null && r2==null)
			return true;
		else if(r1 != null && r2 != null)
		{
			if(r1.data != r2.data)
					return false;
			if(!equalBinaryTree(r1.left, r2.left)) 
					return false;
			if(!equalBinaryTree(r1.right, r2.right))
					return false;
		}
		else 
			return false;
		return true;
	}
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class Pair {
    Queue<Integer> queue = new LinkedList<Integer>();
    int index;
    public Pair() {
        index = -1;
    }
}

class BinarySearch {
    public static void main(String args[]) {
        Test1();
        Test2();
        Test3();
        Test4();
        test5();
        test6();
    }
    static void test5(){
        Aron.beg();

        int[] arr = {0, 2, 3, 5};
        int lo = 0;
        int hi = arr.length - 1;
        int key = 6;
        List<Integer> list = new ArrayList<Integer>(); 

        BinSearchBetween(arr, lo, hi, key, list);
        Aron.printList(list);

        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        int[] arr = {-Integer.MAX_VALUE, 0, 2, 3, 5, Integer.MAX_VALUE};
        int lo = 0;
        int hi = arr.length - 1;
        int key = -1;
        List<Integer> list = new ArrayList<Integer>(); 

        BinSearchBetween(arr, lo, hi, key, list);
        Aron.printList(list);

        Aron.end();
    } 

    public static void BinSearchIndex(int[] arr, int left, int right, int key, Pair pair) {
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            if(key < arr[middle]) {
                if(pair.queue.size() >= 2)
                    pair.queue.remove();
                pair.queue.add(middle-1);

                BinSearchIndex(arr, left, middle - 1, key, pair);
            } else if(key > arr[middle]) {
                if(pair.queue.size() >= 2)
                    pair.queue.remove();
                pair.queue.add(middle+1);

                BinSearchIndex(arr, middle + 1, right, key, pair);
            } else
                pair.index = middle;
        }
    }

    public static boolean BinSearch(int[] arr, int left, int right, int key) {
        boolean ret = false;
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            if(key < arr[middle]) {
                ret = BinSearch(arr, left, middle - 1, key);
            } else if(key > arr[middle]) {
                ret = BinSearch(arr, middle + 1, right, key);
            } else
                ret = true;
        }
        return ret;
    }
    public static boolean BinSearchBetween(int[] arr, int left, int right, int key, List<Integer> list) {
        boolean ret = false;
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            list.add(middle);

            if(key < arr[middle]) {
                ret = BinSearchBetween(arr, left, middle - 1, key, list);
            } else if(key > arr[middle]) {
                ret = BinSearchBetween(arr, middle + 1, right, key, list);
            } else
                ret = true;
        }
        return ret;
    }


    public static void Test1() {
        int[] arr = {1, 2, 3, 5};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test2() {
        int[] arr = {1};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test3() {
        int[] arr = {2};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test4() {
        int[] arr = {0, 2, 3, 5};
        int left = 0;
        int right = arr.length - 1;
        int key = 6;
        Pair pair = new Pair();

        BinSearchIndex(arr, left, right, key, pair);
        for(Integer p:pair.queue) {
            System.out.println("p="+p);
        }
        System.out.println("index="+pair.index);
    }
}

//Binary search in two dimension is based on one dimension search
public class BinarySearch2D 
{
    public static void main(String[] args)
    {
        Test1();
        Test2();
    }

    public static void printArray(int[][] array, int height, int width)
    {
        for(int col=0; col<=height; col++)
        {
            for(int row=0; row<=width; row++)
            {
                System.out.print("["+array[col][row]+"]");
            }
            System.out.println();
        }
    }
    public static void Test1()
    {
        System.out.println("Binary search in two dimension");
        int[][] array = {{1,  100, 200, 201},
                         {5,  105, 205, 1000},
                         {11, 107, 300, 1001},
                         {13, 108, 302, 1002},
                         {104,301, 305, 1003}};
        int key = 201;
        int rlo = 0;
        int rhi = array[0].length-1;
        int clo = 0;
        int chi = array.length-1;
        printArray(array, chi, rhi);

        boolean ret2 = BinSearch2D(array, clo, rlo, chi, rhi, key);
        System.out.println("ret2="+ret2);

        boolean ret3 = binSearchMN(array, clo, rlo, chi, rhi, key);
        System.out.println("ret3="+ret3);
    }

    public static void Test2()
    {
        System.out.println("Binary search in two dimension");
        int[][] array = {{203}};
        int key = 203;
        int rlo = 0;
        int rhi = array[0].length-1;
        int clo = 0;
        int chi = array.length-1;
        printArray(array, chi, rhi);

        boolean ret2 = BinSearch2D(array, clo, rlo, chi, rhi, key);
        System.out.println("ret2="+ret2);

        boolean ret3 = binSearchMN(array, clo, rlo, chi, rhi, key);
        System.out.println("ret3="+ret3);
    }

    //Binary search from top right corder, eliminate row/column algorithm 
    //Complexity O(m+n)
    public static boolean binSearchMN(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        int width = rowhi - rowlo + 1;
        int height = colhi - collo + 1;
        int col = collo;
        int row = rowhi;
        for(int i=0; i<width+height; i++)
        {
            if(key < array[col][row])
            {
                if(row > rowlo)
                    row--;
            }
            else if(key > array[col][row])
            {
                if(col < colhi)
                    col++;
            }
            else 
                return true;
        }
        return false;
    }
    
    //Binary search: eliminate one quandrant in each step
    //Complexity O(lg(m)+lg(n))
    public static boolean BinSearch2D(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        boolean ret = false;
        if(array != null)
        {
            int colm = (collo + colhi)/2;
            int rowm = (rowlo + rowhi)/2;
            if(collo <= colhi && rowlo <= rowhi)
            {
                if(key < array[colm][rowm])
                {
                    boolean b1 = BinSearch2D(array, collo, rowlo,
                                                  colm-1, rowm-1, key);
                    boolean b2 = BinSearch2D(array, collo, rowm,
                                                  colm-1,rowhi, key);
                    boolean b3 = BinSearch2D(array, colm, rowlo,
                                                  colhi, rowm-1, key);
                    ret = b1 || b2 || b3;
                }
                else if(key > array[colm][rowm])
                {
                    boolean b1 = BinSearch2D(array, colm+1, rowm+1,
                                                  colhi,  rowhi, key);
                    boolean b2 = BinSearch2D(array, collo, rowm+1,
                                                  colm,  rowhi, key);
                    boolean b3 = BinSearch2D(array, colm+1, rowlo,
                                                  colhi,  rowm, key);
                    ret = b1 || b2 || b3;
                }
                else
                    ret = true;
            }
        }
        return ret;
    } 
}
    //Binary search: eliminate one quandrant in each step
    //Complexity O(lg(m)+lg(n))
    public static boolean BinSearch2D(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        if(array != null)
        {
            int colm = (collo + colhi)/2;
            int rowm = (rowlo + rowhi)/2;
            if(collo <= colhi && rowlo <= rowhi)
            {
                if(key < array[colm][rowm])
                {
                    boolean b1 = false, b2 = false, b3 = false;
                    b1 = BinSearch2D(array, collo, rowlo,
                                                  colm-1, rowm-1, key);

                    b2 = BinSearch2D(array, collo, rowm,
                                                  colm-1,rowhi, key);
                    b3 = BinSearch2D(array, colm, rowlo,
                                                  colhi, rowm-1, key);
                    return b1 || b2 || b3;
                }
                else if(key > array[colm][rowm])
                {
                    boolean b1 = false, b2 = false, b3 = false;
                    b1 = BinSearch2D(array, colm+1, rowm+1,
                                                  colhi,  rowhi, key);
                    b2 = BinSearch2D(array, collo, rowm+1,
                                                  colm,  rowhi, key);
                    b3 = BinSearch2D(array, colm+1, rowlo,
                                                  colhi,  rowm, key);
                    return b1 || b2 || b3;
                }
                else
                    return true;
            }
        }
        return false;
    } 
import java.io.*;
import java.lang.String;
import java.util.*;
class BinarySearchIteration 
{
	public static void main(String args[])
	{
		int[] Arr = {1, 2, 3, 5};
		int left = 0;
		int right = Arr.length - 1;
		int key = 5;
		int ret = BinSearch(Arr, left, right, key);
		System.out.println(ret);
	}
	public static int BinSearch(int[] Arr, int left, int right, int key)
	{
        int ret = -1;
        while(left <= right && ret == -1)
        {
            //int mid = (left + right)/2;
            int mid = left + (right - left)/2;
            if(Arr[mid] == key)
                ret = mid; 
            else if(Arr[mid] < key)
                left = mid + 1;
            else 
                right = mid -1; 
        }
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import Lib.*;

class BinarySearchTree {
	public static Node prev = null;
	public static void main(String args[]) {
		BST b1 = new BST();

		b1.insert(15);
		b1.insert(12);
		
		b1.insert(14);
		b1.insert(17);
		b1.insert(19);
		b1.insert(130);
		b1.insert(16);
		b1.insert(10);
		
		int[] Arr = new int[100];
		int len=0;
		Node r = b1.getRoot();

		b1.LevelOrder();

		System.out.println(contain(r, 15));

        test1();
        test2();
        test3();
        test4();
        test5();
	}

    public static void kdistance(Node r, int k){
        if(r != null){
            if(k == 0)
                System.out.println(r.data);
            else{
                kdistance(r.left, k-1);
                kdistance(r.right, k-1);
            }
        }
    }

	public static boolean isBST(Node r) {
		if(r == null)
			return true;
		else {
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	//init len = 0
	public static void printAllPath(Node r, int[] Arr, int len) {
		if( r != null && Arr != null) {
			Arr[len] = r.data;
			if( r.left == null && r.right == null) {
				for(int i=0; i<len+1; i++)
					System.out.print(Arr[i]+" ");
				System.out.println();
			}
			else {
				printAllPath(r.left, Arr, len+1);
				printAllPath(r.right, Arr, len+1);
			}
		}
	}
	public static int MaxDepth(Node r) {
		if( r != null) {
			int nl = MaxDepth(r.left);
			int nr = MaxDepth(r.right);

			return (nl>nr?nl:nr)+1;
		}
		return 0;
	}
	public static boolean equalBinaryTree(Node r1, Node r2)
	{
		if(r1==null && r2==null)
			return true;
		else if(r1 != null && r2 != null) {
			if(r1.data != r2.data)
					return false;
			if(!equalBinaryTree(r1.left, r2.left)) 
					return false;
			if(!equalBinaryTree(r1.right, r2.right))
					return false;
		}
		else 
			return false;
		return true;
	}
	public static void Inorder(Node root) {
		if(root != null) {
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
	public static boolean contain(Node r, int value) {
		if( r != null) {
			if(contain(r.left, value))
				return true;
			if(r.data == value)
				return true;
			if(contain(r.right, value))
				return true;
		}
		return false;
	}
    // 10 5 1_ _ 6_ _ 14 11 _
    // 10 _ _
    // 10 5_ _ 12_ _
    // int[] k = new int[1];
	public static Node generateBinaryTree(Node r, String[] list, int[] k) {
        if(k[0] < list.length && list[k[0]] != "_"){
            if(r == null)
                r = new Node(Integer.parseInt(list[k[0]]));
            k[0]++;
            r.left = generateBinaryTree(r.left, list, k);
            k[0]++;
            r.right = generateBinaryTree(r.right, list, k);
            return r;
        }
        return null;
    }

    public static void test5() {
        System.out.println("test5"); 
        BST b1 = new BST();
        int k = 2;
		b1.insert(15);
		b1.insert(5);
		b1.insert(20);
		b1.insert(30);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 
    public static void test4() {
        System.out.println("test4"); 
        BST b1 = new BST();
        int k = 1;
		b1.insert(15);
		b1.insert(5);
		b1.insert(20);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 
    public static void test3() {
        System.out.println("test3"); 
        BST b1 = new BST();
        int k = 0;
		b1.insert(15);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 

    public static void test2() {
        System.out.println("test2"); 
        String[] list = {
            "10",
            "8",
            "_",
            "_",
            "12",
            "_",
            "19"
        };
        Node r = null;
        int[] k= new int[1];
        k[0] = 0;
        Node root = generateBinaryTree(r, list, k);
        Inorder(root);
    } 
    public static void test1() {
        System.out.println("test1"); 
        String[] list = {
            "10",
            "_",
            "_"
        };
        Node r = null;
        int[] k= new int[1];
        k[0] = 0;
        Node root = generateBinaryTree(r, list, k);
        Inorder(root);
    } 
}
	public static boolean BinSearch(int[] arr, int left, int right, int key)
	{
		boolean ret = false;
		if(arr != null && left <= right)
		{
			int middle = (left + right)/2;
			if(key < arr[middle])
			{
                ret = BinSearch(arr, left, middle - 1, key);
			}
			else if(key > arr[middle])
			{
                ret = BinSearch(arr, middle + 1, right, key);
			}
			else 
				ret = true;
		}
		return ret;
	}
import java.util.*;
class Node{
        int data;
        Node left;
        Node right;
    public Node(int data){
        this.data = data;
        left = null;
        right = null;
    }
}

class BinaryTree{
    Node root;
    public BinaryTree(){
        root = null;
    }
    public void insert(int data){
        if(root == null){
            root = new Node(data);
        }else{
            Node current = root;
            boolean end = false;
            while(!end){
                if(data < current.data){
                   if(current.left == null){
                       current.left = new Node(data);
                       end = true;
                   }else{
                       current = current.left; 
                   }
                }
                else{
                    if(current.right== null){
                       current.right= new Node(data);
                        end = true;
                    }
                    else{
                       current = current.right;
                    }
                }
            }
        } 
    }
    public void preorder(Node root)
    {
        if(root != null){
            System.out.println("preorder["+root.data+"]");
            preorder(root.left);
            preorder(root.right);
        }
    }

}

public class BinaryToArray 
{
    public static void main(String[] args)
    {
        BinaryTree bin = new BinaryTree();
        bin.insert(10);
        bin.insert(15);
        bin.insert(12);
        bin.insert(20);
        bin.insert(30);
            
        bin.preorder(bin.root);

        int[] Array = new int[20];
        System.out.println("Hello World!");
    }
    public void int[] BinaryToArray(Node root){
        
        Queue<Node> queue1 = new LinkedList<Node>();
        Queue<Node> queue2 = new LinkedList<Node>();
        if(root != null)
            queue1.offer(root);
        while(queue1.peek()){
            Node no = queue1.remove();
            if(no.left != null){
                queue2.offer(no.left);
            }
        }

    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	boolean visited;
	public Node(int n)
	{ data = n; left = null; right = null; visited=false;}
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class BoundryBinaryTree 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(50);
        
		b1.Insert(39);
		b1.Insert(18);
		b1.Insert(35);
		b1.Insert(36);
		b1.Insert(41);
		b1.Insert(43);
        
        b1.Insert(51);
		b1.Insert(91);
		b1.Insert(76);
		b1.Insert(60);
		b1.Insert(99);
		b1.Insert(59);
		b1.Insert(58);

		
        
        System.out.println();
        PrintBoundry(b1.getRoot());
        System.out.println();
        Node right = null;
        //InorderLeftLeafNode(b1.getRoot(), right); 
        System.out.println();
        PrintBoundryWithInorder(b1.getRoot());
	}
	
    //Initialize right = null
    static boolean leaf = false;
    public static void InorderLeftLeafNode(Node curr)
    {
        if(curr != null)
        {
            if(!leaf)
                System.out.print("{" + curr.data + "}");
            if(curr.left == null && curr.right == null)
            {
                if(leaf)
                    System.out.print("[" + curr.data + "]");
                leaf = true;
            }
            InorderLeftLeafNode(curr.left);
            InorderLeftLeafNode(curr.right);
        }
    }
    public static void PrintBoundryWithInorder(Node curr)
    {
        InorderLeftLeafNode(curr);
        if(curr != null)
        {
            Node right = curr.right;
            Stack<Node> stack = new Stack<Node>();
            while(right != null)
            {
                if(right.left != null || right.right != null)
                {
                    stack.push(right);
                    //System.out.print("[" + right.data + "]");
                }
                right = right.right;
            }
            while(!stack.empty())
            {
                System.out.print("[" + stack.pop().data + "]");
            }
        }
            

    }
    public static void PrintBoundry(Node curr)
    {
        Stack<Node> st = new Stack<Node>();
        Set<Integer> hashset = new HashSet<Integer>();
        boolean first = false;
        Node root = curr;
        while(curr != null || !st.empty())
        {
            if(curr != null)
            {
                if(!first)
                {
                    System.out.println("[" + curr.data + "]");
                    hashset.add(curr.data);
                }
                st.push(curr);
                curr = curr.left;
            }
            else
            {
                if(!first)
                    first = true;
                Node node = st.pop();
                if(node.left == null && node.right == null)
                {
                    if(!hashset.contains(node.data))
                    {
                        System.out.println("[" + node.data + "]");
                        hashset.add(node.data);
                    }
                }
                curr = node.right;
            }
        }
        //Print out the nodes in the right side of the tree
        if(root != null)
        {
            Stack<Node> stack = new Stack<Node>();
            Node right = root.right;
            while(right != null)
            {
                if(!hashset.contains(right.data))
                {
                    hashset.add(right.data);
                    stack.push(right);
                }
                right = right.right;
            }
            while(!stack.empty())
            {
                System.out.println("[" + stack.pop().data + "]");
            }
        }
    }

    public static void PostOrder(Node r)
    {
        if( r != null)
        {
            PostOrder(r.left);
            PostOrder(r.right);
            System.out.println("normal[" + r.data + "]");
        }
    }

    public static void PostorderSimple(Node root)
    {
        if(root != null)
        {
            Stack<List<Node>> st = new Stack<List<Node>>();
            
            while(root != null || !st.empty())
            {
                if(root != null)
                {
                    List<Node> list = new LinkedList<Node>();
                    list.add(0, root);
                    if(root.left != null)
                        list.add(1, root.left);
                    if(root.right != null)
                        list.add(2, root.right);

                    root = root.left;
                }
            }
        }
    }
        
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
public class BracketsMatch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
    }
    public static int[] fun()
    {
        int[] array = {1, 2};
        return array;
    }
    public static void test1()
    {
        System.out.println("test1"); 
        String str = "()";
        int index = 0;
        System.out.println(match(str, index)); 
    } 
    public static void test2()
    {
        System.out.println("test2"); 
        String str = "(}";
        int index = 0;
        System.out.println(match(str, index)); 
    } 
    public static boolean match(String str, int index){
        if(str.charAt(index) == '('){
            match(str, index+1);
        }else{
            if(index-1 < 0)
                return false;
            if(str.charAt(str.length-1-index) == '(' &&  str.charAt(index) != ')')
                return false;
        }
        return true;
    }
}
import java.util.concurrent.*;
import java.util.*;
import classfile.*;

/*
   1. Implement Callable interface
   2. Override call() whatever is inside
   3. Add callables object to a list
   4. Invoke all the callable objects with invokeAll(List<Future<>>) 
*/
public class CallableDemo{
    public CallableDemo(){
        System.out.println("Create callable Demo");
        ExecutorService service = Executors.newFixedThreadPool(10);

        List<MyCallable> futureList = new ArrayList<MyCallable>();
        int nThread = 10;
        Print.p("Create 10 threads and add 10 callables to a future list");
        for ( int i=0; i<nThread; i++){
            MyCallable myCallable = new MyCallable((long)i);
            futureList.add(myCallable);
        }

        System.out.println("Start");
        try{
            List<Future<Long>> futures = service.invokeAll(futureList);  
            for(Future<Long> future : futures){
                try{
                    System.out.println("future.isDone = " + future.isDone());
                    //System.out.println("future: call ="+future.get());
                }
                catch(Exception err1){
                    err1.printStackTrace();
                }
            }
        }catch(Exception err){
            err.printStackTrace();
        }
        service.shutdown();
    }

    class CallableComputation implements Callable<List<String>>{
        Long value = 0L;
        String fname;
        public CallableComputation(String fname){
            this.fname = fname;
        }
        public List<String> call(){
            // 1. Read file
            // 2. Process the file 
            // 3. Output strings to list
            // return the list of string
            return new ArrayList<String>();
        }
    }

    class MyCallable implements Callable<Long>{
        Long id = 0L;
        public MyCallable(Long val){
            this.id = val;
        }
        /*
        It is similar to Run() in Runnable interface => start() method
        Thread t = new Thread(new Runnable())
        t.start()
        Override call()
        */
        public Long call(){
            int a=4, b = 0;
            try{
                Print.fl("call()", id);
                Thread.sleep(1000);
            }catch(InterruptedException e){
            }
            return id;
        }
    }
    public static void main(String args[]){
        CallableDemo demo = new CallableDemo();
    }
}
import java.util.*;
import java.math.*;
import classfile.*;

public class CarmichaelNumber{
    public static void main(String[] args) {
        test1();
    }
    //[ file=carmichaelnumber.html title=""
    public static boolean CarmichaelNumber(int n){
        for(int b=2; b<n; b++){
            if(gcd(b, n) == 1){
                BigDecimal bg = new BigDecimal(b);
                BigDecimal big = bg.pow(n-1);
                BigDecimal bgremainder = big.remainder(new BigDecimal(n));
                if(Integer.parseInt(bgremainder.toString()) != 1)
                    return false;
            }
        }
        return true;
    }
    //]
    static void test0(){
        Aron.beg();
        System.out.println("3=[" + gcd(0, 3) + "]");
        System.out.println("1=[" + gcd(2, 3) + "]");
        System.out.println("1=[" + gcd(3, 2) + "]");
        System.out.println("3=[" + gcd(3, 3) + "]");
        System.out.println("2=[" + gcd(2, 4) + "]");
        System.out.println("2=[" + gcd(6, 4) + "]");
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int carnum = 561;
        System.out.println("561 is Carmichael Number? [" + CarmichaelNumber(carnum) + "]");
        Aron.end();
    }
    public static int gcd(int a, int b){
        if(a == 0 && b > 0)
            return b;
        else if( a > 0 && b == 0){
            return a;
        }else{
            if(a >= b){
                return gcd(a-b, b);
            }else{
                return gcd(a, b-a);
            }
        }
    }
}
public class CofactorMatrix 
{
				public static void main(String[] args)
				{
								System.out.println("Hello World!");
								int[][] A = {
															{1, 2},
															{3, 4}
														};

								int[][] B = cofactor(A, 1, 1);
								for(int r = 0;  B != null && r < B.length; r++)
								{
									for(int c = 0; c < B.length; c++)
									{
										System.out.print("["+B[r][c]+"]");
									}
									System.out.println();
								}
				}
				public static int[][] cofactor(int[][] A, int row, int col)
				{
					int len = 0;
					int[][] B = null; 
					if(A != null && (len = A.length) > 0 && row < len && col < len)
					{
						B = new int[len-1][len-1];
						int r1 = 0;
						for(int r = 0; r < len; r++)
						{
							if(r != row)
							{
								int c1 = 0;
								for(int c = 0; c < len; c++)
								{
									if(c != col)
									{
										B[r1][c1] = A[r][c];
										c1++;
									}
								}
								r1++;
							}
						}
					}
					return B;
				}
}
import java.util.*;

import classfile.*;

public class CoinChange {
    public static void main(String[] args) {
        /*
        test1();
        test2();
        test3();
        test4();
        test5();
        test8();
        test8_new();
        test10();
        test11();
        test12();
        */
        //test13();

        /*
        test20();
        test7();
        test9();
        test20();
        test21();
        test22();
        */

        //test2();

        test14();
        test15();
        //test23();
    }


    //[file=dynamic.html   title=""
    public static int[][] miniCoinDynamic(int[] coin, int sum) {
        int len = coin.length;
        int[][] array = init(len, sum);

        for(int i=0; i<len; i++) {
            for(int s = 0; s <=sum; s++) {
                if( s - coin[i] >= 0) {
                    int min = Integer.MAX_VALUE;
                    for(int k=0; k <=i; k++)
                        min = Math.min(min, array[k][s-coin[i]]);
                    array[i][s] = min == Integer.MAX_VALUE ? min: min + 1;
                }
            }
        }

        // find the mini value on the most right column
        int min = Integer.MAX_VALUE;
        for(int k=0; k <len; k++)
            min = Math.min(min, array[k][sum]);
        array[len-1][sum] = min;

        return array;
    }

    public static int[][] init(int height, int width) {
        int[][] array = new int[height][width+1];
        for(int i=0; i<height; i++) {
            for(int j=0; j<width+1; j++) {
                if(j == 0)
                    array[i][j] = 0;
                else
                    array[i][j] = Integer.MAX_VALUE;
            }
        }
        return array;
    }
    //]

    //Given coins[k] = {2, 3, 4} and change s = 9
    //Count the number of way for coin change
    //coins[k] is in the each change
    //coins[k] is not in the each change
    //count(coins, k, s) = count(coins, k-1, s) + count(coins, k, s-coins[k])
    public static int count_debug(int[] coin, int s, int k) {
        if( s < 0) {
            System.out.print("<"+s+","+k+">\n");
            return 0;
        } else if( s == 0 ) {
            System.out.print("<"+s+","+k+">\n");
            return 1;
        } else if( s > 0 && k > 0) {
            System.out.print("<"+s+","+k+">->");
            int left = count(coin, s, k-1);

            System.out.print("<"+s+","+k+">->");
            int right= count(coin, s-coin[k-1], k);
            return left + right;
        } else {
            System.out.println();
            return 0;
        }
    }

    public static int miniCointWithPerm(int[] coin, int s) {
        if(s == 0)
            return 0;
        else {
            int min = 100;
            for(int i=0; i<coin.length; i++) {
                if(s - coin[i] >= 0)
                    min = Math.min(min, miniCointWithPerm(coin, s-coin[i]) + 1);
            }
            return min;
        }
    }

    // Given coins[k] = {2, 3, 4} and change s = 9
    // Count the number of way for coin change
    // coins[k] is in the each change
    // coins[k] is not in the each change
    // count(coins, k, s) = count(coins, k-1, s) + count(coins, k, s-coins[k])
    public static int count(int[] coin, int s, int k) {
        if( s < 0)
            return 0;
        else if( s == 0 )
            return 1;
        else if( s > 0 && k > 0) {
            int right= count(coin, s-coin[k-1], k);
            int left = count(coin, s, k-1);
            return left + right;
        } else
            return 0;
    }

    //Coin change algorithm using dynamic programming
    //Use table from bottom up to model the recursion tree
    public static int countdy(int[] coin, int s, int k) {
        int[][] table = new int[s+1][k];
        for(int i=0; i<k; i++)
            table[0][i] = 1;

        System.out.println();

        Aron.printTable(table);

        for(int ss=1; ss<s+1; ss++) {
            for(int kk=0; kk<k; kk++) {
                int left  = kk-1 >= 0? table[ss][kk-1]:0;

                if(kk-1 >= 0)
                    System.out.print("["+ss+"]["+(kk-1)+"]=["+left+"]\n");
                else
                    System.out.print("["+ss+"]["+(kk-1)+"]=["+0+"]\n");

                int right = ss-coin[kk] >= 0?  table[ss-coin[kk]][kk]:0;
                int col = ss-coin[kk];

                if(ss-coin[kk] >= 0)
                    System.out.print("["+col+"]["+kk+"]=["+right+"]\n");
                else
                    System.out.print("["+col+"]["+kk+"]=["+0+"]\n");

                System.out.println();

                table[ss][kk] = left + right;
            }
        }

        printTable(table);

        return table[s][k-1];
    }

    //Print out all the coins which adds up to s
    public static void permuCount(int[] coin, int[] arr, int d, int s, int sum) {
        for(int i=0; i<coin.length; i++) {
            if(sum + coin[i] == s) {
                sum += coin[i];
                arr[d] = coin[i];
                for(int j=0; j<=d; j++) {
                    System.out.print("["+arr[j]+"]");
                }
                System.out.println();
            } else if(sum + coin[i] < s) {
                arr[d] = coin[i];
                sum += coin[i];
                permuCount(coin, arr, d+1, s, sum);
                sum -= coin[i];
            }
        }
    }

    public static int minCount_debug(int[] coin, int s, int k) {
        if(s < 0)
            return 100;
        if(s == 0) {
            System.out.print("["+s+"]\n");
            return 0;
        } else if( s > 0 && k <= 0)
            return 100;
        else {
            int min=100;
            for(int i=0; i<k; i++) {
                if(s - coin[i] > 0)
                    System.out.print("["+s+"]->");
                min = Math.min(min, minCount_debug(coin, s-coin[i], k)+1);
            }
            return min;
        }
    }

    //[file=CoinChangeRecursive.html   title=""
    //CoinChange.java
    //Given coin{2, 3, 4} and s = 6
    //Find the minimum number of coins sums up to s
    public static int minCount(int[] coin, int s, int k) {
        int min = Integer.MAX_VALUE;
        if(s == 0)
            min = 0;
        else if(s > 0) {
            // min(s) = min(s-coin[k]) + 1
            for(int i=0; i<k; i++) {
                int childMin = minCount(coin, s-coin[i], k);
                if(childMin != Integer.MAX_VALUE)
                    min = Math.min(min, childMin + 1);
            }
        }
        return min;
    }
    //]


    public static int minCountAllPath(int[] coin, int s, int k, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(s == 0){
            Aron.printList(list);
            min = 0;
        }
        else if(s > 0) {
            for(int i=0; i<k; i++) {
                list.add(coin[i]);
                int childMin = minCountAllPath(coin, s-coin[i], k, list);
                if(childMin != Integer.MAX_VALUE)
                    min = Math.min(min, childMin + 1);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }

        }
        return min;
    }
    //[file=CoinChangeWithHashMap.html   title=""
    // CoinChange.java
    // Given coin{2, 3, 4} and s = 6
    // Find the minimum number of coins sums up to s
    public static int minCountWithDynamic(int[] coin, int s, int k, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(s == 0){
            min = 0;
        }
        else if(s > 0) {
            for(int i=0; i<k; i++) {
                Integer value = map.get(s-coin[i]);
                if(value == null) {
                    value = minCountWithDynamic(coin, s-coin[i], k, map, list);
                    if(value < Integer.MAX_VALUE)
                        value += 1; 
                } 

                min = Math.min(min, value);

                if(s-coin[i] < 0)
                    map.put(s-coin[i], Integer.MAX_VALUE);
                else
                    map.put(s-coin[i], min);

            }
        }
        return min;
    }
    //]

    public static int minCount_Graph(int[] coin, int s, int k, int[] arr) {
        int min = Integer.MAX_VALUE;
        if(s == 0) {
            min = 0;
        } else if(s > 0) {
            // min(s) = min(s-coin[k]) + 1
            int parent = arr[0];
            for(int i=0; i<k; i++) {
                String parentLabel = parent + "[label="+ s +"];";
                System.out.println(parentLabel);

                arr[0] += 1 + i;
                int child = arr[0] ;


                String childLabel = "";
                if( s - coin[i] == 0)
                    childLabel = child + "[label="+ (s-coin[i]) +", style=filled, fillcolor=green]";
                else if(s - coin[i] < 0)
                    childLabel = child + "[label="+ (s-coin[i]) +", style=filled, fillcolor=red]";
                else
                    childLabel = child + "[label="+ (s-coin[i]) +"];";

                System.out.println(childLabel);

                System.out.println(parent + "->" + child + "[label="+ coin[i] +"];");

                int childMin = minCount_Graph(coin, s-coin[i], k, arr);
                if(childMin != Integer.MAX_VALUE) {
                    min = Math.min(min, childMin + 1);
                }
            }
        }
        return min;
    }


    public static void printTable(int[][] arr) {
        if(arr != null) {
            for(int c=0; c<arr.length; c++) {
                for(int r=0; r<arr[0].length; r++) {
                    System.out.print("["+arr[c][r]+"]");
                }
                System.out.println();
            }
        }
        System.out.println();
    }
    public static void test1() {
        System.out.println("test1()");
        int[] recoin = {1};
        int[] dycoin = {1};
        int k = recoin.length;
        int s = 0;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test2() {
        System.out.println("test1()");
        int[] recoin = {1, 2};
        int[] dycoin = {1};
        int k = recoin.length;
        int s = 3;
        int c = count(recoin, s, k);
        System.out.println("recursion count=["+c+"]");
    }

    public static void test3() {
        System.out.println("test1()");
        int[] recoin = {1, 2};
        int[] dycoin = {1, 2};
        int k = recoin.length;
        int s = 3;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test4() {
        System.out.println("test4()");
        int[] recoin = {1, 2, 3};
        int[] dycoin = {1, 2, 3};
        int k = recoin.length;
        int s = 4;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test5() {
        System.out.println("test5()");
        int[] recoin = {2, 3, 4};
        int[] dycoin = {2, 3, 4};
        int k = recoin.length;
        int s = 10;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println();
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");
    }




    public static void test8() {
        System.out.println("test8()");
        int[] recoin = {2, 3, 4, 5, 6};
        int[] dycoin= {2, 3, 4, 5, 6};
        int k = recoin.length;
        int s = 15;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println();
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");
    }

    public static void test8_new() {
        System.out.println("test8_new()");
        int[] recoin = {2, 3, 4, 5, 6};
        int k = recoin.length;
        int s = 15;
        String count = " ";
        int min = miniCointWithPerm(recoin, s);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test9() {
        System.out.println("test9()");
        final int Num = 10;
        int[] coin = new int[Num];

        for(int i=0; i<Num; i++)
            coin[i] = 3+i;

        int s = 150;
        int[][] table = miniCoinDynamic(coin, s);
        int row = table.length;
        int col = table[0].length;
        System.out.println("min=" + table[row-1][col-1]);
    }

    public static void test10() {
        System.out.println("test10()");
        int[] coin = {1, 2};
        int s = 3;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }
    public static void test11() {
        System.out.println("test11()");
        int[] coin = {1, 2, 4};
        int s = 5;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }
    public static void test12() {
        System.out.println("test12()");
        int[] coin = {1, 2, 3, 16};
        int s = 17;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }

    public static void test6() {
        System.out.println("test6()");
        int[] recoin = {2, 3, 4, 5, 6};
        int[] arr = new int[recoin.length+10];
        int d = 0;
        int s = 15;
        int sum = 0;
        permuCount(recoin, arr, d, s, sum);
        System.out.println();
    }

    public static void test13() {
        System.out.println("test13()");
        final int Num = 4;
        int[] coin = new int[Num];
        for(int i=1; i<Num; i++)
            coin[i] = 2*i;

        int s = 45;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        // Aron.printTable(table);
    }

    public static void test14() {
        Aron.beg();
        final int Num = 14;
        int[] coin = new int[Num];

        for(int i=0; i<Num; i++)
            coin[i] = 2+i;

        int s = 45;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>(); 
        int min = minCountWithDynamic(coin, s, Num, map, list);
        System.out.println("min[" + min + "]"); 

        Aron.end();
    }
    public static void test15() {
        Aron.beg();
        final int Num = 4;
        int[] coin = new int[Num];
        for(int i=0; i<Num; i++)
            coin[i] = 2+i;

        int s = 20;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>(); 
        int min = minCountAllPath(coin, s, Num, list);
        System.out.println("min[" + min + "]"); 

        Aron.end();
    }


    public static void test7() {
        System.out.println("test7()");
        int[] coin = {2, 3, 15, 18};
        int k = coin.length;
        int s = 19;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }


    public static void test20() {
        System.out.println("test20()");
        int[] coin = {2, 3, 15, 18};
        int k = coin.length;
        int s = 20;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test21() {
        System.out.println("test21()");
        int[] coin = {2};
        int k = coin.length;
        int s = 2;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test22() {
        System.out.println("test22()");
        int[] coin = {2, 3, 4, 5};
        int k = coin.length;
        int s = 10;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }
    public static void test23() {
        int[] coin = {1, 2};
        int k = coin.length;
        int s = 3;
        int[] arr = new int[1];
        arr[0] = 100;
        System.out.println("digraph G {\n");
        int min = minCount_Graph(coin, s, k, arr);
        System.out.println("}\n");

        System.out.println();
    }
}
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import classfile.*;

class CoinChange{
    Integer curr_total;
    Integer curr_bill;
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    List<Integer> list = new ArrayList<Integer>();;
    
    public CoinChange(){
        curr_total = 0;
        curr_bill = 0;
        list.add(25);
        list.add(10);
        list.add(5);
        list.add(1);

        map.put(25, 10);
        map.put(10, 10);
        map.put(5, 10);
        map.put(1, 10);
    }
    public void insertBill(Integer bill){
        if(bill > 25){
            curr_bill = bill;
        }
    }

    public Map<Integer, Integer> withDraw(){
        Map<Integer, Integer> retMap = new HashMap<Integer, Integer>();
                for(Integer coin : list){
                    if(curr_bill > 0){
                    int quotient = curr_bill / coin;
                    if(quotient > 0){
                        Integer numCoins = map.get(coin);
                        if(quotient <= numCoins){
                            curr_bill = curr_bill - quotient*coin;
                            retMap.put(coin, quotient);
                            map.put(coin, numCoins - quotient);
                        }
                    }
            }
        }
        if(curr_bill == 0)
            return retMap;
        else
            return null;
    }
}
public class CoinMachine{
    public static void main(String[] args){
        test0();
        test1();
        test2();
    }
    
    static void test0(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(54);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }

    static void test1(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(1);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(103);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }
}
// print all combination 0 to n-1
public class Combination 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] path = new int[3];
        int row = 0;
        combination(path, row);
        test1();
        test2();
    }
    public static void combination(int[] path, int row)
    {
        if(path != null)
        {
            if(row == path.length)
            {
                for(int r = 0; r < path.length; r++)
                {
                    System.out.print("["+path[r]+"]");
                }
                System.out.println("");
            }
            for(int col=0; col<path.length && row < path.length; col++)
            {
                path[row] = col; 
                combination(path, row+1);
            }
        }
    }
    public static void test1()
    {
        System.out.println("=================================="); 
        int[] path = {1}; 
        int row = 0;
        int len = path.length;
        combination(path, row);
    }
    public static void test2()
    {
        System.out.println("=================================="); 
        int[] path = {1, 2}; 
        int row = 0;
        int len = path.length;
        combination(path, row);
    } 
}
import java.util.*;

// Comparable
class Contact implements Comparable<Contact> {
    String name;
    String addr;
    int    age;
    public Contact(String name, String addr, int age) {
        this.name = name;
        this.addr = addr;
        this.age = age;
    }

    //Minimum heap
    public int compareTo(Contact c) {
        return this.age - c.age;
        //Maximum heap
        //return -(this.age - c.age);
    }

    public String toString() {
        return "["+name+"]["+addr+"]["+age+"]";
    }
}

class Person {
    String name;
    int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }

}


// Comparator
class LexicographicComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.getName().compareToIgnoreCase(p2.getName());
    }
}

class AgeComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge() == 0? 0 : p1.getAge() < p2.getAge() ? -1 : 1;
    }
}



public class CompareDemo {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        List<Person> listPerson = new ArrayList<Person>(
            Arrays.asList(
                new Person("David", 20),
                new Person("Ann", 19),
                new Person("Michael", 18),
                new Person("Sunny", 6)
            )
        );

        Collections.sort(listPerson, new LexicographicComparator());
        Collections.sort(listPerson, new AgeComparator());
        for(Person p: listPerson) {
            System.out.println(p.getName() + " " + p.getAge());
        }
        List<Contact> listContact = new ArrayList<Contact>(
            Arrays.asList(
                new Contact("David", "Mountain View", 20),
                new Contact("Ann", "Palo Alto", 19),
                new Contact("Michael", "RedWood City", 26)
            )
        );

        System.out.println();
        Collections.sort(listContact);
        for(Contact c: listContact) {
            System.out.println(c.name + " " + c.addr + " " + c.age);
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class Compress {
    public static void main(String args[]) {
        test0();        
        test00();        
        test1();        
        test2();        
        test3();        
        test4();        
        test5();        
        test6();        
        test7();        
        test8();        
        test9();        
        test10();        
        test11();        
    }
    //[ file=compressstr.html title=""
    public static String CompressStr(String str) {
        String ret="";
        if(str != null && str.length() > 0) {
            if(str.length() == 0 || str.length() == 1)
                ret = str;
            else {
                int c=1;
                int i=0;
                for(i=0; i<str.length()-1; i++) {
                    if(str.charAt(i) == str.charAt(i+1))
                        c++;
                    else{
                        if(c > 1) {
                            ret = ret + str.charAt(i) + c + "";
                            c=1;
                        }else{
                            ret = ret + str.charAt(i) + "";
                        }
                    } 
                }

                if(c > 1)
                    ret = ret + c	+ str.charAt(i) + "";
                else
                    ret = ret + str.charAt(i) + "";
            }
        }
        return ret;
    }

    public static String compress(String str) {
        int c = 1;
        String retStr = "";
        int i=0;
        for(; i<str.length()-1; i++) {
            if(str.charAt(i) == str.charAt(i+1)) {
                c++;
            } else {
                if(c == 1)
                    retStr += str.charAt(i) + "";
                else if(c > 1)
                    retStr += str.charAt(i) + "" + c;

                c = 1;
            }
        }

        if(c == 1)
            retStr += str.charAt(i) + "";
        else if(c > 1)
            retStr += str.charAt(i) + "" + c;

        return retStr;
    }

    public static String compress2(String str) {
        int c = 1;
        String retStr = "";
        str += "0";
        for(int i=0; i<str.length()-1; i++) {
            if(str.charAt(i) == str.charAt(i+1)) {
                c++;
            } else {
                if(c == 1)
                    retStr += str.charAt(i) + "";
                else if(c > 1)
                    retStr += str.charAt(i) + "" + c;

                c = 1;
            }
        }

        return retStr;
    }
    //]
    
    static void test0(){
        Aron.beg();
        String str="aabba";
        String ret = CompressStr(str);
        System.out.println("aabba[" + ret + "]"); 
        Aron.end();
    }

    static void test00(){
        Aron.beg();
        String str="a";
        String ret = CompressStr(str);
        System.out.println("a[" + ret + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String str="aabba";
        String ret = compress(str);
        System.out.println("aabba[" + ret + "]"); 
        Aron.end();
    }

    static void test2(){
        Aron.beg();
        String str="a";
        String ret = compress(str);
        System.out.println("a[" + ret + "]"); 
        Aron.end();
    }

    static void test3(){
        Aron.beg();
        String str="aa";
        String ret = compress(str);
        System.out.println("aa[" + ret + "]"); 
        Aron.end();
    }

    static void test4(){
        Aron.beg();
        String str="ab";
        String ret = compress(str);
        System.out.println("ab[" + ret + "]"); 
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        String str="aabbb";
        String ret = compress(str);
        System.out.println("aabbb[" + ret + "]"); 
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        String str="aabbba";
        String ret = compress(str);
        System.out.println("aabbba[" + ret + "]"); 
        Aron.end();
    }

    static void test7(){
        Aron.beg();
        String str="a";
        String ret = compress2(str);
        System.out.println("compress2 a[" + ret + "]"); 
        Aron.end();
    }
    static void test8(){
        Aron.beg();
        String str="aa";
        String ret = compress2(str);
        System.out.println("compress2 aa[" + ret + "]"); 
        Aron.end();
    }
    static void test9(){
        Aron.beg();
        String str="abbb";
        String ret = compress2(str);
        System.out.println("compress2 abbb[" + ret + "]"); 
        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str="aabbbc";
        String ret = compress2(str);
        System.out.println("compress2 aabbbc[" + ret + "]"); 
        Aron.end();
    }

    static void test11(){
        Aron.beg();
        String str="";
        String ret = compress2(str);
        System.out.println("compress2 empty_str[" + ret + "]"); 
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Compress2
{
	public static void main(String args[])
	{
		String str="aaaaa";
		String ret = Compress2(str);
		System.out.println("str=" + ret);
	}
	public static String Compress2(String str) 
	{
		String ret="";
		if(str != null)
		{
			int len=str.length();
			if(len > 0)
			{ int c=1; int i=0;
				for(i=0; i<len-1; i++)
				{ if(str.charAt(i) == str.charAt(i+1))
						c++;
					else 
					{
						if(c>1)
							ret = ret + c + str.charAt(i);
						else 
							ret = ret + str.charAt(i);
						c=1;
					}
				}
				if(c>1)
					ret = ret + c + str.charAt(i);
				else 
					ret = ret + str.charAt(i);
			}
		}
		return ret;
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class ConnectedIsland {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        //test0_maxWords();
        test1_maxWords();
        test2_maxWords();
        test3_maxWords();
        test4_maxWords();
        test5_maxWords();

        test00_maxWords();
        test01_maxWords();
        test02_maxWords();
    }

    //[file=connectedisland.html title=""
    // 2:41 - 3:12
    //--------------------------------------------------------------------------------
    // [0, 1, 1, 0]
    // [0, 1, 0, 0]
    // [1, 0, 0, 1]
    // [1, 0, 1, 0]
    //
    //--------------------------------------------------------------------------------
    // w = 0, h = 0, width = 4, height = 4
    // arr[0][0] = 0
    // arr[0][1] = 1
    // arr[0][2] = 1
    // arr[0][3] ret
    // arr[0][1] = 2 ret
    // arr[-1][1] = ret
    // w = 0, h = 0
    public static int countConnection(int[][] arr, int w, int width, int h, int height) {
        if(arr != null) {
            if(arr[h][w] == 1) {
                arr[h][w] = 2;
                int right = 0, left = 0, up = 0, down = 0;
                if(w + 1 < width)
                    right =countConnection(arr, w+1, width, h, height);
                if(w - 1 >= 0)
                    left = countConnection(arr, w-1, width, h, height);
                if(h - 1 >= 0)
                    up =   countConnection(arr, w, width, h-1, height);
                if(h + 1 < height)
                    down = countConnection(arr, w, width, h+1, height);

                return right + left + up + down + 1;
            }
        }
        return 0;
    }
    public static int maxConnection(int[][] arr) {
        int max = 0;
        if(arr != null) {
            int height = arr.length;
            int width = arr[0].length;
            for(int h=0; h<height; h++) {
                for(int w=0; w<width; w++) {
                    int m = countConnection(arr, w, width, h, height);
                    if(m > max)
                        max = m;
                }
            }
        }
        return max;
    }
    //]
    public static void test0() {
        Aron.beg();

        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {1, 0, 0, 0},
            {1, 1, 0, 0},
            {1, 1, 0, 1},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        int[][] arr2d = {
            {0}
        };
        int max = maxConnection(arr2d);
        Test.t(max, 0);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        int[][] arr2d = {
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 0);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();

        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 4);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();

        int[][] arr2d = {
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {1, 1, 1, 1},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 10);

        Aron.end();
    }

    public static boolean isWord(String s) {
        String[] arr = {
            "a",
            "b",
            "e",
            "ill",
            "ball",
            "app",
            "ban",
            "cat",
            "banana",
            "ancestor",
            "scene",
            "descend",
            "descended",
            "sibling",
            "dangling"
        };
        Set<String> set = new HashSet<>(Arrays.asList(arr));
        return set.contains(s);
    }
    public static void test0_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'a', 'n', 'a'},
            {'a', 'p', 'e', 'n'},
            {'a', 'p', 'p', 'a'},
            {'d', 'a', 'n', 'g'},
            {'a', 'p', 'k', 'k'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test1_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test2_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a', 'b'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test3_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a', 'p', 'p'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test4_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'a', 'n'},
            {'a', 'n', 'a'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test5_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'e', 'e'},
            {'a', 'l', 'i'},
            {'l', 'n', 'l'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test00_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b'},
            {'e'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        //int w = 0, h = 0;

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }
        Aron.end();
    }
    public static void test01_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'i', 'e', 'f'},
            {'e', 'k', 'l', 'l'},
        };
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }

        Aron.end();
    }
    public static void test02_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'i', 'p', 'f'},
            {'e', 'k', 'p', 'l'},
            {'k', 'a', 'l', 'l'},
        };
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }

        Aron.end();
    }


    //
    // 3:23 4:49 5:19
    // word = "";
    public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int h, int height, int w, int width) {
        word.append(arr[h][w]);
        int index = h*width + w;
        if(!uniqueSet.contains(index)) {
            uniqueSet.add(index);

            if(isWord(word.toString()))
                set.add(word.toString());

            if(w + 1 < width) {
                maxWords(set, uniqueSet, word, arr, h, height, w + 1, width);
            }

            if(w - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h, height, w - 1, width);
            }

            if(h + 1 < height) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w, width);
            }

            if(h - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w, width);
            }

            if(w + 1 < width && h + 1 < height) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w + 1, width);
            }

            if(w - 1 >= 0 && h - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w - 1, width);
            }

            if(h + 1 < height && w - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w - 1, width);
            }

            if(h - 1 >= 0 && w + 1 < width) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w + 1, width);
            }
            uniqueSet.remove(h*width + w);
        }
        if(word.length() > 0)
            word.deleteCharAt(word.length()-1);
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

public class ConnectedIslandNew{
    public static void main(String[] args) {
//        test0();
//        test1();
//        test2();
        test_count8_0();
        test_count8_1();
        test_count8_2();
        test_count8_3();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   0,  1},
            { 1,   1,   0,  1},
            { 0,   1,   0,  1},
            { 0,   1,   1,  0},
        };
          
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Print.pbl(max);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        for(int j=-1; j<=1; j++){
            for(int i=-1; i<=1; i++){
                Print.pbl(j + " " + i);
            } 
        }
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 0,   0,   0,  0},
            { 0,   0,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 2);
        Aron.end();
    }
    public static void test_count8_0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 0,   0,   0,  0},
            { 0,   0,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 2);
        Aron.end();
    }
    public static void test_count8_1(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 1,   1,   0,  0},
            { 1,   1,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 7);
        Aron.end();
    }
    public static void test_count8_2(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  1},
            { 0,   1,   0,  0},
            { 0,   0,   0,  1},
            { 1,   1,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 3);
        Aron.end();
    }
    public static void test_count8_3(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   0,   1,  1},
            { 0,   1,   0,  0},
            { 1,   0,   1,  1},
            { 0,   1,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 8);
        Aron.end();
    }

    // *connected_island* *island*
    public static int count(int[][] arr, int h, int w, int height, int width){
        if(arr[h][w] == 1){
            arr[h][w] = 2;
            int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
            if(h + 1 < height)
                n1 = count(arr, h+1, w, height, width);
            if(h - 1 >= 0)
                n2 = count(arr, h-1, w, height, width);
            if(w + 1 < width)
                n3 = count(arr, h, w+1, height, width);
            if(w - 1 >= 0)
                n4 = count(arr, h, w-1, height, width);

            return n1 + n2 + n3 + n4 + 1;
        }
        return 0;
    }

    //
    // east, west, north, south, east/noth, north/west, west/south, south/east
    // 8 direction *8direction* *9direction* *9direct* 
    public static int count8(int[][] arr, int h, int w, int height, int width){
        int s = 0;
        if(arr[h][w] == 1){
            arr[h][w] = 2;
            for(int hh=-1; hh<=1; hh++){
                for(int ww=-1; ww<=1; ww++){
                    if(hh != 0 || ww != 0){
                        if(
                            (h + hh >= 0 && h+hh < height) && 
                            (w + ww >= 0 && w+ww < width) 
                            ) 
                        s +=count8(arr, h+hh, w+ww, height, width); 
                    }
                }
            }
            s += 1;
        }
        return s;
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Power 
{
	public static void main(String args[])

	  int[] A={2, 3, 3, 2,3,4};
		Co(A);
	}
	public static boolean  Co(int[] A)
	{
		int c=1;
		int max=1;
		int num=A[0];
		for(int i=0; i<A.length-1; i++)
		{
			if(A[i] == A[i+1])
			{
				c++;
				if(c > max)
				{
					max=c;
					num = A[i];
				} 
			}
			else
			{
				c--;
				if(c=0)
				{
					c=1;
				}
			}
		}
		System.out.println("max=" + max);
		System.out.println("num=" + num);
	}

}
import java.io.*;
import java.lang.String;
import java.util.*;
class CountNBit 
{
	public static void main(String args[])
	{
		CountNBit(32);
		System.out.println();
		int n = CountNBit(10);
		System.out.println("n=" + n);
	}

	public static int CountNBit(int n)
	{
		/*
		for(int i=0; i<n; i++)
		{
			String bin = Integer.toBinaryString(i);
			System.out.println(String.format("%5s", bin));
		}
		*/
		
		if(n==0)
			return 0;
		else if(n==1)
			return 1;
		else 
		{

			//a/2*x: half of column are 1
			//a is 2^floor(logn)
			//x = floor(logn)
			//
			//F(n-a): the number of 1 bit from 1 - 2^floor(logn)
			//
			//n-a+1 is the number of MSB from 2^floor(logn)-n
			//
			//F(n) = a/2*x + F(n-a) + n-a+1
			//
			int x = (int)Math.floor((double)Math.log(n)/(double)Math.log(2));
			int a = (int)Math.pow(2, x);
			return (a/2)*x + CountNBit(n-a) + (n-a+1);
		}
		
		
		
	}
}
public class CountOccurrences {
    public static void main(String[] args) {
        // write your code here
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    static void test0(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("a", "a");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    }
    static void test1(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aa", "a");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    }
    static void test2(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aaa", "aa");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 

    static void test3(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aacaaa", "aa");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 
    static void test4(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aaccacc", "ac");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 

    //[ file=countoccurrence.html title=""
    // count prefix occurrence
    static int countOccurrences(String str, String pattern){
        int count = 0;
        if(str == null || pattern == null)
            return 0;
        else if(str.length() == 0 || pattern.length() == 0)
            return 0;
        else {
            int start = 0;
            int k = 0;
            int len = pattern.length();
            int i = 0;
            while(i < str.length()){
                if(str.charAt(i) == pattern.charAt(k)){
                    if(k == 0)
                        start = i;
                    k++;
                    if(k == len){
                        count++;
                        k = 0;
                        i = start + 1;
                    }else{
                        i++;
                    }
                }else{
                    k = 0;
                    i = start + 1;
                    start++;
                }
            }
        }
        return count;
    }
    //]

}
import java.util.*;
import classfile.*;

public class Database {
  public static class Table {
    private final String name;
    private final String[] columnNames;
    private final List<List<Object>> data;

    public Table(String name, String[] columnNames, List<List<Object>> data) {
      this.name = name;
      this.columnNames = columnNames;
      this.data = data;
    }

    public void insert(Object[] row) {
      data.add(Arrays.asList(row));
    }

    public String getName() {
      return name;
    }

    public String[] getColumnNames() {
      return columnNames;
    }

    public List<List<Object>> getData() {
      return data;
    }

    public Table select(String[] projectedColumnNames) {
      // IMPLEMENT ME
      Aron.printList2d(data);
      for(List<Object> list : data){
        for(String cn : projectedColumnNames){
        }
      }
      return new Table("Select", null, null);
    }

    public Table where(String cName, Object value) {
      // IMPLEMENT ME
      int columnInx= 0;
      for(columnInx=0; columnInx<columnNames.length; columnInx++){
          if(columnNames[columnInx].equals(cName)){
              Print.p("columnInx=" + columnInx);
              break;
          }
      }

     Table tab = null;
     for(List<Object> ll : data){
         if(ll.get(columnInx).equals(value)){
             Print.p("columnInx.intValue()=" + value);

             List<List<Object>> rowList = new ArrayList<List<Object>>();
             rowList.add(ll);

             tab = new Table("dog", columnNames, rowList);
             break;
         }
     }

      // return new Table(getName(), null, null);
      return tab; 
    }

    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer(String.join(", ", columnNames)).append("\n");
      for (List<Object> row : data) {
        if (row.size() != 0) {
          Object value = row.get(0);
          sb.append(value == null ? "" : value.toString());
          for (int i = 1; i < row.size(); i++) {
            value = row.get(i);
            sb.append(", ").append(value == null ? "" : value.toString());
          }
        }
        sb.append("\n");
      }
      return sb.toString();
    }
  }

  private final Map<String, Table> tableMap;

  public Database() {
    this.tableMap = new HashMap<String, Table>();
  }

  public void addTable(Table table) {
    this.tableMap.put(table.getName(), table);
  }

  public Table getTable(String tableName) {
    return tableMap.get(tableName);
  }

  public Table innerJoin(Table leftTable, String leftTableKeyName, Table rightTable, String rightTableKeyName) {
    // IMPLEMENT ME
    return new Table("InnerJoin", null, null);
  }

  public static void main(String[] args) {
    Table departmentTable = new Table("departments", new String[]{"id", "name"}, new ArrayList<List<Object>>());
    departmentTable.insert(new Object[] {0, "engineering"});
    departmentTable.insert(new Object[] {1, "finance"});

    Table userTable = new Table("users", new String[]{"id", "department_id", "name"}, new ArrayList<List<Object>>());
    userTable.insert(new Object[] {0, 0, "Ian"});
    userTable.insert(new Object[] {1, 0, "John"});
    userTable.insert(new Object[] {2, 1, "Eddie"});
    userTable.insert(new Object[] {3, 1, "Mark"});

    Table salaryTable = new Table("salaries", new String[]{"id", "user_id", "amount"}, new ArrayList<List<Object>>());
    salaryTable.insert(new Object[] {0, 0, 100});
    salaryTable.insert(new Object[] {1, 1, 150});
    salaryTable.insert(new Object[] {2, 1, 200});
    salaryTable.insert(new Object[] {3, 3, 200});
    salaryTable.insert(new Object[] {4, 3, 300});
    salaryTable.insert(new Object[] {5, 4, 400});

    Database db = new Database();
    db.addTable(departmentTable);
    db.addTable(userTable);
    db.addTable(salaryTable);

    // should print
    // id, department_id, name
    // 1, 0, John
    //
    // select id, department_id, name from users where id = 1
    //
    //System.out.println(db.getTable("users").where("id", 1).select(new String[] {"id", "department_id", "name"}));
    
    Table table = db.getTable("users");
    Print.p(table.getName());
    Table wtable = table.where("id", 1);
    Print.p(wtable.getName());
    Aron.printArray(wtable.columnNames);
    Aron.printList2d(wtable.data);
    wtable.select(new String[]{"name"});

    // should print
    // users.name, departments.name
    // Ian, engineering
    // John, engineering
//    System.out.println(
//        db.innerJoin(db.getTable("users"), "department_id", db.getTable("departments"), "id")
//            .where("departments.name", "engineering")
//            .select(new String[]{"users.name", "departments.name"}));
  }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Card
{
	String suits;
	int rank;
	public Card(int rank, String suits)
	{ this.suits = suits; this.rank = rank;}
}
class Deck
{
	final int SIZE=52;
	Card[] deck = null;
	public Deck()
	{
		int c=0;
		deck = new Card[52];
		if( deck != null)
		{
			for(int i=0; i<13; i++)
			{
				deck[c++] = new Card(i+1, "Diamonts");		
				deck[c++] = new Card(i+1, "Clubs");		
				deck[c++] = new Card(i+1, "Hearts");		
				deck[c++] = new Card(i+1, "Spades");		
			}
		}
		System.out.println("c="+c);
	}
	public void Shuttle()
	{
		Random ran = new Random();
		for(int i=0; i<SIZE; i++)
		{
			int r = ran.nextInt(SIZE);
			System.out.println("r="+r);
			Card tmp = deck[r];	
			deck[r] = deck[SIZE-1-i];
			deck[SIZE-1-i] = tmp;
		}
	}
	public void show()
	{
		for(int i=0; i<SIZE; i++)
		{
			System.out.print(deck[i].suits+" "+deck[i].rank+" ");
			if( (i+1)%4==0)
				System.out.println();
		}
	}

}
class DeckCard 
{
	public static void main(String args[])
	{
		Deck d = new Deck();
		d.Shuttle();
		d.show();
	}
}
public class DepthTree 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int depth(Node r)
    {
        return 0;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
public class Dequeue{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        Deque<Node> queue = new ArrayDeque<Node>();
        queue.add(new Node(1));
        queue.add(new Node(2));
        System.out.println("size[" + queue.size() + "]"); 
        queue.poll();
        System.out.println("size[" + queue.size() + "]"); 

        Aron.end();
    }
} 
public class DiagonalMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[][] Array = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                        };
        for(int i=0; i<Array.length; i++)
        {
            for(int j=0; j<Array[0].length; j++)
            {
                System.out.print("["+Array[i][j]+"]");
            }
            System.out.println("");
        }
        System.out.println("");
        DiagonalMatrix(Array);
        System.out.println("");
        DiagonalMatrixAll(Array);
    }
    public static void DiagonalMatrix(int[][] matrix)
    {
        if(matrix != null)
        {
            int rowLen = matrix.length;
            if(matrix[0] != null)
            {
                int colLen = matrix[0].length;
                for(int i=0; i<rowLen; i++)
                {
                    for(int j=0; j<colLen; j++)
                    {
                        if(j-i >= 0)
                            System.out.print("["+matrix[j][j-i]+"]");
                        else
                            System.out.print("[ ]");
                    }
                    System.out.println("");
                }
            }
        }
    }
    public static void DiagonalMatrixAll(int[][] matrix)
    {
        if(matrix != null)
        {
            int rowLen = matrix.length;
            if(matrix[0] != null){
                int colLen = matrix[0].length;
                for(int i=0; i<rowLen; i++){
                    for(int j=0; j<colLen; j++){
                        if(j==j+i){
                            System.out.print("["+matrix[j][j+i]+"]");
                        }
                        else{
                            if(i%2 == 1){
                                if(j+i < colLen)
                                    System.out.print("["+matrix[j][j+i]+"]");
                                else
                                    System.out.print("[ ]");
                            }
                            else{
                                if(j-i >= 0)
                                    System.out.print("["+matrix[j][j-i]+"]");
                                else 
                                    System.out.print("[ ]");
                            }
                        }
                    }
                    System.out.println(" ");
                }
            }
        }
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.stream.Collectors;
import java.util.function.Function;
import java.util.function.BiFunction;
 

/*
    Tue Nov 20 09:45:31 2018 
-------------------------------------------------------------------------------- 
    Double linkedlist for generic type in Java
    append()
    addFront()
    remove()
        head node
        tail node
        middle node
    toList()
    print()
-------------------------------------------------------------------------------- 
*/ 
class MyNode<T>{
    MyNode<T> left;
    MyNode<T> right;
    T data;
    public MyNode(T data){
        this.data = data;
    }
}

class LinkedList<T>{
    public MyNode<T> head;    
    public MyNode<T> tail;
    public LinkedList(){
    }
    public void append(MyNode node){
        if(tail == null){
            head = tail = node;
        }else{
            tail.right = node;
            node.left = tail;
            tail = node;
        }    
    }
    public void addFront(MyNode node){
        if(head == null){
            head = tail = node;
        }else{
            MyNode tmp = head;
            head = node; 
            head.right = tmp;
            tmp.left = head;
        }
    }
    public void remove(MyNode r){
        if(head != null){
            // remove first node
            if(head == r){
                MyNode tmp = head.right;
                head = head.right;
                if(head == null) // only one node
                    tail = head;
                // more than one node
            }else{
                if(tail == r){ // last node, two or more nodes
                    tail = tail.left;
                    tail.right = null;
                }else{
                    // There are nodes between r 
                    MyNode left = r.left;
                    MyNode right = r.right;
                    left.right = right;
                    right.left = left;
                }
            }
        }
    }
    public void print(){
        MyNode tmp = head;
        while(tmp != null){
            Print.p(tmp.data);
            tmp = tmp.right; 
        }
    }        
    public ArrayList<T> toList(){
        ArrayList<T> list = new ArrayList<T>(); 
        MyNode<T> tmp = head;
        while(tmp != null){
            list.add(tmp.data);
            tmp = tmp.right; 
        }
        return list;
    }
}

public class DoubleLinkedListGeneric{
    public static void main(String[] args) {
        test1();
        test00();
        test01();
        test02();
        test03();
        test04();
    }

    public static void test04(){
        Aron.beg();
        LinkedList<Integer> ll = new LinkedList();
        ArrayList<Integer> ls = Aron.geneListInteger(0, 3);
        MyNode n1 = new MyNode(1);
        MyNode n2 = new MyNode(2);
        MyNode n3 = new MyNode(3);
        MyNode n0 = new MyNode(0);
        ll.append(n1);
        ll.append(n2);
        ll.append(n3);
        ll.print();
        ll.addFront(n0);
        ll.print();
        Test.t(ls, ll.toList());
        Print.fl("test04"); 
        ll.print();
        Aron.end();
    }
    public static void test03(){
        Aron.beg();
        Print.fl(); 
        LinkedList<Integer> ll = new LinkedList();
        MyNode n1 = new MyNode(1);
        MyNode n2 = new MyNode(2);
        MyNode n3 = new MyNode(3);
        ll.append(n1);
        ll.append(n2);
        ll.append(n3);
        ll.print();
        Print.fl("test03"); 
        ll.remove(n3);
        ll.print();
        Aron.end();
    }
    public static void test02(){
        Aron.beg();
        LinkedList<Integer> ll = new LinkedList();
        MyNode n1 = new MyNode(1);
        MyNode n2 = new MyNode(2);
        MyNode n3 = new MyNode(3);
        ll.append(n1);
        ll.append(n2);
        ll.append(n3);
        ll.print();
        Print.fl("test02"); 
        ll.remove(n2);
        ll.print();
        Aron.end();
    }
    public static void test01(){
        Aron.beg();
        LinkedList<Integer> ll = new LinkedList();
        MyNode n1 = new MyNode(1);
        MyNode n2 = new MyNode(2);
        MyNode n3 = new MyNode(3);
        ll.append(n1);
        ll.append(n2);
        ll.append(n3);
        ll.print();
        Print.fl(); 
        ll.remove(n1);
        Print.fl(); 
        ll.print();
        Aron.end();
    }
    public static void test00(){
        Aron.beg();
        LinkedList<Integer> ll = new LinkedList();
        MyNode n1 = new MyNode(1);
        MyNode n2 = new MyNode(2);
        MyNode n3 = new MyNode(3);
        ll.append(n1);
        ll.append(n2);
        ll.append(n3);
        ll.print();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import classfile.*;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 

class DoubleLinkedList_test{
    public static void main(String args[]) {
        test0();
        test_addFirst();
        test_addNext();
        test_delete_first();
        test_delete_middle();
        test_delete_last();
        test_delete_one();
        test_delete_none();
    }
    
    static void test0(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        
        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 3);
        Test.t(list.get(1).data, 4);
        Test.t(list.get(2).data, 5);

        Aron.end();
    }
    static void test_addFirst(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.append(p2);

        Node firstNode  = new Node(9);
        dll.addFirst(firstNode);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 9);
        Test.t(list.get(1).data, 3);
        Test.t(list.get(2).data, 4);

        Aron.end();
    }
    static void test_addNext(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.append(p2);

        Node nextNode = new Node(9);
        dll.addNext(p1, nextNode);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 3);
        Test.t(list.get(1).data, 9);
        Test.t(list.get(2).data, 4);

        Aron.end();
    }

    static void test_delete_last(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);

        dll.delete(p3);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 3);
        Test.t(list.get(1).data == 4);

        Aron.end();
    }
    static void test_delete_first(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        dll.delete(p1);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 4);
        Test.t(list.get(1).data == 5);

        Aron.end();
    } 
    static void test_delete_middle(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        dll.delete(p2);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 3);
        Test.t(list.get(1).data == 5);

        Aron.end();
    } 

    static void test_delete_one(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        dll.append(p1);
        dll.delete(p1);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 0);

        Aron.end();
    } 

    static void test_delete_none(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.delete(p2);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 1);
        Test.t(list.get(0).data == 3);

        Aron.end();
    } 
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 

//[ file=eightqueen.html title=""
// n queens problem
class Queen{
    List<Move> list = new ArrayList<>();
    private int width = 4;
    public Queen(int width){
        this.width = width;
    }

    class Move{
        public int c;
        public int r;
        public Move(int c, int r){
            this.c = c;
            this.r = r;
        }
    }

    // int c = 0;
    public void queenSolver(int c){
        if(c == width){
            for(Move m:list){
                Print.p("[" + m.c + "," + m.r + "]");
            }
            Ut.l();
        }else{
            for(int r=0; r<width; r++){
                if(isValidMove(c, r)){
                    list.add(new Move(c, r));
                    queenSolver(c+1);
                    list.remove(list.size()-1);
                }
            }
        }
    }
    public boolean isValidMove(int c, int r){
        for(Move m : list){
            if(m.r == r || Math.abs(m.c - c) == Math.abs(m.r - r))
                return false;
        }
        return true;
    }
}
//]

public class EightQueen{
    public static void main(String[] args) {
        test0();
        test1();
    }
    
    static void test0(){
        Aron.beg();
        Queen q = new Queen(4);
        int c = 0;
        q.queenSolver(c);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

// <enum>enum class example</enum>
// *j_enum_example* *jenum_example*
enum MyType {
    NUM(3),
    ROW(4);
    int value;
    MyType(int value) {
        this.value=value;
    }
    int Value() {
        return this.value;
    }
}

enum DAY{
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}

public class EnumExample {
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        Print.pbl("NUM=" + MyType.NUM.Value());
        Print.pbl("NUM=" + MyType.ROW.Value());
        Aron.end();
    }
    static void test1(){
        Aron.beg();

        getDay(DAY.SUNDAY);
        getDay(DAY.MONDAY);

        Aron.end();
    }
    public static void getDay(DAY day){
        if (day == DAY.SUNDAY){
            Print.pbl("sunday");
        }else if( day == DAY.MONDAY){
            Print.pbl("monday");
        }

    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class EvaluateExpr {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0() {
        Aron.beg();
        String str = "( 1 + 2 )";
        int sum = evaluate(str);
        Test.t(sum == 3);
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        String str = "( 1 - 2 )";
        int sum = evaluate(str);
        Test.t(sum == -1);
        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        String str = "( 1 - ( 2 - 4 ) )";
        int sum = evaluate(str);
        Test.t(sum == 3);
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        String str = "( 1 - ( ( 2 - 4 ) + 3 ) )";
        int sum = evaluate(str);
        Test.t(sum == 0);
        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        String str = "( 1 )";
        int sum = evaluate(str);
        Test.t(sum == 1);
        Aron.end();
    }
    public static void test10() {
        Aron.beg();
        String str = "12";
        boolean isNum = str.matches("[0-9]+");
        Print.pbl(isNum);

        str = "a12";
        isNum = str.matches("[0-9]+");
        Print.pbl(isNum);
        Aron.end();
    }
    // iterate the in order traversal  
    public static int evaluate(String str) {
        int sum = 0;
        Stack<Integer> operandStack = new Stack<Integer>();
        Stack<String> operatorStack = new Stack<String>();

        String[] arr = str.split("\\s+");
        for(String s : arr){
            if(Aron.isNumeric(s)) {
                operandStack.push(Integer.parseInt(s));
            } else if(s.equals("+") || s.equals("-")) {
                operatorStack.push(s);
            } else if(s.equals(")")) {
                if(operatorStack.size() > 0 && operandStack.size() > 1) {
                    String op = operatorStack.pop();
                    int right = operandStack.pop();
                    int left  = operandStack.pop();
                    if(op.equals("+")) {
                        operandStack.push(left + right);
                    } else if(op.equals("-")) {
                        operandStack.push(left - right);
                    } else
                        Print.pbl("Expression Error");
                }
            }
        }
        Aron.printArray(arr);
        return operandStack.peek();
    }
}

import java.util.*;
import classfile.*;

public class ExcelColumnNumber{
    public static void main(String[] args) {
        System.out.println("Print all permuation character with repeating character!");
        String s = "ABC";
        char[] array = new char[s.length()];
        int depth = 0;
        Set<Character> map = new LinkedHashSet<Character>();
        //permRepeated(s, array, depth);
        //perm(s, array, depth, map);

        int[] arr = new int[1];
        int num = 20;
        arr[0] = 1;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i, arr, num);

        ExcelSheetRowNumberDirect(1);
        System.out.println("================");
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test11_printBinary();

        test00_ExcelSheetRowNumberDirect();
    }
    
    static void test00_ExcelSheetRowNumberDirect(){
        Aron.beg();
        int num = 1;
        Print.p("num=" + num);
        ExcelSheetRowNumberDirect(num);

        num = 26;
        Print.p("num=" + num);
        ExcelSheetRowNumberDirect(num);

        Aron.end();
    }
    static void test11_printBinary(){
        Aron.beg();

        Test.t(printBinary(0), "0"); 
        Test.t(printBinary(1), "1"); 
        Test.t(printBinary(2), "10"); 
        Test.t(printBinary(3), "11"); 
        Test.t(printBinary(4), "100");

        Aron.end();
    } 

    public static void test5() {
        System.out.println("test5");
        String prefix = "";
        int nBits = 1;
        int count = 0;
        int height = 1;
        nBitsBinaryString("", nBits, count, height);
    }
    public static void test6() {
        System.out.println("test6");
        String prefix = "";
        int nBits = 2;
        int count = 0;
        int height = 2;
        nBitsBinaryString("", nBits, count, height);
    }
    public static void test7() {
        System.out.println("test7");
        String prefix = "";
        int nBits = 3;
        int count = 0;
        int height = 4;
        nBitsBinaryString("", nBits, count, height);
    }

    public static void nBitsBinaryString(String prefix, int nBits, int count, int height) {
        if(count == nBits && height == 0)
            System.out.println(prefix);
        else if(height > 0) {
            nBitsBinaryString(prefix + "0", nBits, count, height-1);
            nBitsBinaryString(prefix + "1", nBits, count+1, height-1);
        }
    }
    /*
    public static void permrepeating(String str, String permStr, int k, int h){
        int len = array.length;
        if(permStr.length() == k){
            System.out.println(permStr);
        }
        else{
            for(int i=0; i<len; i++){
                String s = str.charAt(i) + "";
                permrepeating(str, permStr + s, k, h+1);
            }
        }
    }
    */
    public static void test1() {
    }
    public static void test2() {
        ExcelSheetRowNumberDirect(1000000);
    }

    public static void test3() {
        int n = ExcelSheetStringToInteger("A");
        System.out.println("A=" + n);

        n = ExcelSheetStringToInteger("Z");
        System.out.println("Z=" + n);


        n = ExcelSheetStringToInteger("AA");
        System.out.println("AA=" + n);
        n = ExcelSheetStringToInteger("AB");
        System.out.println("AB=" + n);
    }

    public static void test4() {
        String str = ExcelSheetIntergeToString(1);
        System.out.println("1=" + str);

        str = ExcelSheetIntergeToString(2);
        System.out.println("2=" + str);

        str = ExcelSheetIntergeToString(26);
        System.out.println("26=" + str);

        str = ExcelSheetIntergeToString(28);
        System.out.println("28=" + str);
    }

    // 1 -> 0 -> 'A'
    // 2 -> 1 -> 'B'
    // 3 -> 2 -> 'C'
    // 26->25 -> 'Z'
    // 27->26 -> 'AA'

    public static String ExcelSheetIntergeToString(int n) {
        String ret = "";
        char[] array = new char[26];
        for(int i=0; i<26; i++)
            array[i] = (char)((int)'A' + i);

        if( n-1 == 0)
            ret = array[n-1] + "";
        else {
            while(n > 0) {
                int rem = (n-1) % 26;
                n = (n-1) / 26;
                ret = (char)array[rem] + "" + ret;
            }
        }
        return ret;
    }
    // 'A' -> 0 -> 1
    // 'B' -> 1 -> 2
    // 'C' -> 2
    // 'Z' -> 25
    // 'AA'-> 26 ->27
    // (a % m) = x
    // 1 % m = y
    // (a + 1) % m  = x + y
    //
    public static int ExcelSheetStringToInteger(String str) {
        int sum = 0;
        if(str != null) {
            int len = str.length();
            for(int i=0; i<len; i++) {
                int n = str.charAt(len-1-i) - 'A' + 1;
                sum += (int)Math.pow(26, i)*n;
            }
        }
        return sum;
    }

    //Calculate the excel sheet row number directly
    //   s = 26^1 + 26^2 + 26^3 + ... + 26^k
    // 26s = 26^2 + 26^3 + 26^4 + ... + 26^(k+1)
    // 25s = 26^(k+1) - 26
    // 25s + 26 = 26^(k+1)
    // log(25s+26)/log(26) = k+1
    // log(25s+26)/log(26)-1 = k
    public static void ExcelSheetRowNumberDirect(int num) {
        int k = (int)(Math.log(25*num + 26)/Math.log(26)) - 1;
        int diff = num - (int)(Math.pow(26, k+1) - 26)/25;
        int[] arr = new int[26];

        Print.p(k);
        Print.p("diff=" + diff);

        for(int i=0; i<26; i++)
            arr[i] = 'a'+i;

        int n = diff;
        if(diff == 0)
            n = num;

        while(n > 0) {
            int r = (n-1) % 26;
            Print.p((char)arr[r]);
            n /= 26;
        }
        System.out.println();
    }
    //print excel sheet row number algorithm based on permutation
    public static void ExcelSheetRowNumber(String s, int num) {
        int[] arr = new int[1];
        arr[0] = 1;
        char[] array = new char[s.length()];
        int depth = 0;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i, arr, num);
    }


    //Given string character array and integer k,
    //print all permutation with repeatation string length k
    public static void permRepeatedChooseK(String s, char[] array, int depth, int k, int[] arr, int num) {
        if(depth == k) {
            if(arr[0] == num)
                System.out.print("<"+num+">");
            System.out.print("{"+arr[0]+"}");
            arr[0]++;
            for(int i=0; i<depth; i++) {
                System.out.print("["+array[i]+"]");
            }
            System.out.println();
        } else {
            for(int i=0; i<s.length(); i++) {
                array[depth] = s.charAt(i);
                permRepeatedChooseK(s, array, depth+1, k, arr, num);
            }
        }
    }
    
    //[ file=headertonumber.html title=""
    static int excelNum(String header){
        int sum = 0;
        if(header != null){
            int len = header.length(); 
            for(int i=0; i<len; i++){
                int n = header.charAt(len-1 - i) - 'A' + 1;
                sum += n*Math.pow(26, i);
            }
        }
        return sum;
    }
    //]

    //[ file=numbertoheader.html title=""
    // 0 -> 'A'
    // 1 -> 'B'
    // 25 -> 'Z'
    // num = 1 -> 'A'
    // num = 26 -> 'A' + 25 = 'Z'
    // num = 27
    // reminder = 0 -> 'A'
    // num = 1
    // reminder = 0 -> 'A'
    // num = 52
    // (52 - 1) % 26 = 25 -> 'Z'
    // 52 / 26 = 2
    //  x = ['A' - 'Z'] - 'A'
    //  x = [0 ... 25]
    //  
    //  n = x + 1
    //  sum = (x + 1)*pow(26, 2) + (x + 1)*pow(26, 1) + (x+1)*pow(26, 0)
    static String numToHeader(int num){
        String str = "";
        while(num > 0){
            int reminder = (num - 1) % 26;
            char ch = (char)(reminder + 'A');
            str = ch + "" + str;
            num = (num - 1) / 26;
        }
        return str;
    }
    //]

    static String printBinary(int n){
        String str = "";
        if( n == 0)    
            str += "0";
        else{     
            while(n > 0){
                int reminder = n % 2;
                str = (reminder + "") + str;
                n /= 2;
            }
        }
        return str;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class ExcelNumberBinary{
    public static void main(String[] args) {
        test1();
        test3();

        test0_excel();
        test1_excel();
        test2_excel();

        test0_printExcel();
        test1_printExcel();
        test2_printExcel();
    }
    public static void test0() {
        Aron.beg();
        String str = intToAlphabet(0);
        Print.pb(str);
        Aron.end();
    }
    public static String intToAlphabet(int n) {
            int num = (int)'a' + n;
            char ch = (char)num;
            return "" + ch;
    }
    public static void test1() {
        Aron.beg();
        int num = 16;
        printAllBinary(num);
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        int num = 17;
        printAllBinary(num);
        Aron.end();
    }

    //[ file=printbin.html title=""
    /**
    * print all binary from zero to num-1 with length log2(num)
    * @param num maximum number 
    */
    public static void printAllBinary(int num) {
        String str = "";
        int binLen = (int)Math.ceil(Math.log(num)/Math.log(2));

        for(int j=0; j<num; j++){
            int n = j;
            for(int i=0; i<binLen; i++){
                if(n % 2 == 0)
                    str = "0" + str;
                else
                    str = "1" + str;

                n = n/2;
            } 
            Print.pbl(str);
            str = "";
        } 
    }
    //]


    //[ file=binexcel.html title=""
    // [1 -> 26] = ['A' -> 'Z']
    // [0 -> 25]   ['A' -> 'Z'] 
    public static void excelNumSaveLength(int num) {
        int binLen = 1;
        if(num == 1) 
            binLen = 1;
        else 
            binLen = (int)Math.ceil(Math.log(num)/Math.log(26));

        for(int j=1; j<=num; j++){
            int n = j;
            String str = "";
            for(int i=1; i<=binLen; i++){
                String s = Aron.intToAlphabetUpper((n-1)%26);
                str = s + str;
                n = (n-1)/26;
            } 
            Print.pbl(str);
        } 
    }
    //]
    //[ file=excelnum1.html title=""
    // [1 -> 26] = ['A' -> 'Z']
    // [0 -> 25]   ['A' -> 'Z'] 
    public static void printExcel(int num){
        int base = 26;
        for(int i=1; i<=num; i++){
            int x = i;
            String str = "";
            if(x-1 == 0)
                str = 'A' + str;
            else{
                while( x > 0){
                    int r = (x-1) % base;
                    String s = Aron.intToAlphabetUpper(r);
                    str = s + str;
                    x = (x-1) / base;
                }
            }
            Print.pbl(str);
        }
    }
    //]

    public static void test0_excel() {
        Aron.beg();
        int num = 26;
        excelNumSaveLength(num);

        Aron.end();
    }
    public static void test1_excel() {
        Aron.beg();
        int num = 1; 
        excelNumSaveLength(num);

        Aron.end();
    }
    public static void test2_excel() {
        Aron.beg();
        int num = 27; 
        excelNumSaveLength(num);
        Aron.end();
    }
    public static void test0_printExcel() {
        Aron.beg();
        int num = 1; 
        printExcel(num);
        Aron.end();
    }
    public static void test1_printExcel() {
        Aron.beg();
        int num = 26; 
        printExcel(num);
        Aron.end();
    }
    public static void test2_printExcel() {
        Aron.beg();
        int num = 27; 
        printExcel(num);
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

//[ file=throw.html title=""
// User-defined Exception
class BigException extends Exception{
    public BigException(String msg){
        super(msg);
    }
}

class SmallException extends Exception{
    public SmallException(String msg){
        super(msg);
    }
}


public class ExceptionExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    // throw IOException and try/catch them
    static void test0(){
        Aron.beg();

        try{
            openFile("text/myfile1.txt");
        }catch(IOException e){
            System.err.println(e.getMessage());
        }

        Aron.end();
    }
    
    static void test1(){
        Aron.beg();
        openFile1("text/myfile1.txt");
        Aron.end();
    }
    
    static void test2(){
        Aron.beg();
        sizeMatter(20);
        sizeMatter(1000);
        sizeMatter(-1000);
        Aron.end();
    } 

    static void sizeMatter(int n){
        try{
            if(n > 100){
                throw new BigException("Too big BigException");
            }else if(n < -100){
                throw new SmallException("Too small SmallException");
            }
        }catch(BigException e){
            Print.p(e.getMessage());
        }catch(SmallException e){
            Print.p(e.getMessage());
        }
    }
    static void openFile(String fName) throws IOException{
        BufferedReader br = new BufferedReader(new FileReader(fName));
        String line = null;
        while( (line = br.readLine()) != null){
            Print.pl(line);
        }
        throw new IOException("Yep, throw IOException");
    }

    static void openFile1(String fName) {
        try{
            BufferedReader br = new BufferedReader(new FileReader(fName));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pl(line);
            }
        }catch(IOException e){
            System.err.println(e.getMessage());
        }
    }
    //]
} 
import java.util.*;
import java.io.*;
import classfile.*;

public class ExeCommand{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String output = Aron.executeCommand("ls");
        Print.pbl(output);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import classfile.*;

// Fiabonacci number with matrix, fiabonacci matrix 
class Fibonacci {
    public static void main(String args[]) {
        int n=10;
        int[][] Arr = new int[2][2];
        int[][] A = nFibonacciNum2(Arr, n);
        System.out.println("A[1][0]=" + A[1][0]);

        int fib = nFibonacciNum1(n);
        System.out.println("fib=" + fib);
    }
    //O(n^2)
    public static int nFibonacciNum(int n) {
        if(n == 0)
            return 0;
        else if(n==1)
            return 1;
        return nFibonacciNum(n-1)+nFibonacciNum(n-2);
    }

    //O(n)
    public static int nFibonacciNum1(int n) {
        int ret=0;
        if(n==0)
            ret = 0;
        else if(n==1)
            ret = 1;
        else {
            int a=0;
            int b=1;
            int c=1;
            int count=2;
            while(count <= n) {
                c = a + b;
                a = b;
                b = c;
                count++;
            }
            ret = c;
        }
        return ret;
    }
    //O(logn)
    public static int[][] nFibonacciNum2(int[][] A, int n) {
        if(n==0) {
            A[0][0] = 0;
            A[1][0] = 0;
            A[0][1] = 0;
            A[1][1] = 0;
            return A;
        } else if(n==1) {
            A[0][0] = 1;
            A[1][0] = 1;
            A[0][1] = 1;
            A[1][1] = 0;
            return A;
        } else {
            if(n%2 == 0)
                return MultiMat(nFibonacciNum2(A, n/2), nFibonacciNum2(A, n/2));
            else
                return MultiMat(A, MultiMat(nFibonacciNum2(A, (n-1)/2), nFibonacciNum2(A, (n-1)/2)));
        }
    }

    public static int[][] MultiMat(int[][] A1, int[][] A2) {
        int[][] A = new int[2][2];

        A[0][0] = A1[0][0]*A2[0][0] + A1[0][1]*A2[1][0];
        A[1][0] = A1[1][0]*A2[0][0] + A1[1][1]*A2[1][0];
        A[0][1] = A1[0][0]*A2[1][0] + A1[0][1]*A2[1][1];
        A[1][1] = A1[1][0]*A2[0][1] + A1[1][1]*A2[1][1];
        return A;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// FileOutStream example, outputstream, output stream, write raw data to file,
// filetream filestream, stream file, write byte[] to file,
public class FileOutStreamExample {
    public static void main(String[] args) {
        test0();
    }
    public static void test0() {
        Aron.beg();

        File file = new File("./text/raw1.txt");
        String content = "write byte[] array to file";

        try (FileOutputStream fop = new FileOutputStream(file)) {
            // if file doesn't exists, then create it
            if (!file.exists()) {
                file.createNewFile();
            }

            // get the content in bytes
            byte[] contentInBytes = content.getBytes();

            fop.write(contentInBytes);
            fop.flush();
            fop.close();

            System.out.println("Done");

        } catch (IOException e) {
            e.printStackTrace();
        }

        Aron.end();
    }
}

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
import java.io.*;
//
import classfile.*; 

// FileInputStream example, FileOutputStream example, 
// FileInputStream, FileOutputStream, read raw byte[] from file, read binary file
// read chunk file, skip file, seek file, 
class FileRead {
    public static void main(String args[]) {
//        test0();
        test1();
//        test2();
    }
    
    static void test0(){
        Aron.beg();

        try {
            // Open the file that is the first
            // command line parameter

            String fName = "/Users/cat/myfile/github/java/text/file3.txt";
            FileInputStream fstream = new FileInputStream(fName);
            // Get the object of DataInputStream
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            //Read File Line By Line
            while ((strLine = br.readLine()) != null) {
                // Print the content on the console
                System.out.println (strLine);
            }
            //Close the input stream
            in.close();
        } catch (Exception e) {
            //Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        Aron.end();
    }
    static void test1(){
        Aron.beg();

//        try {
//            String fName = "/Users/cat/myfile/github/java/text/file3.txt";
//            File file = new File(fName);
//
//            FileInputStream fstream = new FileInputStream(fName);
//            int nbyte = 0;
//            //Read File Line By Line
//            byte[] arr = new byte[20];
//            while ((nbyte = fstream.read(arr)) != -1) {
//                for(int i=0; i<nbyte; i++){
//                    Print.pbl(arr[i]);
//                } 
//                String str = new String(arr);
//                Print.pbl(str + " size=" + nbyte);
//            }
//            //Close the input stream
//            fstream.close();
//        } catch (Exception e) {
//            //Catch exception if any
//            System.err.println("Error: " + e.getMessage());
//        }
        
        String fName = "/Users/cat/myfile/github/java/text/file3.txt";
        int bufSize = 40;
        List<String> list = readFileLineByte(fName, bufSize); 
        Aron.printList(list);
        Aron.end();
    }
    public static List<String> readFileLineByte(String fName, int bufSize){
        List<String> list = new ArrayList<String>(); 
        try {
            FileInputStream fstream = new FileInputStream(fName);
            int nbyte = 0;
            //Read File Line By Line
            byte[] arr = new byte[bufSize];
            byte[] lineArr = new byte[bufSize];
            int k=0;
            while ((nbyte = fstream.read(arr)) != -1) {
                String str = new String(arr);

                for(int i=0; i<nbyte; i++){
                    Print.pbl("char=" + arr[i]);
                    if(arr[i] == '\n'){
                        Print.pbl("newline=" + arr[i]);

                        lineArr[k] = arr[i];
                        list.add(new String(lineArr));
                        k = 0;
                        lineArr = new byte[bufSize];
                    }else{
                        lineArr[k] = arr[i];
                        k++;
                    }
                }
            }
            //Close the input stream
            fstream.close();
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
        return list;
    }
    
    static void test2(){
        Aron.beg();
        String currDir = "/Users/cat/myfile/github/java";
        List<String> list = Aron.getCurrentDirs(currDir);
        Aron.printList(list);
        List<String> flist = Aron.getCurrentFiles(currDir);
        Ut.l();
        Aron.printList(flist);

        Aron.end();
    }
}
import java.util.*;
import java.util.stream.*;
import java.io.*;
import classfile.*;

public class Filter {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        List<Integer> list1 = Arrays.asList(1, 2, 3); 
        List<Integer> list2 = Arrays.asList(2, 1, 3); 
        List<Integer> left = list1.stream().filter(x -> x < 2).collect(Collectors.toList());
        List<Integer> right = list1.stream().filter(x -> x > 2).collect(Collectors.toList());
        Aron.printList(left);
        Aron.printList(right);

        

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}

public class FindKeyRotateArray {
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }

    public static void test0() {
        System.out.println("Find the max element in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        int key = 1;
        boolean ret = findKey(array, left, right, key);
        //boolean ret1 = binarySearch(array, left, right, key);
        boolean ret2 = findKey(array, left, right, key);
        System.out.println("key="+ret);
        //System.out.println("key1="+ret1);
        System.out.println("key2="+ret2);
    }
    public static void test1() {
        System.out.println("Find the max element in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        int key = 1;
        Aron.printArray(array);
        System.out.println("key="+key);
        boolean ret = findKey(array, left, right, key);
        System.out.println("key="+ret);
    }

    public static void test2() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }
    public static void test3() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test4() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test5() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test6() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex2(array, left, right);
        System.out.println("index="+index);
    }

    public static void test7() {
        System.out.println("Find the min Index in a sorted and rotated array");
        int[] array = {3, 2};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMinIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test8() {
        System.out.println("Find the min Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMinIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static int findMaxIndex(int[] array, int left, int right) {
        int ret = -1;
        int len = right - left + 1;
        if( len == 1)
            ret = left;
        else if( len == 2)
            ret = array[left] > array[right]? left:right;
        else if(len > 2) {
            int mid = (left + right)/2;
            if(array[left] < array[mid])
                ret = findMaxIndex(array, mid, right);
            else
                ret = findMaxIndex(array, left, mid);
        }
        return ret;
    }

    public static boolean findKey(int[] array, int left, int right, int key) {
        if(left == right)
            return array[left] == key;

        int maxIndex = findMaxIndex(array, left, right);
        return binarySearch(array, left, maxIndex, key) || binarySearch(array, maxIndex+1, right, key);
    }
    public static boolean binarySearch(int[] array, int left, int right, int key) {
        boolean ret = false;
        if(array != null) {
            int mid = (left + right)/2;
            if(left < right) {
                if(key < array[mid]) {
                    ret = binarySearch(array, left, mid-1, key);
                } else if(key > array[mid]) {
                    ret = binarySearch(array, mid+1, right, key);
                } else
                    ret = true;
            } else if(left == right)
                ret = array[left] == key;
        }
        return ret;
    }

    // 1 2 3
    // 2 3 1
    // 1
    public static int findMinIndex(int[] array, int left, int right) {
        if(array != null) {
            if(array[left] < array[right])
                return left;
            else {
                int mid = (left + right)/2;
                if(array[mid] < array[right])
                    return findMinIndex(array, left, mid);
                else if(array[mid] > array[right])
                    return findMinIndex(array, mid+1, right);
                else if(array[mid] == array[right])
                    return mid;
            }
        }
        return -1;
    }
    // 1 2 3
    // 2 3 1
    // 3 1
    //
    // 3 1 2

    public static int findMaxIndex2(int[] array, int left, int right) {
        if( array != null) {
            //no rotation
            // {2}
            // {2, 3}
            if(array[left] < array[right])
                return right;
            else {
                //One rotation at least
                int mid = (left + right)/2;
                if(array[left] < array[mid])
                    return findMaxIndex2(array, mid, right);
                else if(array[left] > array[mid])
                    return findMaxIndex2(array, left, mid);
                else if(array[left] == array[mid])
                    return mid;
            }
        }
        return -1;
    }

    //No duplicated elements in the array
    public static boolean findKeyRotateArray(int[] array, int left, int right, int key) {
        boolean ret = false;
        if(array != null) {
            int len = right - left + 1;
            if(len == 1) {
                if(key == array[left])
                    ret = true;
            } else if (len > 1) {
                int mid = (left + right)/2;
                if(array[left] < array[mid]) {
                    if(key > array[mid])
                        ret = findKey(array, mid+1, right, key);
                    else if(key < array[mid]) {
                        if(array[left] < key)
                            ret = findKey(array, left, mid-1, key);
                        else if(array[left] > key)
                            ret = findKey(array, mid+1, right, key);
                        else
                            ret = true;
                    } else
                        ret = true;
                } else if(array[left] > array[mid]) {
                    if(key < array[mid])
                        ret = findKey(array, left, mid-1, key);
                    else if(key > array[mid]) {
                        if(key < array[left]) {
                            ret = findKey(array, mid+1, right, key);
                        } else if(key > array[left]) {
                            ret = findKey(array, left, mid-1, key);
                        } else
                            ret = true;
                    } else
                        ret = true;
                } else {
                    ret = array[left] == key || array[right] == key? true : false;
                }
            }
        }
        return ret;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
    public Node parent;
	public int data;
    boolean isVisited;
	public Node(int n)
	{ data = n; left = right = parent = null; isVisited = false;}
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ 
                        cur.left = new Node(n); end = true; 
                        cur.left.parent = cur;
                    }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ 
                        cur.right = new Node(n); end = true; 
                        cur.right.parent = cur;
                    }
					else
						cur = cur.right;
				}
			}
		}
	}

	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
	public Node getRoot()
	{ return root;}
}
class FindKthNeighbour 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);

		Node r = b1.getRoot();
		Inorder(r);
        //
		int[] Arr = new int[100];
		int len=0;
        Node initNode = r;

        List<Node> list = new LinkedList<Node>();
        Node randNode = GetRandomNode(r, initNode, list); 
        System.out.println("randNode["+randNode.data+"]");
        PrintAllKthNeighbour(randNode, 3);
	}
	
    public static Node GetRandomNode(Node node, Node initNode, List<Node> list)
    {
        if(node != null)
        {
            GetRandomNode(node.left, initNode, list);
            list.add(node);
            GetRandomNode(node.right, initNode, list);
            Random rand = new Random();
            if(initNode == node)
            {
                int index = rand.nextInt(list.size()); 
		        System.out.println("rand=["+index+"] list=["+list.size()+"]");
                return list.get(index);
            }
        }
        return null;
    }
    public static void PrintAllKthNeighbour(Node node, int k)
    {
        if(node != null && !node.isVisited)
        {
            node.isVisited = true;
            if(k == 0)
            {
		        System.out.println("Neighbour["+node.data+"]");
            }
            else
            {
                k--;
                PrintAllKthNeighbour(node.left, k);
                PrintAllKthNeighbour(node.right, k);
                PrintAllKthNeighbour(node.parent, k);
            }
        }
    }
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
public class FindMaxRotateArray 
{
				public static void main(String[] args)
				{
                    System.out.println("Find the max element in a sorted and rotated array");
                    int[] array = {1, 2, 4};
                    int left = 0;
                    int right = array.length - 1;
                    int max = findMax(array, left, right);
                    int key = 2;
                    boolean ret = findKey(array, left, right, key);
                    System.out.println("max="+max);
                    System.out.println("key="+ret);
				}
                public static int findMax(int[] array, int left, int right)
                {
                    int ret = 0; 
                    int len = right - left + 1;
                    if( len == 1)
                        ret = array[left];
                    else if( len == 2)
                        ret = array[left] > array[right]? array[left]:array[right];
                    else if(len > 2)
                    {
                        int mid = (left + right)/2;
                        if(array[left] < array[mid])
                            ret = findMax(array, mid, right);
                        else 
                            ret = findMax(array, left, mid);
                    }
                    return ret;
                }
                //No duplicated elements in the array
                public static boolean findKey(int[] array, int left, int right, int key)
                {
                    boolean ret = false;    
                    if(array != null)
                    {
                        int len = right - left + 1; 
                        if(len == 1)
                        {
                            if(key == array[left])
                                ret = true;
                        }
                        else if (len > 1)
                        {
                            int mid = (left + right)/2;    
                            if(array[left] < array[mid])
                            {
                                if(key > array[mid])
                                    ret = findKey(array, mid+1, right, key);
                                else if(key < array[mid])
                                {
                                    if(array[left] < key)
                                        ret = findKey(array, left, mid-1, key);
                                    else if(array[left] > key)
                                        ret = findKey(array, mid+1, right, key);
                                    else 
                                        ret = true;
                                }
                                else
                                    ret = true;
                            }
                            else if(array[left] > array[mid])
                            {
                                if(key < array[mid])
                                    ret = findKey(array, left, mid-1, key);
                                else if(key > array[mid])
                                {
                                    if(key < array[left])
                                    {
                                        ret = findKey(array, mid+1, right, key);
                                    }
                                    else if(key > array[left])
                                    {
                                        ret = findKey(array, left, mid-1, key);
                                    }
                                    else
                                        ret = true;
                                }
                                else
                                    ret = true;
                            }
                            else
                            {
                                ret = array[left] == key || array[right] == key? true : false;
                            }
                        }
                    }
                    return ret;
                }
}
import java.util.*;

public class FindMedianLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Find the median of linkedlist");
        SLL s1 = new SLL();
        s1.append(2);
        s1.append(20);
        s1.append(30);
        s1.append(40);
        s1.append(50);

        Node node = median(s1.getHead());
        System.out.println("median["+node.data+"]");
    }

    public static void show(Node curr)
    {
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }
    
    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class FindNegative2DMat 
{
	public static void main(String args[])
	{
			int[][] Arr = new int[3][4];
			gen2D(Arr);
			int s = FindNegative(Arr);
			System.out.println("s=" + s);
	}

	public static void gen2D(int[][] Arr)
	{
		int row, col;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;
			Arr[0][0] = -2;
			Random r = new Random();
			for(int i=0; i<row; i++)
			{
				int ran = r.nextInt(3); 
				for(int j=0; j<col; j++)
				{
					if(i-1>=0 && j-1>=0)
					Arr[i][j] = Arr[i-1][j]+ Arr[i][j-1]+ran + 5;
					else if(j-1>=0)
						Arr[i][j] = Arr[i][j-1]+ran;
					else if(i-1>=0)
						Arr[i][j] = Arr[i-1][j]+ran;

					System.out.print(String.format("%10s", Arr[i][j]));
				}
				System.out.println();
			}
		}
	}
	public static int FindNegative(int[][] Arr)
	{
		int sum=0;
		if(Arr != null)
		{
			int nRow = Arr.length;
			int nCol = Arr[0].length; 

			int down = 0;
			int left = nCol-1;

			while(down < nRow && left >=0)
			{
				if(Arr[down][left] < 0)
				{
					sum = sum + left + 1;
					down++;
				}
				else 
					left--;
			}
		}
		return sum;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class FindNode 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
        
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        

        System.out.println("Before Swap");
        inorder(b1.getRoot());

        System.out.println("============");
        System.out.println("After Swap");

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        swap(199, 16, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
        System.out.println("============");
        findNode(b1.getRoot(), 199);
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static boolean findNode(Node node, int k)
    {
        if(node != null)
        {
            if(findNode(node.left, k))
            {
                System.out.println(node.data);
                return true;
            }

            if(node.data == k)
            {
                System.out.println(k);
                return true;
            }

            if(findNode(node.right, k))
            {
                System.out.println(node.data);
                return true;
            }
        }
        return false;
    }
    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }
}
import java.util.*;

class Node {
    char ch;
    public Node(char ch) {
        this.ch = ch;
    }
}

// get first non duplicated char from a stream
// use HashMap and Double LinkedList
public class FirstOccurCharFromStream {
    public static void main(String[] args) {
        System.out.println("Find the first occurrence character from a stream");
        String str = "kkc";
        char ch = FirstOccurrence(str);
        System.out.println("ch=["+ch+"]");
    }
    public static char FirstOccurrence(String str) {
        char ret = 0;
        List<Node> list = new LinkedList<Node>();
        if(str != null) {
            Map<Integer, Node> map = new HashMap<Integer, Node>();
            int len = str.length();
            for(int i=0; i<len; i++) {
                char ch = str.charAt(i);
                if(map.containsKey((int)ch)) {
                    Node node = map.get((int)ch);
                    if(node != null) {
                        list.remove(node);
                        map.put((int)ch, null);
                    }
                } else {
                    Node node = new Node(ch);
                    map.put((int)ch, node);
                    list.add(node);
                }
            }
        }
        if(list.size() > 0)
            ret = list.get(0).ch;
        return ret;
    }
}
import java.util.*;


//single linked list
class Node 
{
	Node next;
	int data;
	public Node(int n)
	{ next = null; data = n;}
}

class SLL
{
	Node head;
	public SLL()
	{ head = null;}
	public void append(int n)
    {
        Node cur = head;
		if(head == null)
			head = new Node(n);
		else
		{
			while(cur.next != null)
			{ 
                cur = cur.next; 
            }
			cur.next = new Node(n);
		}

    }
	public void append(Node no)
	{
		Node cur = head;
		if(head == null)
			head = no;
		else
		{
			while(cur.next != null)
			{ cur = cur.next; }
			cur.next = no;
		}
	}

	//recursive 
	static Node next=null;
	public void Reverse(Node cur)
	{
		if(cur != null)
		{
			Reverse(cur.next);
			if(next != null)
				next.next = cur;	
			else 
				head = cur;
			next = cur;
			cur.next = null;
		}
	}
	//iteration
	public void Reverse1(Node cur)
	{
		if(head != null)
		{
			Node prev = null;
			Node next = cur.next;

			while(cur != null)
			{
				cur.next = prev;
				prev = cur;
				cur = next;
				if(next != null)
					next = next.next;
			}
			head = prev;
			
		}
	}
	public Node getHead()
	{ return head;}

    public Node getTail()
	{ 
        Node curr = head;
        while(curr != null && curr.next != null)
        {
            curr = curr.next;
        }
        return curr;
    }

	public void Remove(Node no)
	{
		if(no != null && head != null)
		{
			Node cur = head;	
			Node prev = null;
			while(cur != no)
			{
				prev = cur;
				cur = cur.next;
			}
			if(prev != null && no.next != null)
			{ prev.next = no.next; no.next = null; }
			else if(prev == null && no.next != null)
			{ head = no.next; no.next = null; }
			else if(prev != null && no.next == null)
			{ prev.next = null; }
			else 
			{ no = null; head = null;}
		}	
	}
	public void show()
	{
		Node cur=head;
		while(cur != null)
	 	{ System.out.println("cur.data=" + cur.data); cur=cur.next;}
	}
}

public class FixSortedLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test1()
    {
        SLL s1 = new SLL();
        s1.append(1);
        s1.append(2);
        s1.append(4);
        s1.append(3);
        s1.append(5);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test2()
    {
        SLL s1 = new SLL();
        s1.append(3);
        s1.append(2);
        s1.append(1);
        s1.append(4);
        s1.append(5);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test3()
    {
        SLL s1 = new SLL();
        s1.append(3);
        s1.append(2);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test4()
    {
        SLL s1 = new SLL();
        s1.append(3);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test5()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MIN_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test6()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MAX_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test7()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MAX_VALUE);
        s1.append(Integer.MIN_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    // Fix reversed sublist in a single linkedlist
    // Input: 1->2->3->5->4->6  (5->4) reverse
    // output:1->2->3->4->5->6
    public static void Fix(Node head)
    {
        Stack<Integer> stack = new Stack<Integer>();
        Node curr = head;

        Node minNode = new Node(Integer.MIN_VALUE);
        minNode.next = curr;
        curr = head = minNode;
        while(curr != null && curr.next != null)
        {
            curr = curr.next; 
        }
        Node prev = curr;
        curr.next = new Node(Integer.MAX_VALUE);
        Node start = null;
        curr = head;
        while(curr != null)
        {
            Node next = curr.next;
            if(next != null)
            {
                if(curr.data > next.data)
                {
                    stack.push(curr.data);
                    if(start == null)
                        start = curr;
                }
                else if(start != null)
                {
                    stack.push(curr.data);
                    break;
                }
            }
            curr = next;
        }
        while(start != null && !stack.empty())
        {
            start.data = stack.pop();
            System.out.println("start.data["+start.data+"]");
            start = start.next;
        }
        head = head.next;
        prev.next = null;

    }

    public static void show(Node head)
    {
        Node curr = head;
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }

}
import classfile.*;

public class FlapBST {
    public static void main(String[] args) {
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(20);
        bst.insert(1);
        //Aron.binImage(bst.root);
        Aron.inorder(bst.root);
        flap(bst.root);
        Ut.l();
        Aron.inorder(bst.root);
        Aron.binImage(bst.root);
        
    }
    public static void flap(Node root) {
        if(root != null) {
            flap(root.left);
            flap(root.right);
            Node tmp = root.left;
            root.left = root.right;
            root.right = tmp;
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class FormatExample{
    public static void main (String[] args)
	{
		String sendID = "AABB";
        String output = String.format("%0"+(10-sendID.length())+"d%s", 0, sendID);
        System.out.println(output);
	}
} 

import java.util.ArrayList;
import java.util.List;
import java.util.function.Function;

class Student {
    public String name;
    public int age;
    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }
    public  String customShow(Function<Student,String> fun){
        return fun.apply(this);
    }
} 

class Operator{
    Integer num1;
    Integer num2;
    public Operator(Integer num1, Integer num2){
        this.num1 = num1;
        this.num2 = num2;
    }
    public Integer ope(Function<Operator, Integer> fun){
        return fun.apply(this);
    }
}

class MyClass implements Function<Integer, String>{
    public String apply(Integer n){
        System.out.println("call apply()");
        return "str:" + n.toString();
    }
}


public class FunctionDemo {
    public static void main(String[] args) {
        List<Student> list = new ArrayList();
        list.add(new Student("Ram",20));
        list.add(new Student("Shyam",22));
        list.add(new Student("Kabir",18));
        
        // Simple use of function
        for(Student st: list){
            System.out.println(st.customShow(s->s.name+": "+s.name));
        }
        
        //Style one to declare function 
        Function<Student,String> styleOne = s->{
            String result =  "Name:"+s.name +" and Age:"+s.age;
            return result;
        };
        
        //Style two to declare function
        Function<Student,String> styleTwo = s->        
            "Name:"+s.name +" and Age:"+s.age;
        
        System.out.println("--print value by style one--");
        //print the values of list using stle one function
        for(Student st: list){
            System.out.println(st.customShow(styleOne));
        }
        
        System.out.println("--print value by style two--");
        //print the values of list using style two function
        for(Student st: list){
            System.out.println(st.customShow(styleTwo));
        }

        //-------------------------------------------------------------------------------- 
        Operator myop = new Operator(1, 2);
        Function<Operator, Integer>  p1 = s -> s.num1 + s.num2;
        Function<Operator, Integer>  p2 = s -> s.num1 - s.num2;
        System.out.println(myop.ope(p1));
        System.out.println(myop.ope(p2));
        //-------------------------------------------------------------------------------- 
        System.out.println(new MyClass());

        MyClass c = new MyClass();
        System.out.println(c.apply(100));

    }
} 
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
    public Node getRoot()
	{ return root;}
}
class GeneBinaryTree
{
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(15);
		b1.Insert(12);
		
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		b1.Insert(20);
		b1.Insert(18);

		Node r = b1.getRoot();

		System.out.println("digraph G{");
        int level = 0;
        Inorder(r, level);
		System.out.println("}");
	}
    	
	public static void Inorder(Node root, int level) {
		if(root != null) {
			//System.out.println("" + root.data + "[label=" + root.data +"];");
			System.out.println(root.data);
            if(root.left != null){
			    System.out.print("" + root.data + "->");
            }
			Inorder(root.left, level+1);

            if(root.right != null){
			    System.out.print("" + root.data + "->");
            }
			Inorder(root.right, level+1);
		}
	}
}
import java.util.ArrayList;
import java.util.List;
class Node
{
    Map<String, Node> map = new HashMap<String, Node>();
}

class Tree
{
    Node root;
    public Tree()
    {
    }
}

public class GeneralTree 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class GenerateNumberFile{
    public static void main(String[] args) {
        test0();
    }
    public static void test0(){
        Aron.beg();

        String fName = "/Users/cat/myfile/github/java/text/random.txt";
        List<Integer> list = Aron.random(1000);
        List<String> slist = new ArrayList<String>(); 
        for(Integer n : list)
            slist.add(n + " ");

        Aron.writeFile(fName, slist);

        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

/**
* Generate Java simple template code
*/ 
public class GenerateProgram{
    final static String fName = "/Users/cat/myfile/github/java/text/program.txt";
    public static void main(String[] args) {
        printInfo();
        Print.p("Argument len=" + args.length);

        for(String s : args){
            Print.p("args:" + s);
        }
        if(args.length > 0)
            generateCode(args[0]);
        else
            Print.p("No Class Name is provided");
    }

    public static void printInfo(){
        Print.pb(fName);
    }
    /**
    * Generate Java file from a class name(e.g. MyClass => MyClass.java)
    */ 
    public static void generateCode(String pName){
        Aron.beg();
        List<String> list = Aron.readFile(fName);

        for(int i=0; i<list.size(); i++){ 
            String s = list.get(i);
            String newStr  = s.replace("Program", pName);
            Print.p(newStr);
            list.set(i, newStr);
        }
        Aron.line();

        List<String> list2 = new ArrayList<String>(); 
        for(int i=0; i<list.size(); i++){ 
            String s = list.get(i);
            Print.p(s);
            list2.add(s + "\n");
        }

        String newName = "/Users/cat/myfile/github/java/" + pName + ".java";
        Aron.writeFile(newName, list2);

        Aron.end();
    }
} 
import java.io.*;
import java.lang.String;
import java.util.*;
import java.lang.reflect.*;

import classfile.*;

// get all methods, all method, method signature
public class GetAllMethods{
    public static void main(String[] args) {
        //Method method = Test.getClass().getMethod();
        //Parameter para = new CachingParameter();

//        Class<String> clz = String.class;
//        for (Method m : clz.getDeclaredMethods()) {
//           System.err.println(m.getName());
//           for (Parameter p : m.getParameters()) {
//              System.err.println("  " + p.getName());
//           }
//        }

        Class<GetAllMethods> clz = GetAllMethods.class;
        for (Method m : clz.getDeclaredMethods()) {
           System.err.println(m.getName());
           for (Parameter p : m.getParameters()) {
              System.err.println("  " + p.getName());
           }
        }

        for(Method m : GetAllMethods.class.getMethods()) {
            Class<?>[] parameterTypes = m.getParameterTypes();
            for(Class<?> t : parameterTypes){
              System.out.println("type:" + t.getName());
            }
            Class<?> returnType = m.getReturnType();
            // funny stuff goes here
        }
    }
    static void print(String str1, int num){
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.io.*;
class GetCurrentPath 
{
	public static void main(String args[])
	{
					File currentPath = new File(new File(".").getAbsolutePath());
					System.out.println("absoluatepath="+currentPath.getAbsolutePath());
					try{
					System.out.println("canonicalpath="+currentPath.getCanonicalPath());
					}catch(IOException e)
					{
					}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.lang.reflect.*;

class GetMethod{
    public void foo() { }
    public String baz() {
        return "";
    }
    //[ file=getmethod.html title=""
    public static void main(String args[]) {
        try {
            Class c = GetMethod.class;
            Method[] m = c.getDeclaredMethods();
            for (int i = 0; i < m.length; i++)
                System.out.println(m[i].toString());
        } catch (Throwable e) {
            System.err.println(e);
        }
    }
    //]
}

import java.io.*;
import java.util.*;
class GivenSumPair 
{
	public static void main(String args[])
	{
		int[] Arr = {7, 5, 6, 7, -10, 1};
		Pair(Arr, -9);

	}

	public static void Pair(int[] Arr, int sum)
	{
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		
		for(int i=0; i<Arr.length; i++)
		{
			if(map.containsKey(new Integer(Arr[i])))
			{
				Integer v = map.get(new Integer(Arr[i]));
				int n = v.intValue(); n++;
				map.put(new Integer(Arr[i]), new Integer(n));
			}
			else
			{
				map.put(new Integer(Arr[i]), new Integer(1));
			}
		}

		for(int i=0; i<Arr.length; i++)
		{
			int diff = sum - Arr[i];
			if(map.containsKey(new Integer(diff)))
			{
				Integer v = map.get(new Integer(diff));
				int n = v.intValue();
				if(n > 0)
				{ System.out.println(diff + " " + Arr[i]);
					n--;
					map.put(new Integer(diff), new Integer(n));
				}
				Integer v1 = map.get(new Integer(Arr[i]));
				int n1 = v1.intValue();
				if(n1 > 0)
				{ n1--;
					map.put(new Integer(Arr[i]), new Integer(n1));
				}
			}
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class GraphLoopPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }
    static void test0(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);
        map.put(n2, n1);

        System.out.println("n1, n4=[" + isAPath(n1, n4, map, set) + "]"); 
        System.out.println("n2, n3=[" + isAPath(n2, n3, map, set) + "]"); 
        System.out.println("n1, n2=[" + isAPath(n1, n2, map, set) + "]"); 

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);
        map.put(n2, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);

        map.put(n1, n2);
        map.put(n2, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);

        n2.next = n3;

        map.put(n1, n2);
        map.put(n3, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        System.out.println("True[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 1;
        System.out.println("True[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test7(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 1;
        int destination = 2;
        System.out.println("False[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test8(){
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        List<Integer> list = new ArrayList<Integer>(); 

        int[][] arr2d = {
            {0, 2, 7, 0},
            {0, 0, 0, 4},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        int min = Integer.MAX_VALUE;
        System.out.println("min path[" + minPathMatrix(source, destination, list, min, arr2d, height, width) + "]"); 

        Aron.end();
    }
    static void test9(){
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        List<Integer> list = new ArrayList<Integer>(); 

        int[][] arr2d = {
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},

            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
        }; 

        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        int min = Integer.MAX_VALUE;
        System.out.println("min path[" + minPathMatrix(source, destination, list, min, arr2d, height, width) + "]"); 

        Aron.end();
    }

    //[ file=pathloop.html title=""
    //1, 1
    //
    //1, 4 
    //<1, 2->3>
    //<2, 4>
    //<3, 4>
    //<2, 1>
    //              1 
    //         2        3     
    //              4
    static boolean isAPath(Node sNode, Node dNode, Map<Node, Node> map, Set<Node> set){
        if(sNode != null && dNode != null){
            if(set.contains(sNode)){
                return false;
            }else{
                set.add(sNode);
            }
            if(sNode.data == dNode.data)
                return true;
            else{
                Node curr = map.get(sNode);
                while(curr != null){
                    if(curr.data == dNode.data){
                        return true;
                    }else{
                        return isAPath(curr.next, dNode, map, set);
                    }
                }
            }
        }
        return false;
    }

    static boolean isLoop(Node curr, Map<Node, Node> map, Set<Node> set){
        if(curr != null){
            if(set.contains(curr)){
                return true;
            }else{
                set.add(curr);
                Node child = map.get(curr);
                while(child != null){
                    if(isLoop(child, map, set))
                        return true; 
                    child = child.next;
                }
                set.remove(curr);
            }
        }
        return false;
    }

    static boolean isPathMatrix(int s, int d, int[][] arr, int height, int width){
        if(arr != null && s < height){
            if(s == d)
                return true;
            else{
                for(int i=0; i< width; i++){
                    if(arr[s][i] == 1){
                        return isPathMatrix(i, d, arr, height, width); 
                    }
                }
            }
        }
        return false;
    }

    static int maxSumBin(Node root, int sum, int max){
        if(root != null){
            if(root.left == null && root.right == null){
                return Math.max(sum + root.data, max);
            }else{
                int lmax = maxSumBin(root.left, sum + root.data);
                int rmax = maxSumBin(root.right, sum + root.data);

                return Math.max(lmin, rmin);
            }
        }
        return 0;
    }

    static int maxSumBin2(Node root){
        if(root != null){
            return Math.max(maxSumBin2(root.left), maxSumBin2(root.right)) + root.data;
        }
        return 0;
    }

    static int minPathMatrix(int s, int d, List<Integer> list, int min, int[][] arr, int height, int width){
        if(arr != null && s < height){
            if(s == d){
                int sum = 0;
                for(Integer n : list)
                    sum += n;
                min = Math.min(sum, min);
            }
            else{
                for(int i=0; i< width; i++){
                    if(arr[s][i] > 0){
                        list.add(arr[s][i]);
                        min = minPathMatrix(i, d, list, min, arr, height, width); 

                        if(list.size() > 0)
                            list.remove(list.size()-1);
                    }

                }
            }
        }
        return min;
    }
    //]
} 
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class Guassian2{
    public static void main(String[] args) {
        test0();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class GuassianElimination{
    public static void main(String[] args) {
//        test0();
//        test2();
//        test3();
//        test5();
//        test6();
//        upperTriangle_test();
//        GEReduce_test();
//        lowerTriangle_test();
//        inverse_test2();
//          solveEquation_test();
          //upperTriangle_test2();
          //upperTriangle_test3();
//          upperTriangle_test4();
//          upperTriangle_test5();
//          upperTriangle_test6();
//          upperTriangle_test7();
//          upperTriangle_test8();
//          upperTriangle_test9();

//        inverse_test();
//        inverse_test1();
//        inverse_test2();
        inverse_test3();
    }
    public static void test0(){
        Aron.beg();
        double[][] arr = new double[][] {
        {1, 2, 3, 1},
        {4, 5, 6, 2},
        {7, 8, 10, 5},
        };

        double[] vec = new double[] {0, 0, 0};
        double[] A = new double[] {1, 2, 5};
        Aron.printArray2D(arr);

        int len = arr[0].length;
        int h = arr.length;
        for(int i=0; i<h-1; i++){
            for(int n=1; n+i<h; n++){
            double m00 = arr[i][i];
            double m10 = arr[i+n][i];
            for(int j=i; j<len; j++){
                arr[i][j] = arr[i][j]*m10;
                arr[n+i][j] = arr[n+i][j]*m00;
                arr[n+i][j] = arr[i][j] - arr[n+i][j];
            }
            }
        }
        
        Print.p("h=" + h);
        for(int i=0; i<h; i++){
            double sum = 0;
            for(int j=0; j<i+1; j++){
                // div the a[k][k], (assume the matrix is invertable. Thereforce, {a[k][k] != 0, k=1...n})
                if(h-1-i == h-1-j){
                    vec[h-1-i] = (arr[h-1-i][h] - sum)/arr[h-1-i][h-1-j];
                    Print.p("arr[" + (h-1-i) + "][" + (h-i) + "]=" + arr[h-1-i][h]);
                    Print.p("vec[" + (h-1-i) + "]" + vec[h-1-i]);
                }else{
                    sum += arr[h-1-i][h-1-j]*vec[h-1-j];
                    Print.p("->vec[" + (h-1-j) + "]" + vec[h-1-j]);
                    Print.p("sum=" + sum);
                }
            }
            Print.p();
        }

        Aron.printArray2D(arr);
        
        Aron.end();
    }
    public static double[] backwardSubstitution(double[][] arr){
        int h = arr.length;
        int w = arr[0].length;
        double[] vec = new double[h];
        for(int i=0; i<h; i++){
            double sum = 0;
            for(int j=0; j<i+1; j++){
                // div the a[k][k], (assume the matrix is invertable. Thereforce, {a[k][k] != 0, k=1..n})
                if(h-1-i == h-1-j){
                    vec[h-1-i] = (arr[h-1-i][h] - sum)/arr[h-1-i][h-1-j];
                }else{
                    sum += arr[h-1-i][h-1-j]*vec[h-1-j];
                }
            }
            Print.p();
        }
        return vec;
    }

    // convert long[][] to double[][]
    public static double[][] convertlongTodouble(long[][] arr){
        int row = arr.length;
        int col = arr[0].length;
        double[][] m = new double[row][col];
        for(int r=0; r < row; r++){
            for(int c=0; c< col; c++){
                m[r][c] = (double)arr[r][c];    
            }
        }
        return m;
    }
//    public static void lowerTriangle(long [][] m){
//        if(m != null){
//            int len = m.length;
//            int wid = m[0].length;
//            for(int k=len-1; k>=0; k--){
//                for(int i=k-1; i >= 0; i--){
//                    long m00 = m[k][k];
//                    long m10 = m[i][k];
//                    if(m10 != 0 && m00 != 0){
//                        for(int j=k; j >=0; j--){
//                            m[k][j] = m[k][j]*m10;
//                            m[i][j] = m[i][j]*m00;
//                            m[i][j] = m[k][j] - m[i][j];
//                        }
//
//                        Print.p(m);
//                        long gcdk = Aron.gcdList(m[k]);
//                        long gcdi = Aron.gcdList(m[i]);
//                        Print.p("gcdk=" + gcdk);
//                        Print.p("gcdi=" + gcdi);
//                        if(gcdk != 0 && gcdi != 0){
//                            for(int j=k; j>=0; j--){
//                                m[k][j] = m[k][j]/gcdk;
//                                m[i][j] = m[i][j]/gcdi;
//                            }
//                        }else{
//                            if(gcdk != 0){
//                                for(int j=k; j>=0; j--)
//                                    m[k][j] = m[k][j]/gcdk;
//                            }
//                            if(gcdi != 0){
//                                for(int j=k; j>=0; j--)
//                                    m[i][j] = m[i][j]/gcdi;
//                            }
//                        }
//                        Print.p(m);
//                    }
//                }
//            }
//        }
//    }
    
    // if mat is invertable, return the inverse
    // return null otherwise
    public static double[][] inverse(long [][] mat){
       double[][] mm = null;
       if (Aron.isValidMatrix(mat)){
           int w = mat.length;
           long[][] id = Aron.geneIdentitylong(w);
           long[][] m = Aron.concatMatrix(mat, id);
           upperTriangle(m);
           lowerTriangle(m);
           int nrow = m.length;
           int ncol = m[0].length;
           mm = new double[nrow][ncol/2];
           for(int i=0; i<nrow; i++){
               if(m[i][i] != 0){
                   for(int j=0; j<ncol/2; j++)
                       mm[i][j] = (double)m[i][ncol/2 + j]/m[i][i];
               }else{
                   return null;
               }
           }
       }
       return mm;
       
    }

    /**
    *  Solve system equaton
    *  1x + 2y = 1 
    *  3x + 5y = 2 
    *  Form argumented matrix =>
    *  [1, 2, 1]
    *  [3, 5, 2]
    *  Guassian Elimination  =>
    *  [x, x, x]
    *  [0, x, x]
    *  Backward substitution =>
    *  x= c1
    *  y= c2
    */
    public static double[] solveEquation(long[][] m){
        upperTriangle(m);
        double[][] arr = convertlongTodouble(m);
        double[] vec = backwardSubstitution(arr);
        return vec;
    }
    public static void lowerTriangle(long [][] m){
        if(m != null){
            int len = m.length;
            int wid = m[0].length;
            for(int k=len-1; k>=0; k--){
                for(int i=k-1; i >= 0; i--){
                    long m00 = m[k][k];
                    long m10 = m[i][k];
                    if(m10 != 0 && m00 != 0){
                        for(int j=wid-1; j >=0; j--){
                            m[k][j] = m[k][j]*m10;
                            m[i][j] = m[i][j]*m00;
                            m[i][j] = m[k][j] - m[i][j];
                        }

                        //Print.p(m);
                        long gcdk = Aron.gcdList(m[k]);
                        long gcdi = Aron.gcdList(m[i]);
                        if(gcdk != 0 && gcdi != 0){
                            for(int j=wid-1; j>=0; j--){
                                m[k][j] = m[k][j]/gcdk;
                                m[i][j] = m[i][j]/gcdi;
                            }
                        }else{
                            if(gcdk != 0){
                                for(int j=wid-1; j>=0; j--)
                                    m[k][j] = m[k][j]/gcdk;
                            }
                            if(gcdi != 0){
                                for(int j=wid-1; j>=0; j--)
                                    m[i][j] = m[i][j]/gcdi;
                            }
                        }
                        //Print.p(m);
                    }
                }
            }
        }
    }
    public static void GEReduce(long [][] m){
        if(m != null){
            int len = m.length;
            int w = m[0].length;
            for(int k=0; k<len-1; k++){
                for(int i=k+1; i < len; i++){
                    long m00 = m[k][k];
                    long m10 = m[i][k];
                    if(m10 != 0 && m00 != 0){
                        for(int j=k; j < w; j++){
                            m[k][j] = m[k][j]*m10;
                            m[i][j] = m[i][j]*m00;
                            m[i][j] = m[k][j] - m[i][j];
                        }

                        long gcdk = Aron.gcdList(m[k]);
                        long gcdi = Aron.gcdList(m[i]);
                        if(gcdk != 0 && gcdi != 0){
                            for(int j=k; j<w; j++){
                                m[k][j] = m[k][j]/gcdk;
                                m[i][j] = m[i][j]/gcdi;
                            }
                        }else{
                            if(gcdk != 0){
                                for(int j=k; j<w; j++)
                                    m[k][j] = m[k][j]/gcdk;
                            }
                            if(gcdi != 0){
                                for(int j=k; j<w; j++)
                                    m[i][j] = m[i][j]/gcdi;
                            }
                        }
                    }
                }
            }
        }
    }
    public static void upperTriangle(long [][] m){
        if(Aron.isValidMatrix(m)){
            int len = m.length;
            int w = m[0].length;
            for(int k=0; k<len-1; k++){
                for(int i=k+1; i < len; i++){
                    long m00 = m[k][k];
                    long m10 = m[i][k];
                    if(m10 != 0 && m00 != 0){
                        for(int j=k; j < w; j++){
                            m[k][j] = m[k][j]*m10;
                            m[i][j] = m[i][j]*m00;
                            m[i][j] = m[k][j] - m[i][j];
                        }

                        long gcdk = Aron.gcdList(m[k]);
                        long gcdi = Aron.gcdList(m[i]);
                        if(gcdk != 0 && gcdi != 0){
                            for(int j=k; j<w; j++){
                                m[k][j] = m[k][j]/gcdk;
                                m[i][j] = m[i][j]/gcdi;
                            }
                        }else{
                            if(gcdk != 0){
                                for(int j=k; j<w; j++)
                                    m[k][j] = m[k][j]/gcdk;
                            }
                            if(gcdi != 0){
                                for(int j=k; j<w; j++)
                                    m[i][j] = m[i][j]/gcdi;
                            }
                        }
                    }
                }
            }
        }
    }
    public static void upperTriangle_test8(){
        Aron.beg();
        long[][] m = {
            {2},
        };
        upperTriangle(m);
        Print.p(m);
        long[][] expected = {
                             {2},
                            };
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test9(){
        Aron.beg();
        long[][] m = {
            {0},
        };
        upperTriangle(m);
        Print.p(m);
        long[][] expected = {
                             {0},
                            };
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test2(){
        Aron.beg();
        long[][] m = {
            { 1,   2,   3, 1},
            { 4,   5,   6, 2},
            { 7,   8,   10, 5},
        };
        upperTriangle(m);
        Print.p(m);
        long[][] expected = {
                            {1, 2, 3, 1},
                            {0, 3, 6, 2},
                            {0, 0, 1, 2},
                            };
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test3(){
        Aron.beg();
        long[][] m = {
            { 1,   2,   3},
            { 4,   5,   6},
            { 7,   8,   10},
        };
        upperTriangle(m);
        Print.p(m);
        long[][] expected = {
                            {1, 2, 3},
                            {0, 1, 2},
                            {0, 0, 1},
                            };
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test4(){
        Aron.beg();
        long[][] m = Aron.geneIdentitylong(3); 
        upperTriangle(m);
        Print.p(m);
        long[][] expected = Aron.geneIdentitylong(3); 
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test5(){
        Aron.beg();
        long[][] m = Aron.geneMatrixZerolong(3); 
        upperTriangle(m);
        Print.p(m);
        long[][] expected = Aron.geneMatrixZerolong(3); 
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test6(){
        Aron.beg();
        long[][] m = Aron.geneMatrixZerolong(2); 
        upperTriangle(m);
        Print.p(m);
        long[][] expected = Aron.geneMatrixZerolong(2); 
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void upperTriangle_test7(){
        Aron.beg();
        long[][] m = Aron.geneMatrixZerolong(1); 
        upperTriangle(m);
        Print.p(m);
        long[][] expected = Aron.geneMatrixZerolong(1); 
        Aron.writeFileJavaList("/tmp/xx.x", m);
        Test.t(expected, m);
        Aron.end();
    }
    public static void inverse_test(){
        Aron.beg();
        long [][] m = {
            {1, 2, 3 },
            {4, 5, 6 },
            {7, 8, 10},
        };
        Print.p(m);
        double[][] mm = inverse(m);
        Print.p(mm, 6);
        Aron.end();
    }
    public static void inverse_test1(){
        Aron.beg();
        long [][] m = {
            {1, 2, 3 , 3},
            {4, 5, 6 , 9},
            {7, 8, 10, 21},
            {17, 48, 9, 4},
        };
        String f1 = "/tmp/x1.x";
        String f2 = "/tmp/x2.x";
        Print.p(m);
        Aron.writeFileHaskellList(f1, m);
        double[][] mm = inverse(m);
        Print.p(mm, 6);
        Aron.writeFileHaskellList(f2, mm);
        Aron.end();
    }

    public static void inverse_test2(){
        Aron.beg();
        int nrow = 10;
        int start = 10;
        long [][] m = Aron.geneMatrixlong(10, nrow); 
        Print.p(m);
        double[][] mm = inverse(m);
        Print.p(mm, 5);
        Aron.end();
    }
    public static void inverse_test3(){
        Aron.beg();
        long [][] m = {
            {1, 3, 7},
            {2, 4, 8},
            {3, 5, 10},
        };
        Print.p(m);
        double[][] mm = inverse(m);
        if(mm != null)
            Print.p(mm, 6);
        Aron.end();
    }
    public static void inverse_test3(){
        Aron.beg();
        long [][] m = {
            {1, 2, 3},
            {2, 3, 4},
            {3, 4, 5},
        };
        Print.p(m);
        double[][] nn = inverse(m);
        Test.t(nn == null);
        Print.p(nn);
        Aron.end();
    }
    public static void lowerTriangle_test(){
        Aron.beg();
        long [][] m = {
            {1, 2, 3,  1, 0, 0},
            {4, 5, 6,  0, 1, 0},
            {7, 8, 10, 0, 0, 1},
        };
        Print.p(m);
        lowerTriangle(m);
        Print.p(m);
        Aron.end();
    }
    public static void upperTriangle_test11(){
        Aron.beg();
        long[][] m = {
            { 1,   2,   3, 1},
            { 4,   5,   6, 2},
            { 7,   8,   10, 5},
        };
        upperTriangle(m);
        double[][] arr = convertlongTodouble(m);
        Aron.printArray2D(arr);
        double[] vec = backwardSubstitution(arr);
        Aron.end();
    }

    public static void test2(){
        Aron.beg();
        int start = 7;
        int r = 6;
        long[][] m = Aron.geneMatrixlong(start, r, r);
        Aron.printArray2D(m);
        upperTriangle(m);
        Aron.printArray2D(m);
        Aron.end();
    }
    public static void upperTriangle_test(){
        Aron.beg();
        int max = 10;
        int r = 4; 
        //long [][] m = Aron.geneMatrixRandomIntervalLong(1, max, r);
        long [][] m = {
            {1, 2, 3,  1, 0, 0},
            {4, 5, 6,  0, 1, 0},
            {7, 8, 10, 0, 0, 1},
        };
        Aron.printArray2D(m);
        upperTriangle(m);
        Aron.printArray2D(m);
        Aron.end();
    }
    public static void GEReduce_test(){
        Aron.beg();
        int max = 10;
        int r = 4; 
        //long [][] m = Aron.geneMatrixRandomIntervalLong(1, max, r);
        long [][] m = {
            {1, 2, 3,  1, 0, 0},
            {4, 5, 6,  0, 1, 0},
            {7, 8, 10, 0, 0, 1},
        };
        Aron.printArray2D(m);
        GEReduce(m);
        Aron.printArray2D(m);
        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        int max = 10;
        int r = 17; 
        long [][] m = Aron.geneMatrixRandomIntervalLong(1, max, r);
        Aron.printArray2D(m);
        upperTriangle(m);
        Aron.printArray2D(m);
        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        int max = 10;
        int r = 10; 
        long [][] m = Aron.geneMatrixRandomIntervalLong(1, max, r, r+1);
        upperTriangle(m);
        Aron.printArray2D(m);
        double[][] arr = convertlongTodouble(m);
        Aron.printArray2D(arr);
        double[] vec = backwardSubstitution(arr);
        Aron.printArray2D(arr);

        Aron.end();
    }
    public static void solveEquation_test(){
        Aron.beg();
        long[][] m = {
            { 1,   2,   3, 1},
            { 4,   5,   6, 2},
            { 7,   8,   10, 5},
        };
        Aron.printArray2D(m);
        double[] vec = solveEquation(m);
        Print.p(vec);
        Aron.end();
    }
} 

interface HashMapInterface
{
    Object put(Object key, Object value);
    Object get(Object key);
    Object remove(Object key);
}

class Node
{
    Object key;
    Object value;
    Node next;
    public Node(Object key, Object value)
    {
        this.next = null;
        this.key = key;
        this.value= value;
    }
}
class HashMapClass implements HashMapInterface
{
    Node[] nodeArray;
    int size;
    public HashMapClass(int size)
    {
        this.size = size;
        nodeArray = new Node[size];
    }
    public Object put(Object key, Object value)
    {
        boolean done = false;
        Object ret = null;
        Node curr = nodeArray[key.hashCode() % this.size];
        while(curr != null && !done)
        {
            if(key != curr.key)
            {
                curr = curr.next;
            }
            else
            {
                ret = curr.value;
                done = true;
            }
        }
        return ret;
    }
    public Object get(Object key)
    {
        Object ret = null;
        if(key != null)
        {
            boolean done = false;
            Node curr = nodeArray[key.hashCode() % this.size];
            while(curr != null && !done)
            {
                if(key != curr.key)
                {
                    curr = curr.next;
                }
                else
                {
                    ret = curr.value;
                    done = true;
                }
            }
        }
        return ret;
    }
    public Object remove(Object key)
    {
        Object ret = null;
        if(key != null)
        {
            boolean done = false;
            Node curr = nodeArray[key.hashCode() % this.size];
            Node prev = curr;
            while(curr != null && !done)
            {
                if(key != curr.key)
                {
                    prev = curr;
                    curr = curr.next;
                }
                else
                {
                    ret = curr.value;
                    if(prev == curr)
                    {
                        prev = curr = null;
                    }
                    else
                    {
                        prev.next = curr.next;
                        done = true;
                    }
                }
            }
        }
        return ret;
    }
}

public class HashMapImple 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class HashMapIterate  
{
	public static void main(String args[])
	{
		Map<String, String> hashmap = new HashMap<String, String>();
		hashmap.put("key0", "str0");	
		hashmap.put("key1", "str1");	
		hashmap.put("key2", "str2");	
		hashmap.put("key3", "str3");	

		for(String key : hashmap.keySet())
		{
			String value = hashmap.get(key);
			System.out.println("hashmap["+key+","+value+"]");	
		}
	}
}
public class Haversine {
    public static final double R = 6372.8; // In kilometers
    public static double haversine(double lat1, double lon1, double lat2, double lon2) {
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        lat1 = Math.toRadians(lat1);
        lat2 = Math.toRadians(lat2);
 
        double a = Math.pow(Math.sin(dLat / 2),2) + Math.pow(Math.sin(dLon / 2),2) * Math.cos(lat1) * Math.cos(lat2);
        double c = 2 * Math.asin(Math.sqrt(a));
        return R * c;
    }
    public static void main(String[] args) {
        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

class Interval implements Comparable<Interval> {
    public int begin;
    public int end;
    public Interval(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter) {
        if(this.begin > inter.begin)
            return 1;
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString() {
        return "[" + begin + " " + end + "]";
    }
}

public class Hello {
    public static void main(String[] args) {
        test0();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test00();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    static void test00() {
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};

        for(int i=0; i<arr1.length; i++) {
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0) {
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()) {
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else {
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()) {
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }

        Aron.end();
    }

    static void test0() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(5);
        sll.append(4);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = cloneLinkedList(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test2() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test3() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test4() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test5() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test6() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test7() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseLinkedList(sll.head);
        Aron.printSLL(nhead);

        Aron.end();
    }

    static void test8() {
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseIte(sll.head);
        Aron.printSLL(nhead);
        Aron.end();
    }

    static void test9() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        SingleLinkedList sll2 = new SingleLinkedList();
        sll2.append(1);
        sll2.append(2);
        sll2.append(3);


        Node curr = sll.head;
        Node head = sll.head;

        while(curr != null && curr.next != null) {
            curr = curr.next;
        }
        curr.next = head;

        boolean circular = isCircular(sll.head);
        System.out.println("isCircular[" + circular + "]");

        boolean circular2 = isCircular(sll2.head);
        System.out.println("isCircular2[" + circular2 + "]");

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str = "";
        System.out.println("empty str " + str + "[" + isBalance(str) + "]");

        str = "()";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "([)]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "()([])";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        Aron.end();
    }
    
    static void test11(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        h = insertNodeToSortedList(ssl.head, 5);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test13(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node newHead = insertNodeToSortedList(ssl.head, 15);
        Aron.printSLL(newHead);
        Aron.end();
    }

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=nextnext.html title=""
    public static Node reverseIte(Node curr) {
        Node prev = null;
        Node next = null;
        while(curr != null) {
            next = curr.next;
            curr.next = prev;

            prev = curr;
            curr = next;
        }
        return prev;
    }

    public static Node reverseLinkedList(Node curr) {
        if(curr == null || curr.next == null)
            return curr;

        Node head = reverseLinkedList(curr.next);
        curr.next.next = curr;
        curr.next = null;

        return head;
    }

    public static Node reversePair(Node head) {
        Node curr = head;
        while(curr != null && curr.next != null) {
            int tmp = curr.data;
            curr.data = curr.next.data;
            curr.next.data = tmp;

            curr = curr.next.next;
        }
        return head;
    }

    public static boolean isCircular(Node curr) {
        if(curr == null)
            return false;
        else {
            Node next = curr.next;
            if(curr == next)
                return true;

            while(next != null) {
                if(curr == next)
                    return true;

                curr = curr.next;

                next = next.next;
                if(next != null)
                    next = next.next;
            }
        }
        return false;
    }
    //]


    static Node cloneLinkedList(Node head) {
        Node newHead = null;
        Node newCurr = null;
        Node curr = head;

        if(curr != null) {
            newCurr = newHead = new Node(head.data);

            while(curr.next != null) {
                newCurr.next = new Node(curr.next.data);
                newCurr = newCurr.next;
                curr = curr.next;
            }
        }
        return newHead;
    }

//    static boolean isBal(String str, int index){
//        if(str != null && index < str.length()){
//            if(!isBal(str, index + 1))
//                return false;
//
//            if(str.charAt(index) == '(' || str.charAt(index) == '[')
//                return isBal(str, index + 1);
//            else
//                return false;
//
//            else if(str.charAt(index) == ')'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '(') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }else if(str.charAt(index) == ']'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '[') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }
//        }
//        return true;
//    }

    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }

    static Node insertNodeToSortedList(Node head, int num){
       Node curr = head; 
       Node prev = null;

       while(curr != null){
           if(curr.data < num){
               prev = curr;
               if(curr.next == null){
                   prev.next = new Node(num);
                   return head;
               }
           }else{
               if(prev != null){
                   prev.next = new Node(num);
                   prev.next.next = curr;
                   return head;
               }else{
                   // first node
                   Node node = new Node(num);
                   node.next = curr;
                   head = node;
                   return head;
               }
           }
           curr = curr.next;
       }
       return head;

    }

    static boolean isBalance(String str) {
        Stack<String> stack = new Stack<String>();
        if(str != null) {
            for(int i=0; i<str.length(); i++) {
                String s = str.charAt(i) + "";
                if(s.equals("(") || s.equals("[")) {
                    stack.push(s);
                } else {
                    if(s.equals(")")) {
                    if(!stack.empty() && stack.peek().equals("(")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else if(s.equals("]")) {
                    if(!stack.empty() && stack.peek().equals("[")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else {
                        System.out.println("Error");
                        return false;
                    }

                }
            }
        }
        return stack.empty();
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.List;
import java.util.*;
import java.lang.Math;
import java.io.*;

import classfile.*;

class MyNode{
    public int data;
    public List<MyNode> list;
    public MyNode(int data){
        this.data = data;
        list = new ArrayList<MyNode>();
    }
}

class MyTree{
    public MyNode root;

    public MyTree(){
    }

    public void create(){
        root = new MyNode(1);
        root.list.add(new MyNode(2));
        root.list.add(new MyNode(3));

        MyNode branch = new MyNode(10);
        branch.list.add(new MyNode(11));
        branch.list.add(new MyNode(12));
        root.list.add(branch);

        MyNode branch1 = new MyNode(20);
        branch1.list.add(new MyNode(21));
        branch1.list.add(new MyNode(22));
        root.list.add(branch1);
    }
    public void printTree(MyNode node, int level, BufferedWriter bw){
        //Aron.beg();

        try{
            if(node != null){
                String format;

                if(level == 0)
                    format = "%1$1s";
                else
                    format = "%1$" + (level*10) + "s";

                //System.out.println(String.format(format, "[" + node.data));
                System.out.print(" [ " + node.data + " ");
                bw.write(" [ " + node.data + " ");
                for(MyNode n : node.list){
                    printTree(n, level+1, bw);
                }
                System.out.print(" ] " + " ");
                bw.write(" ] " + " ");
                //System.out.println(String.format(format, "]"));
            }
        }catch(IOException e){
        }

        //Aron.end();
    }
}

public class Hello1{
    public static void main(String[] args){
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
    }
    public static int height(Node root){
        return root == null ? -1 : Math.max(height(root.left), height(root.right)) + 1;
    }

    public static void printTree(MyNode node, int level){
        if(node != null){
            String format;
            if(level == 0)
                format = "%1$1s";
            else
                format = "%1$" + (level*10) + "s";

            System.out.println(String.format(format, "[" + node.data));
            for(MyNode n : node.list){
                printTree(n, level+1);
            }
            System.out.println(String.format(format, "]"));
        }
    }

    public static void test0(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");

        Aron.end();
    }

    public static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(1);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(20);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(20);
        bst.insert(30);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);

        Aron.end();
    }
    
    static void test5(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);
        System.out.println("\n---------------------------------"); 

        Node curr = bst.root;
        while(curr != null){
            System.out.println("[" + curr.data + "]");
            curr = curr.next;
        }

        Aron.end();
    }
    static void test6(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(3);
        bst.insert(7);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);
        System.out.println("\n---------------------------------"); 

        Node curr = bst.root;
        while(curr != null){
            System.out.println("[" + curr.data + "]");
            curr = curr.next;
        }

        Aron.end();
    }

    public static int BinaryTreeLevel(Node root){
        return root == null ? 0 : Math.max(BinaryTreeLevel(root.left), BinaryTreeLevel(root.right)) + 1;
    }

    static Node prev = null;
    public static void printLevel(Node curr, int level){
        if(curr != null){
            if(level == 1 ){
                System.out.println("[" + curr.data + "]");
                if(prev != null){
                    prev.next = curr;
                    prev = curr;
                }else{
                    prev = curr;
                }
            }else{
                printLevel(curr.left, level - 1);
                printLevel(curr.right, level - 1);
            }
        } 
    }
    public static void print(Node curr){
        for(int i = 1; i<= BinaryTreeLevel(curr); i++){
            printLevel(curr, i);
        }
    }
    
    static void test7(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);
        Node n5 = new Node(5);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n5);
        map.put(n5, n4);

        for(Map.Entry<Node, Node> entry: map.entrySet()){
            Node curr = entry.getValue();
            while(curr != null){
                System.out.println("[" + entry.getKey().data + " " + curr.data + "]");
                curr = curr.next;
            }
        }
        List<Node> list = new ArrayList<Node>();
        list.add(n1);
        getAllPaths(n1, map, 4, list);

        Aron.end();
    }
    
    static void test8(){
        Aron.beg();
        int[] arr = {2, -5, 8, -2, 3};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test9(){
        Aron.beg();
        int[] arr = {-1, -5, 8, -4, 5, -2, 3, -2};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test10(){
        Aron.beg();
        int[] arr = {-1, -5, 8};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void test11(){
        Aron.beg();
        int[] arr = {6, -5, 8};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void buildMap(Node r, int key, Map<Integer, Integer> map){
        if(r != null){
            System.out.println("[" + r.data + "][" + key + "]");
            map.put(key, r.data);
            buildMap(r.left, 2*key + 1, map);
            buildMap(r.right, 2*key + 2, map);
        }
    }
    // index = 0
    static Node buildTree(Map<Integer, Integer> map, int index){
        Integer n = map.get(index);
        if(n != null){
            Node root = new Node(n);
            root.left = buildTree(map, 2*index+1);
            root.right = buildTree(map, 2*index+2);
            return root;
        }
        return null;
    }
    static void getAllPaths(Node n, Map<Node, Node> map, int num, List<Node> list){
        if(n.data == num){
            for(Node node : list){
                System.out.println("[" + node.data + "]");
            }
            System.out.println("\n---------------------------------"); 
        }else{
                Node curr = map.get(n);
                while(curr != null){
                    list.add(curr);
                    getAllPaths(curr, map, num, list);

                    if(list.size() > 0)
                        list.remove(list.size()-1);

                    curr = curr.next;
                }
        }
    }
    static int maxList(int[] arr){
        int max = -1;
        int first = 0;
        int second = 0;
        if(arr != null && arr.length > 0){
            max = arr[0];
            int sum = arr[0];
            for(int i=1; i<arr.length; i++){
                    sum += arr[i];
                    System.out.println("sum[" + sum + "]");
                    System.out.println("arr[" + i + "]=" + arr[i]);
                    if(sum < 0){
                        sum = 0;
                        if(i + 1 < arr.length)
                            first = i + 1;
                    }

                    if( max < Math.max(sum, arr[i])){
                        max = Math.max(sum, arr[i]);
                        second = i;
                    }
            }
            System.out.println("f[" + first + "]");
            System.out.println("s[" + second + "]");
        }
        return max;
    }

    static void test12(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 0, 1, 1},
            {1, 0, 1, 1},
            {0, 0, 0, 1},
            {0, 0, 1, 0},
            {0, 1, 1, 0},
        }; 

//[0][0]=0[0][1]=0[0][2]=5[0][3]=0
//[1][0]=1[1][1]=0[1][2]=0[1][3]=0
//[2][0]=0[2][1]=0[2][2]=0[2][3]=0
//[3][0]=0[3][1]=0[3][2]=3[3][3]=0
//[4][0]=0[4][1]=0[4][2]=0[4][3]=0


        int h = 0;
        int w = 0;
        int height = arr2d.length;
        if(height > 0){
            int width = arr2d[0].length;

            System.out.println("h[" + height + "]");
            System.out.println("w[" + width + "]");
            for(int i=0; i< height; i++){
                for(int j=0; j< width; j++){
                    int count = maxCount(arr2d, i, j, height, width);
                    System.out.print("[" + i + "][" + j + "]=" + count);
                }
                System.out.println("");
            } 
            
        }
        
        Aron.end();
    }

    static int maxCount(int[][] arr2d, int h, int w, int height, int width){
        if(arr2d != null){
            if(arr2d[h][w] == 1){
                arr2d[h][w] = 2;
                int n1 = 0;
                int n2 = 0;
                int n3 = 0;
                int n4 = 0;
                if(h + 1 < height)
                    n1 = maxCount(arr2d, h + 1, w, height, width);
                if(h - 1 >= 0)
                    n2 = maxCount(arr2d, h - 1, w, height, width);
                if(w + 1 < width)
                    n3 = maxCount(arr2d, h, w + 1, height, width);
                if(w - 1 >= 0)
                    n4 = maxCount(arr2d, h, w - 1, height, width);

                return n1 + n2 + n3 + n4 + 1;
            }
        }
        return 0;
    }
    
    static void test13(){
        Aron.beg();

        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter("file3.txt"));
            int level = 0; 
            MyTree t = new MyTree();
            t.create();
            t.printTree(t.root, level, bw);

            bw.close();

            BufferedReader br = new BufferedReader(new FileReader("file3.txt"));
            String line;
            while((line = br.readLine()) != null){
                //System.out.println("inside[" + line + "]");
                break;
            }
            System.out.println("\n---------------------------------"); 

            String[] arr = line.split("\\s+");

            List<String> list = new ArrayList<String>(); 
            for(String s : arr){
                System.out.print("<<" + s + ">>"); 
                if(s.trim().length() > 0)
                    list.add(s);
            }

            br.close();
            level = 0;
            MyNode r = null;
            System.out.println("\n buildTree2---------------------------------"); 
            MyNode root = buildTree2(r, list.iterator());

//            System.out.println("\n---------------------------------"); 
//            for(String s : arr){
//                System.out.print("(" + s + ")"); 
//            }
            printTree(root, level);
            System.out.println("\n---------------------------------"); 

        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        Aron.end();
    }

    static MyNode buildTree2(MyNode root, Iterator<String> ite){
        if(ite.hasNext()){
            String token = ite.next();

            if(token.equals("[")){
                if(root == null)
                    return buildTree2(root, ite);
                else{
                    root.list.add(buildTree2(root, ite));
                    return root;
                }
            }else if(token.equals("]")){
            }
            else{
                MyNode nn = new MyNode(Integer.parseInt(token));
                if(root != null){
                    root.list.add(nn);
                    return buildTree2(root, ite);
                }else{
                    root = new MyNode(Integer.parseInt(token));
                    root.list.add(buildTree2(root, ite)); 
                }
            }
            return root;
        }
        return null;
    }

    static void test14(){
        Aron.beg();
        String file = "file.txt";
        try(BufferedReader br = new BufferedReader(new FileReader(file))){
            for(String line; (line = br.readLine()) != null;){
                System.out.println("[" + line + "]");
            }
        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        String file1 = "file1.txt";
        try(BufferedWriter bw = new BufferedWriter(new FileWriter(file1))){
            bw.write("dog\n");
            bw.write("God");
        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        Aron.end();
    }
    static void test15(){
        Aron.beg();
        
        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20); 
        int n = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        buildMap(bt.root, n, map);
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " " + entry.getValue() +"]");
        }
        int index = 0;
        Node root = buildTree(map, index);
        Aron.inorder(root);
                 
        Aron.end();
    }
    
    static void test16(){
        Aron.beg();

        System.out.println(String.format("[%1$-1s]" , "123"));
//        System.out.println(String.format("[%1$05d]" , "123"));

        Aron.end();
    }

    static void test17(){
        Aron.beg();
        String str = "[1 [2][3][10[11][12]][20[21][22]]]";
        String[] arr = str.split("\\d+");
        for(String s : arr){
            System.out.println("{" + s + "}");
        }
        Aron.end();
    }
    static void test18(){
        Aron.beg();
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(1);
        list.add(2);
        list.add(3);

        Iterator<Integer> ite = list.iterator();
        while(ite.hasNext()){
            System.out.println("[" + ite.next() + "]"); 
        }
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node {
    public Node left;
    public Node right;
    public int data;
    public Node(int n) {
        data = n;
        left = null;
        right = null;
    }
    public Node getLeft() {
        return left;
    }
    public Node getRight() {
        return right;
    }
    public void setLeft(Node l) {
        left = l;
    }
    public void setRight(Node r) {
        right = r;
    }
}

class BST {
    Node root;
    public BST() {
        root = null;
    };
    public void Insert(int n) {
        if(root == null) {
            root = new Node(n);
        } else {
            Node curr = root;
            boolean end = false;
            while(curr != null && !end) {
                if(n < curr.data) {
                    if(curr.left == null) {
                        curr.left = new Node(n);
                        end = true;
                    } else
                        curr = curr.left;
                } else {
                    if(curr.right == null) {
                        curr.right = new Node(n);
                        end = true;
                    } else
                        curr = curr.right;
                }
            }
        }
    }
    public void Inorder(Node curr) {
        if(curr != null) {
            Inorder(curr.left);
            System.out.print(curr.data + " ");
            Inorder(curr.right);
        }
    }
    public Node getRoot() {
        return root;
    }
}
class InorderIteration {

    public static Node prev = null;
    public static void main(String args[]) {
        BST b1 = new BST();
        b1.Insert(15);
        b1.Insert(12);
        /*
        b1.Insert(14);
        b1.Insert(17);
        b1.Insert(19);
        b1.Insert(130);
        b1.Insert(16);
        b1.Insert(10);
        */

        PostorderIteration(b1.getRoot());
        System.out.println();
        Postorder(b1.getRoot());
        Node node = ConvertBSTToCircileDoubleLinkedList(b1.getRoot());
        int count = 0;
        while(node != null && count < 20) {
            System.out.println("<"+node.data+">");
            node = node.right;
            count++;
        }
        //Inorder(b1.getRoot());
    }

    // in order traversal using iteration
    // inorder iteration
    public static void InorderIteration(Node curr) {
        Stack<Node> st = new Stack<Node>();
        while(curr != null || !st.isEmpty()) {
            if(curr != null) {
                st.push(curr);
                curr = curr.left;
            } else {
                Node no = st.pop();
                System.out.println("[" + no.data + "]");
                curr = no.right;
            }
        }
    }

    //Convert bst binary search tree to circular double linked list
    public static Node ConvertBSTToCircileDoubleLinkedList(Node curr) {
        Stack<Node> st = new Stack<Node>();
        Node currNode = null;
        Node first = null;
        Node prev = null;
        while(curr != null || !st.isEmpty()) {
            if(curr != null) {
                st.push(curr);
                curr = curr.left;
            } else {
                prev = currNode;
                currNode = curr = st.pop();
                if(prev != null) {
                    prev.right = currNode;
                    currNode.left = prev;
                } else {
                    first = currNode;
                }
                //System.out.println(currNode.data);
                curr = curr.right;
            }
        }
        if(first != null) {
            first.left = currNode;
            currNode.right = first;
        }
        return first;
    }
    public static void PostorderIteration(Node curr) {
        /*
        Stack<Node> st = new Stack<Node>();
        Node prev = null;
        while(curr != null || !st.isEmpty())
        {
            if(curr != null)
            {
                st.push(curr);
                prev = curr.left;
                curr = curr.left;
            }
            else
            {
                curr = st.pop();
                if(prev == curr.right)
                    System.out.println("curr.data=" + curr.data);
                prev = curr.right;
                curr = curr.right;
            }
        }
        */
    }
    public static void Inorder(Node root) {
        if(root != null) {
            Inorder(root.left);
            System.out.println("data=" + root.data);
            Inorder(root.right);
        }
    }
    public static void Postorder(Node myroot) {
        if(myroot != null) {
            System.out.println("post=" + myroot.data);
            Postorder(myroot.left);
            Postorder(myroot.right);
        }
    }
}
class Node
{
    int data;
    Node next;
    public Node(int data)
    {
        this.data = data;
        next = null;
    }
}
class CircularLinkedList
{
    Node first;
    public CircularLinkedList()
    {
        first = null;
    }
    public void print()
    {
        Node tmpFirst = first;
        if( tmpFirst != null)
        {
            Node curr = tmpFirst.next;
            System.out.println("["+tmpFirst.data+"]");
            while(tmpFirst != curr)
            {
                System.out.println("["+curr.data+"]");
                curr = curr.next;
            }
        }
    }
    public void print(Node first)
    {
        this.first = first;
        print();
    }
    public void setFirst(Node first)
    {
        this.first = first;
    }
    public void insert(Node node)
    {
        if(node != null)
        {
            if(first == null) //zero node
            {
                first = node;
                node.next = first;
            }
            else
            {
                Node curr = first;
                Node next = curr.next;
                if(next == null) //one node
                {
                    first.next = node;
                    node.next = first;
                }
                else //two or more nodes
                {
                    boolean done = false;
                    while(!done)
                    {
                        if(curr.data < next.data)
                        {
                           if(curr.data < node.data && node.data < next.data) 
                           {
                                curr.next = node;
                                node.next = next;
                                done = true;
                           }
                        }
                        else
                        {
                            if(node.data > curr.data || node.data < next.data)
                            {
                                curr.next = node;
                                node.next = next;
                                done = true;
                            }
                        }
                        curr = curr.next;
                        next = next.next;
                    }
                }
            }
        }
    }
}
public class InsertCircularLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Insert node to sorted circular linked list!");
        CircularLinkedList cll = new CircularLinkedList();
        Node node1 = new Node(10);
        Node node2 = new Node(6);
        Node node3 = new Node(20);
        Node node4 = new Node(1);
        Node node5 = new Node(7);
        
        cll.insert(node1);
        cll.insert(node2);
        cll.insert(node3);
        cll.setFirst(node2);

        cll.insert(node4);
        cll.insert(node5);
        cll.print();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

// sorted linkedlist, sorted linked list
// gf SortedLinkedList.java
public class InsertSortedList{
    public static void main(String[] args) {
        test10();
        test11();
        test12();
        test13();
    }
    
    static void test10(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();

        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        sll.append(4);
        sll.append(7);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test11_thread(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        sll.append(4);
        sll.append(7);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }

    static void test11(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(4);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test13(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
}
class Node
{
    Node next;
    int data;
    public Node(int data)
    {this.data = data;}
}

class InsertToList
{
    Node head;
    public InsertToList()
    {head = null; }
    public void insert(Integer data)
    {
        if(head == null)
            head = new Node(data);
        else
        {
            Node curr = head;
            Node next = curr.next;
            if(next == null) //One node only
            {
                Node node = new Node(data);
                if(data > curr.data)
                    curr.next = node;
                else
                {
                    node.next = curr;
                    head = node;
                }
            }
            else            //More than one node
            {
                //Insert node before the head
                if(data < curr.data)
                {
                    Node node = new Node(data);
                    node.next = curr;
                    head = node;
                }
                else 
                {
                    //Insert node between curr and next 
                    while(next != null)
                    {
                        if(curr.data < data && data < next.data)
                        {
                            curr.next = new Node(data);
                            curr.next.next = next;
                            break;
                        }
                        curr = next;
                        next = next.next;
                    }
                    if(next == null) //Insert to the last node
                    {
                        curr.next = new Node(data);
                    }
                }
            }
        }
    }
    public void printList()
    {
        Node curr = head;
        while(curr != null)
        {
            System.out.print("["+curr.data+"]");
            curr = curr.next;
        } 
    }
}

public class InsertToOrderList 
{
    public static void main(String[] args)
    {
        System.out.println("Insert an integer to order list");
        InsertToList orderList = new InsertToList();        
        orderList.insert(1);
        orderList.insert(0);
        orderList.printList();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class  InterTwoSortArr
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr1 = {1, 4, 8, 10};
		int[] Arr2 = {2, 8, 10, 16};
		int[] A = InterTwoSortedArr(Arr1, Arr2);
		for(int i=0; i<A.length; i++)
			System.out.println("A["+i+"]="+A[i]);
	}
	

	public static int[] InterTwoSortedArr(int[] Arr1, int[] Arr2)
	{
		int[] A = null;
		int[] retArr = null;
		int i=0, j=0, c=0;
		if( Arr1 != null && Arr2 != null)
		{
			int len1 = Arr1.length;
			int len2 = Arr2.length;

			A = new int[len1>len2?len1:len2];
			while(i < len1 && j < len2)
			{ if(Arr1[i]<Arr2[j])
					i++; 
				else if(Arr1[i]>Arr2[j])
					j++; 
				else 
				{ A[c]=Arr1[i];
					i++; j++;
					c++;
				}
			}
			
		}
		retArr = new int[c];
		for(i=0; i<c; i++)
			retArr[i]=A[i];
		return retArr;
	}
}
import java.io.*;

interface myinter 
{
	public void face();
	public void print();
}

class myclass implements myinter 
{
	public void face()
	{
		System.out.println("face");
	}
	public void print()
	{
		System.out.println("print");
	}
}


class Interface 
{
	public static void main(String args[])
	{
		myclass a = new myclass();
		a.face();
		a.print();
	}
}
import java.util.*;

public class IntersectionList {
    public static void main(String[] args) {
        test0();
        test1();
    }

    static  void test0() {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        lists.add(Arrays.asList(1, 4, 4, 3, 2));
        lists.add(Arrays.asList(1, 3, 1, 9, 4));
        lists.add(Arrays.asList(1, 6, 3, 2, 2));
        List<Integer> retList = intersection(lists);

        for(Integer n : retList) {
            System.out.println(n);
        }
    }

    static  void test1() {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        lists.add(Arrays.asList(1, 4, 4, 3, 2));
        lists.add(Arrays.asList(6));
        lists.add(Arrays.asList(1, 6, 3, 2, 2));
        List<Integer> retList = intersection(lists);

        for(Integer n : retList) {
            System.out.println(n);
        }
    }

    //[ file=intersectionlist.html title=""
    public static List<Integer> intersection(List<List<Integer>> lists) {
        List<Integer> retList = new ArrayList<Integer>();
        if(lists != null) {
            Map<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();

            for (int i = 0; i < lists.size(); i++) {
                List<Integer> list = lists.get(i);

                for (Integer n : list) {
                    Set<Integer> set = map.get(n);
                    if (set != null) {
                        set.add(i);
                        map.put(n, set);
                    } else {
                        Set<Integer> nSet = new HashSet<Integer>();
                        nSet.add(i);
                        map.put(n, nSet);
                    }
                }
            }
            for (Map.Entry<Integer, Set<Integer>> entry : map.entrySet()) {
                Integer n = entry.getKey();
                Set<Integer> set = map.get(n);
                if (set.size() == lists.size())
                    retList.add(n);
            }
        }
        return retList;
    }
    //]
}
import java.util.*;
import java.io.*;
import classfile.*;

class Entry{
    public String key;
    public Object value;
    public Entry next;
    public Entry(String key, Object value){
        this.key = key;
        this.value = value;
    }
}

class Hash{
    public Entry[] arr;
    public int max;
    public int count = 0;
    public Hash(int max){
        this.max = max;
        arr = new Entry[max];
    }

    public Node get(String key){
        int hash = key.hashCode() % max;
        return (Node)arr[hash].value;
    }
    public void delete(String key){
        if(key != null){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr != null){
                Entry prev = null;
                while(curr != null){
                    if(curr.key == key)
                        break;
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(prev == null){
                    arr[hash] = curr.next;
                    count--;
                }else{
                    if(curr != null){
                        prev.next = curr.next;
                        count--;
                    }
                }
            }
        }
    }
    public void put(String key, Node node){
        if(count < max){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr == null){
                arr[hash] = new Entry(key, node);
                count++;
            }
            else{
                Entry prev = null;
                while(curr != null){
                    if(curr.key.equals(key)){
                        // Replace with new value
                        curr.value = node;
                        break;
                    }
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                // No key is found
                if(curr == null){
                    prev.next = new Entry(key, node);
                    count++;
                }
            }
        }
        
    }
}


class Interval implements Comparable<Interval> {
    int startTime;
    int endTime;
    public Interval(int startTime, int endTime) {
        this.startTime = startTime;
        this.endTime = endTime;
    }
    public int compareTo(Interval v) {
        return startTime - v.startTime;
    }
}


//[ file=inorderiterator.html title=""     
class InorderIterator {
    Node curr;
    Stack<Node> stack = new Stack<Node>();
    public InorderIterator(Node r) {
        this.curr = r;
    }
    public boolean hasNext() {
        if(curr != null || stack.size() > 0)
            return true;
        else
            return false;
    }
    public int next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node.data;
            }
        }
        return -1;
    }
}
//]

public class IntervalExample {
    public static void main(String[] args) {
        test0_InorderIterator();
        test1_InorderIterator();
        test2_InorderIterator();
        test3_InorderIterator();
        test00_hash();
        test01_hash();
        test02_hash();
        test03_hash();
        test04_hash();
        test05_hash();
        test06_hash();
        test07_hash();
        test08_hash();
        test09_hash();
        test010_hash();
        test011_hash();
        test012_hash();
    }
    static void test0_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
//        bst.insert(5);
//        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test1_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test2_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test3_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(1);
        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    // 4:17
    static int[] multiple(int[] arr) {
        int[] tmpArray = null;
        if(arr != null) {
            int len = arr.length;
            tmpArray = new int[len];
            for(int i=0; i<len; i++) {
                int m = 1;
                for(int j=0; j<len; j++) {
                    if(i != j) {
                        m *= arr[j];
                    }
                }
                tmpArray[i] = m;
            }
        }
        return tmpArray;
    }
    // prefix and suffix
    // abc = [a, bc], [ab, c], [abc, ""]
    static List<String> prefixSuffix(String str) {
        List<String> list = new ArrayList<String>();
        if(str != null) {
            int len = str.length();
            for(int i=0; i<len; i++) {
                String prefix = str.substring(0, i+1);
                String suffix = str.substring(i+1, len);
                list.add(prefix);
                list.add(suffix);
            }

        }
        return list;
    }
    static void test2() {
        Aron.beg();
        String str = "abc";
        prefixSuffix(str);
        Aron.end();
    }
    //  4:14 - 5:20
    static void inorder(Node r) {
        if(r != null) {
            inorder(r.left);
            Print.p(r.data);
            inorder(r.right);
        }
    }
    static void inorderIterator(Node r) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = r;
        while(curr != null || stack.size() > 0) {
            if(curr != null) {
                stack.push(r);
                curr = r.left;
            } else {
                Node p = stack.pop();
                Print.p(p.data);
                curr = p.right;
            }
        }
    }
    // 5:20 - 5:34
    static void preorder(Node r) {
        if(r != null) {
            Print.p(r.data);
            preorder(r.left);
            preorder(r.right);
        }
    }
    static void preorderIterator(Node r) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = r;
        while(curr != null || stack.size() > 0) {
            if(curr != null) {
                Print.p(curr.data);
                stack.push(curr);
                curr = curr.left;
            } else {
                Node p = stack.pop();
                curr = p.right;
            }
        }
    }
    // 5:35 - 5:42
    static void postorder(Node r) {
        if( r != null) {
            postorder(r.left);
            postorder(r.right);
            Print.p(r.data);
        }
    }
    // use two stacks
    static void postorderIterator(Node r) {
        Stack<Node> stack1 = new Stack<Node>();
        Stack<Node> stack2 = new Stack<Node>();
        if(r != null) {
            stack1.push(r);
            while(stack1.size() > 0) {
                Node node = stack1.pop();
                if(node.left != null)
                    stack1.push(node.left);

                if(node.right != null)
                    stack1.push(node.right);

                stack2.push(node);
            }
            while(stack2.size() > 0) {
                Print.p(stack2.pop().data);
            }
        }
    }

    static void test1() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int[] array = multiple(arr);
        Aron.printArray(arr);
        Aron.printArray(array);

        Aron.end();
    }


    // test1 [1]
    // test2 [1, 2]
    // test3 [2, 1]
    // test4 [3, 1, 2]
    // test5 [2, 3, 1]
    public static int findMaxIndex(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] < arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;
                if(arr[lo] < arr[mid])
                    return findMaxIndex(arr, mid, hi);
                else
                    return findMaxIndex(arr, lo, mid);
            }
        }
        return -1;
    }
    
    static void test00_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        Node node = (Node)hash.get("a");

        Test.f(node, null);
        Test.f(node, new Node(3));
        Test.t(node, new Node(1));

        Aron.end();
    }
    static void test01_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("a", new Node(2));
        Node node = (Node)hash.get("a");
        Test.t(node, new Node(2));

        Aron.end();
    }
    static void test02_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test03_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        hash.put("e", new Node(5));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test04_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.delete("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
        }

        Aron.end();
    }
    static void test05_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.delete("a");
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test06_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test07_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 1);

        Aron.end();
    }
    static void test08_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 0);

        Aron.end();
    }
    static void test09_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        Test.t(hash.count, 2);

        Aron.end();
    }
    static void test010_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        Test.t(hash.count, 1);

        Aron.end();
    }
    static void test011_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
    static void test012_hash(){
        Aron.beg();
        Hash hash = new Hash(3);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

public class InvertBinTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    
    public static Node invert(Node root){
        if(root != null){
            Node right = invert(root.left);
            Node left  = invert(root.right);
            root.right = right;
            root.left  = left;
            return root;
        }
        return null;
    }
    public static void test0(){
       BST bst = new BST(); 
       bst.insert(10);
       bst.insert(5);
       bst.insert(15);
       bst.insert(7);
       Ut.l();
       Aron.inorder(bst.getRoot());
       Ut.l();
       Node r = invert(bst.getRoot());
       Aron.inorder(r);
    }
    public static void test1(){
       BST bst = new BST(); 
       bst.insert(10);
       bst.insert(5);
       bst.insert(7);
       bst.insert(15);
       bst.insert(12);
       bst.insert(18);
       Ut.l();
       Aron.inorder(bst.getRoot());
       Ut.l();
       Node r = invert(bst.getRoot());
       Aron.binImage(r);
       Aron.inorder(r);
    }
}
public class IsLeapYear 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int isLeapYear(int month, int year)
    {

    }
}
import java.lang.Integer;
import java.lang.String;
import java.util.*;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.stream.Stream;

import classfile.*;

public class JavaDataStructure {
    public static void main(String[] args) {
        System.out.println("Java Data Structure");

        //[file=data-structure.html title=""
        // map, list, linkedlist, HashMap, HashTable, queue, stack
        //
        int[] array     = {1, 2, 3};
        int[][]  array2 = {{1, 2, 3},
            {4, 5, 6}
        };
        // ArrayList
        ArrayList<String> alist = new ArrayList<String>();
        alist.add("dog");
        alist.add("cat");

        // list of list, ArrayList 2D
        ArrayList<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        list2d.add(alist);

        // List
        List<String> list = new ArrayList<String>();
        list.add("eloberate");
        list.add("continue");
        list.add("continuous");

        // Vector is old data structure in Java, use List instead
        // Vector is not synchronized
        Vector<String> vector = new Vector<String>();
        vector.add("jobs");
        vector.add("career");
        vector.add("motivation");
        vector.add("ambition");

        // LinkedList
        LinkedList<Integer> linkedList = new LinkedList<Integer>();
        linkedList.add(1);
        linkedList.add(2);

        // Queue
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.add(1);
        queue.add(2);
        queue.remove();
        if(queue.peek() == 2)
            System.out.println("top element is :" + 2);

        // LinkedBlockingDeque
        // blocking, use lock in the implementation
        Deque<String> blockingDeque = new LinkedBlockingDeque<String>();
        blockingDeque.addFirst("first");
        blockingDeque.addLast("last");

        // non-blocking, non blocking, nonblocking queue
        // ConcurrentLinkedDeque, concurrent queue concurrentqueue
        Deque<String> concurrentDeque = new ConcurrentLinkedDeque<String>();
        concurrentDeque.addFirst("first");
        concurrentDeque.addLast("last");

        // HashMap can have null for [k, v]
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("cat", 1);
        map.put("dog", 2);

        String key = "cat";
        Integer value = map.get(key);
        if(value != null) {
            value = map.get(key);
            System.out.println("key=" + key + " value=" + value);
        }

        if(map.containsKey(key))
            System.out.println("map contains key=" + key);

        // java, init list, java initialize list, List as Value in HashMap
        Map<String, List<String>> mapList = new HashMap<String, List<String>>();
        mapList.put("1", Arrays.asList("dog", "cat", "cow"));
        mapList.put("2", Arrays.asList("C++", "Java", "Haskell"));
        mapList.put("3", Arrays.asList("Scala", "Python", "Ruby"));

        for(Map.Entry<String, List<String>> entry: mapList.entrySet()) {
            String myKey = entry.getKey();
            List<String> myList = entry.getValue();
            for(String elem: myList) {
                System.out.println("myKey=" + myKey + " list=" + elem);
            }
        }

        if(mapList.containsKey("key")) {
            System.out.println("contains key");
        }

        // HashTable can't have [k, v] to be null
        Map<String, String> table = new Hashtable<String, String>();
        table.put("key", "value");
        table.put("nonull", "nonull");
        for(Map.Entry<String, String> entry : table.entrySet()) {
            System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
        }

        List<String> mylist = mapList.get("dog");
        int size = mapList.size();
        if(mapList.containsValue("1")) {
            System.out.println("contains value");
        }

        for(String str : mylist) {
            System.out.println("str=" + str);
        }

        // iterate set, for set, for hashset, loop set,   HashSet
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2));
        Integer item = 1;
        if(set.contains(item))
            System.out.println("set contains element:" + 1);


        for(Integer n : set) {
            System.out.println("n=:" + n);
        }

        set.remove(item);
        int size1 = set.size();
        System.out.println("size1 =" + set.size());

        // iterate set
        for(Integer elem: set) {
            System.out.println("for elem:=" + elem);
        }

        // set to array
        Integer[] array1 = (Integer[]) set.toArray(new Integer[set.size()]);
        for(Integer n: array1) {
            System.out.println("n=:" + n);
        }

        List<Integer> list4 = new ArrayList<>(); 
        Integer[] array4 = (Integer[]) list4.toArray();

        Integer[] arr5 = {1, 2, 3};
        List<Integer> list5 = Arrays.asList(arr5);

        // list to iterator
        List<Integer> list8 = new ArrayList<Integer>();
        list8.add(1);
        list8.add(2);
        Iterator<Integer> ite = list8.iterator();
        while(ite.hasNext()) {
            System.out.println("[" + ite.next() + "]");
        }

        // double ended queue, deck
        Deque<Node> queue1 = new ArrayDeque<Node>();
        queue1.add(new Node(1));
        queue1.add(new Node(2));
        System.out.println("size[" + queue1.size() + "]");
        queue1.poll();
        System.out.println("size[" + queue1.size() + "]");

        List<String> list1 = new ArrayList<String>();
        List<String> list2 = new LinkedList<String>();
        List<String> list3 = new Stack<String>();
        List<String> list6 = new Vector<String>();
        Queue<String> queue2 = new LinkedList<String>();
        Queue<String> queue3 = new PriorityQueue<String>();
        Map<String, String> mymap = new HashMap<String, String>();
        Map<String, String> mymap1 = new Hashtable<String, String>();
        Map<String, String> mymap2 = new LinkedHashMap<String, String>();

        //]
    }
}
import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.stream.*;
import java.util.*;
import java.io.*;
import classfile.*;

// *j_json* *json* *json_array* *json_Serializable* *json_class* *j_json_example*
class Item implements Serializable {
    @SerializedName("_OrderDetails")
    private OrderDetails[] mOrderDetails;

    @SerializedName("Id")
    private String mId;
    public String getId(){
        return mId;
    }

    public OrderDetails[] getMOrderDetails(){ 
        return mOrderDetails;
    }

    @SerializedName("OrderData")
    private String mOrderDate;

    @SerializedName("Number")
    private String mNumber;

    @SerializedName("CustomerName")
    private String mCustomerName;

    @SerializedName("Note")
    private String mNote;

    // Add setters and getters

    public static class OrderDetails implements Serializable {
        @SerializedName("ProductName")
        private String mProductName;
        String getMProductName(){
            return mProductName;
        }

        @SerializedName("TotalAfterDiscount_Lc")
        private String mTotalAfterDiscount;

        @SerializedName("MeasureUnitName")
        private String mMeasureUnitName;

        @SerializedName("TotalPrice_Lc")
        private String mTotalPrice;

        @SerializedName("PricePerUnit_Lc")
        private String mPricePerUnit;

        @SerializedName("Quantity")
        private String mQuantity;

        // Add setters and getters
    }
}

public class JsonArray {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String responseJSON = "[\n" +
                              "  {\n" +
                              "    \"_OrderDetails\": [\n" +
                              "      {\n" +
                              "         \"ProductName\": \"FUCHS SUPER GT SAE 10W30 6X5 / FP10100010102\",\n" +
                              "        \"TotalAfterDiscount_Lc\": \"7500\",\n" +
                              "        \"MeasureUnitName\": \"كرتونة\",\n" +
                              "        \"TotalPrice_Lc\": \"7500\",\n" +
                              "        \"PricePerUnit_Lc\": \"75\",\n" +
                              "        \"Quantity\": \"100\"\n" +
                              "      }\n" +
                              "    ],\n" +
                              "    \"Id\": \"274\",\n" +
                              "    \"OrderDate\": \"4/10/2014 12:00:00 AM\",\n" +
                              "    \"Number\": \"16\",\n" +
                              "    \"CustomerName\": \"الأسد\",\n" +
                              "    \"Note\": \"\"\n" +
                              "  }\n" +
                              "]";

        Item[] placelist;
        Gson gson = new Gson();
        placelist = gson.fromJson(responseJSON, Item[].class);
        System.out.println(Arrays.toString(placelist));
        for(Item m : placelist){
            Print.pbl(m.getId());
            for(Item.OrderDetails order : m.getMOrderDetails()){
                Print.pbl(order.getMProductName());
            }
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}


import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.util.Iterator;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import classfile.*;

/*
gx https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple/1.1
<!-- https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple -->
<dependency>
    <groupId>com.googlecode.json-simple</groupId>
    <artifactId>json-simple</artifactId>
    <version>1.1</version>
</dependency>
*/


// *j-json-example-array-object*   *json-example*
public class JsonArrayExample{
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        test0();
        Ut.l();
        test1();
        Ut.l();
        test2();
        Ut.l();
        test3();
        Ut.l();
        test4();
    }
    static void test0(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            // *j-json-read-file*
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/file1.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("Name");
            String author = (String) jsonObject.get("Author");
            JSONArray companyList = (JSONArray) jsonObject.get("Company List");
 
            System.out.println("Name: " + name);
            System.out.println("Author: " + author);
            System.out.println("\nCompany List:");
            Iterator<String> iterator = companyList.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonobj.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("name");
            Print.pbl("name=" + name);
            JSONObject jsonObj = (JSONObject)jsonObject.get("obj");
            String age = (String)jsonObj.get("age");
            Print.pbl(age);
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    }

    static void test2(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonArray.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("name");
            Print.pbl("name=" + name);
            JSONObject jsonObj = (JSONObject)jsonObject.get("product");
            String age = (String)jsonObj.get("age");
            Print.pbl(age);
            JSONArray jsonArray = (JSONArray)jsonObject.get("array"); 

            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                Print.pbl(iterator.next().get("id"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonObjObj.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
            JSONArray jsonArray = (JSONArray)jsonObject.get("product"); 
            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                Print.pbl(iterator.next().get("id"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    } 

    static void test4(){
        Aron.beg();
        listAllCategories();
        Aron.end();
    } 

    public static void listAllCategories(){
        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/json_product.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
            JSONArray jsonArray = (JSONArray)jsonObject.get("products"); 
            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                JSONObject currJson = iterator.next(); 
                Print.pbl(currJson.get("id"));
                Print.pbl(currJson.get("name"));
                Print.pbl(currJson.get("category"));
                Ut.l();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

import classfile.*;
import java.util.*;

class CharacterIterator implements Iterator<Character>{
    String str;
    int index = 0;
    public CharacterIterator(String str){
        this.str = str;
    }
    public boolean hasNext(){
        return index < str.length();
    }
    public Character next(){
        Character ch = str.charAt(index);
        index++;
        return ch;
    }
}

class MyJSon{
    public Map<String, Object> map = new HashMap<String, Object>();
}

// Json parser
class JObj{
    public String value;
    Map<String, JObj> map = new HashMap<String, JObj>();
    Map<String, ArrayList<JObj>> mapList = new HashMap<String, ArrayList<JObj>>();
    public JObj(String value){
        this.value = value;
    }
}

interface Json{
}

class Value implements Json{
    String str;
    public Value(String str){
        this.str = str;
    }
}
class JObject implements Json{
    JObject obj;
}

class JList implements Json{
    List<Json> list = new ArrayList<Json>();
}


public class JsonParser{
    public static void main(String[] args) {
        //test0();
        // this will affect the [static index]
        //test1(); 

    }
    public static void test00() {
        Aron.beg();
        MyJSon son = new MyJSon();
        List<MyJSon> list = new ArrayList<MyJSon>(); 
        son.map.put("a", "b");
        son.map.put("k", new MyJSon());
        son.map.put("k", list);

        Aron.end();
    }
    public static void test0() {
        Aron.beg();
        String str = "\"do\"";
        char[] arr = str.toCharArray();
        String name = parseName(arr);
        Print.pb(name);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        String str = "{\"a\":\"b\"}";
        CharacterIterator ite = str.iterator(); 

        JObj obj = jsonParser(ite);
        print(obj);
        Aron.end();
    }
    public static void print(JObj obj){
        if(obj != null){
            Print.pb(obj.value);
            for(Map.Entry<String, JObj> entry : obj.map.entrySet()){
                Print.pb(entry.getKey());
                print(entry.getValue());
            }
        }
    }

    // {"dog":"cat"}
    // {"dog":{"cat":"rat"}}
    // {"dog":{"cat":"rat","pig":"cow"}}
    // {"dog":[{"cat":"rat"},{"pig":"cow"}]}
    // k->o1
    // k->{01}
    // k->[{o1, o2}]
    // k->[{01}]
    /**
     * {"dog":"cat"}
     * {"dog":"cat", "cow":"rat"}
     * {"dog":{"cat":"rat"}}
     * {"dog":{"cat":"rat", "cow":"pig"}}
     * {"dog":[{"cat":"rat"}, {"cow":"pig"}]
     * dog->{<cat, rat>, <cow, pig>}
     * dog->[<cat, rat>, <cow, pig>]
     */
    static int index = 0;
    public static JObj jsonParser(Iterator<Character> ite){

        return null;
    }

    static String parseValue(char[] arr){
        return parseName(arr);
    }
    // "ab"
    // ""
    static String parseName(char[] arr){
        String str = "";
        int c = 0;
        while(index < arr.length){
            if(arr[index] != '"')
                str += arr[index];
            else{
                c++;
                if(c == 2)
                 break;
            }

            index++;
        }
        return c == 2? str : null;
    }
}
import java.util.*;

// priority heap compareto compareTo heapify heap
//[ file=kclosest.html title=""
// Compile: javac KClosestPoint.java and java KClosestPoint
// Runtime: (n*logk)
class Point{
    double x;
    double y;
    public Point(double x, double y){
        this.x = x;
        this.y = y;
    }
}

class Distance implements Comparable<Distance>{
    Point ref;
    Point point;
    public Distance(Point ref, Point point){
        this.ref = ref;
        this.point = point;
    }

    private double norm(){
        double normRef = (point.x - ref.x)*(point.x - ref.x) +  
                         (point.y - ref.y)*(point.y - ref.y);
        return normRef;
    }
    public int compareTo(Distance d){
        if(this.norm() > d.norm())
            return 1;
        else if(this.norm() == d.norm() )
            return 0;
        else 
            return -1;

    }
    public String toString(){
        return "["+ point.x +"]["+ point.y +"]";
    }
}

public class KClosestPoint {
    public static void main(String[] args) {
        test1();
    }
    public static void test1() {

        Point ref = new Point(1, 1);
        Set<Point> set = new HashSet<Point>(); 
        set.add(new Point(20, 20));
        set.add(new Point(2, 2));
        set.add(new Point(10, 10));
        set.add(new Point(2, 4));

        PriorityQueue<Distance> queue = new PriorityQueue<Distance>();
        for(Point pt : set){
            queue.add(new Distance(ref, pt)); 
        }
        int k = 3;
        while(k > 0){
            System.out.println(queue.remove().toString());
            k--;
        }
    }
}
//]

//Find a sequence of moves of a Knight on a chessboard such that the Knight visits each square only once 
public class KnightTour 
{
    public static void main(String[] args)
    {
        test1();
    }
    public static void test1()
    {
        int[][] board = new int[8][8];
        int count = 0;
        int c = 0;
        int r = 0;
        findPath(board, count, c, r);
    }
    public static void findPath(int[][] board, int count, int c, int r)
    {
        if(board != null)
        {
            if(count == 64)
            {
                Aron.printArray2D(board);
                System.exit(0);
            }
            else
            {
                board[c][r] = count+1;
                System.out.println("["+c+"]["+r+"] count="+count);

                if(c + 1 < 8 && r + 2 < 8 && board[c+1][r+2] == 0)
                    findPath(board, count+1, c+1, r+2);

                if(c + 2 < 8 && r + 1 < 8 && board[c+2][r+1] == 0)
                    findPath(board, count+1, c+2, r+1);

                if(c + 2 < 8 && r - 1 >= 0 && board[c+2][r-1] == 0)
                    findPath(board, count+1, c+2, r-1);

                if(c + 1 < 8 && r - 2 >= 0 && board[c+1][r-2] == 0)
                    findPath(board, count+1, c+1, r-2);

                if(c - 1 >= 0 && r - 2 >= 8 && board[c-1][r-2] == 0)
                    findPath(board, count+1, c-1, r-2);

                if(c - 2 >= 0 && r - 1 >= 0 && board[c-2][r-1] == 0)
                    findPath(board, count+1, c-2, r-1);

                if(c - 2 >= 0 && r + 1 < 8 && board[c-2][r+1] == 0)
                    findPath(board, count+1, c-2, r+1);

                if(c - 1 >= 0 && r + 2 < 8 && board[c-1][r+2] == 0)
                    findPath(board, count+1, c-1, r+2);

                board[c][r] = 0;
            }
        }
    }
}
public class KthMedian 
{
    public static void main(String[] args)
    {
       test1(); 
       test2(); 
       test3(); 
       test4(); 
    }
    public static void test1()
    {
        System.out.println("test1");
        int[] array = {1, 4, 2, 5, 6};
        int lo = 0, hi = array.length-1;
        int k=5;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 6);
    } 
    public static void test2()
    {
        System.out.println("test2");
        int[] array = {1, 4};
        int lo = 0, hi = array.length-1;
        int k=1;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 
    public static void test3()
    {
        System.out.println("test3");
        int[] array = {1};
        int lo = 0, hi = array.length-1;
        int k=1;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 
    public static void test4()
    {
        System.out.println("test4");
        int[] array = {2, 0, 1};
        int lo = 0, hi = array.length-1;
        int k=2;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 

    //Find the kth median element in a unsorted array
    //Return index for the kth smaller element
    //Otherwise return -1
    public static int modifiedQuickSort(int[] array, int lo, int hi, int k)
    {
        if(k <= hi - lo + 1) 
        {
            if(hi == lo && k == 1)
                return lo;
            else{
                int pindex = partition(array, lo, hi);
                int leftLen = pindex - lo;
                int rightLen = hi - pindex;
                if(pindex + 1 > k) 
                    return modifiedQuickSort(array, lo, pindex-1, k);
                else if(pindex + 1 < k)
                    return modifiedQuickSort(array, pindex+1, hi, k - (leftLen+1));
                else 
                    return pindex;
            }
        }
        return -1;
    }

    //use modified quicksort algorithm to find the kth median element
    //partition an array to two parts: left_array < pivot < right_array
    public static int partition(int[] array, int lo, int hi)
    {
        int top = lo;
        if(array != null)
        {
            int pivot = array[hi];
            for(int i=lo; i<=hi; i++)
            {
                if(array[i] < pivot)
                {
                    swap(array, i, top);
                    top++;
                }
            }
            swap(array, top, hi); 
        }
        return top;
    } 
    public static void swap(int[] array, int i, int j)
    {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
public class LCS 
{
    /**
     * 0               if i ==0 || j == 0
     * 
     *                  LCS(A[i-1], B[j-1]) + 1  if A[i]==B[j]
     * LCS(A[i], B[j] 
     *                  Max(LCS(A[i-1], B[j]), LCS(A[i], B[j-1]) if A[i] != B[j]
     *
     */
    public static void main(String[] args)
    {
                    System.out.println("Hello World!");
                    char[] A = {'a', 'b', 'c', 'd'}; 
                    char[] B = {'a', 'c'}; 
                    char[] Arr = new char[10];
                    int i = A.length;
                    int j = B.length;
                    int k = 0;
                    LCS(A, i, B, j, Arr, k); 
                    for(int x=0; x<2; x++)
                    {
                        System.out.println("Arr["+x+"]="+Arr[x]);
                    }
    }
    static int LCS(char[] A, int i, char[] B, int j, char[] Arr, int k)
    {
        if(i == 0 || j == 0)
        {
            return 0;
        }
        else if(A[i-1] == B[j-1])
        {
            Arr[k]=A[i-1];
            return LCS(A, i-1, B, j-1, Arr, k+1)+1;
        }
        else
        {
            return LCS(A, i-1, B, j, Arr, k)>LCS(A, i, B, j-1, Arr, k)?LCS(A, i-1, B, j, Arr, k):LCS(A, i, B, j-1, Arr, k);
        }
    }
}
import java.util.*;
import classfile.*; 

// LRU cache
// least recent used cache
// lru cache  
class Node<T> {
    Node next;
    Node prev;
    String key;
    T data;
    public Node(String key, T data) {
        next = prev = null;
        this.key = key;
        this.data = data;
    }
}

class LRU {
    Node least;
    Node most;
    int maxSize;
    int count;
    Map<String, Node<String>> map = new HashMap<String, Node<String>>();
    public LRU(int size) {
        least = most = null;
        maxSize = size;
        count = 0;
    }

    Node get(String key) {
        Node<String> node = map.get(key);
        if( node != null) {
            if(node != most) {
                remove(node.key);
                append(key, node.data);
            }
        }
        return node;
    }
    void insert(String key, String data) {
        if(!map.containsKey(key)) {
            append(key, data);
        } else {
            Node node = map.get(key);
            remove(key);
            append(key, data);
        }
    }
    void remove(String key) {
        Node curr = map.get(key);
        if( curr != null) {
            Node prev = curr.prev;
            Node next = curr.next;
            if(prev == null && next == null) {
                least = most = null;
                curr.next = curr.prev = null;
            } else if(prev != null && next == null) {
                most = prev;
                most.next = null;
                curr.next = curr.prev = null;
            } else if(prev == null && next != null) {
                least = next;
                next.prev = null;
                curr.next = curr.prev = null;
            } else {
                prev.next = next;
                next.prev = prev;
                curr.next = curr.prev = null;
            }
            map.remove(key);
            count--;
        }
    }
    void append(String key, String data) {
        if(least == null && count < maxSize) {
            Node<String> node = new Node<String>(key, data);
            least = most = node;
            map.put(key, node);
            count++;
        } else {
            if(count < maxSize) {
                Node<String> node = new Node<String>(key, data);
                most.next = node;
                node.prev = most;
                most = node;
                map.put(key, node);
                count++;
            } else {
                Node next = least.next;
                least.next = null;
                if(next != null)
                    next.prev = null;
                else
                    least = most = null;
                least = next;
                count--;
                append(key, data);
            }
        }
    }
    void print() {
        Node curr = least;
        while(curr != null) {
            System.out.println("<"+curr.key+","+curr.data+">");
            curr = curr.next;
        }
    }
}

public class LRUCache {
    public static void main(String[] args) {
        test0();
    }
    
    static void test0(){
        Aron.beg();

        System.out.println("Least Recent Used Cache");
        LRU  lru = new LRU(4);

        lru.insert("key", "mydata");
        lru.insert("key1", "mydata1");
        lru.insert("key2", "mydata2");
        lru.insert("key3", "mydata3");
        lru.insert("key4", "mydata4");
        lru.insert("key5", "mydata5");
        lru.get("key2");
        lru.insert("key3", "mydatakey3");
        lru.print();
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;


// gx /Library/WebServer/Documents/zsurface/image/lrucache.png
// LRU cache, least recent used cache, lru cache new
// In memory catche.
// e.g. memcache 
//
//
// insert - if the key is in the map, remove the node from the list
//          update the map with new node, append the node to the list
// 
//          if the list is full, remove the oldest node, and append
//          the new node to the list, and update the map with new node
//  
//          update the map with new key/node
//          update the map with new key/node
// 
class RNode{
    String key;
    String data;
    public RNode(String key, String data){
        this.key = key;
        this.data = data;
    }
}
class LRUCacheNew {
    int max;
    int count;
    List<RNode> list = new ArrayList<RNode>(); 
    Map<String, RNode> map = new HashMap<String, RNode>(); 
    public LRUCacheNew(int max){
        this.max = max;
        count = 0;
    }
    public  RNode get(String key){
        RNode node = map.get(key);
        if(node != null){
            list.remove(node);
            list.add(node);
        }
        return node;
    }

    // gx /Library/WebServer/Documents/zsurface/image/lrucache.png
    public void insert(String key, RNode node){
        RNode vnode = map.get(key);
        if(vnode != null){
            // vnode is in the list
            map.remove(vnode.key);
            list.remove(vnode);
            map.put(key, node);
            list.add(node);
        }else{
            // vnode is not in the list
            if(count < max){
                map.put(key, node);
                list.add(node);
                count++;
            }else{
                if(max > 0){
                    list.remove(0);
                    map.put(key, node);
                    list.add(node);
                }
            }
        }
    }
    public void print(){
        for(RNode node : list){
            Print.pb(node.key + " " + node.data);
        }
    }
}

public class LRUCache2{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        LRUCacheNew lru = new LRUCacheNew(3);
        RNode n1 = new RNode("k1", "data1");
        RNode n2 = new RNode("k2", "data2");
        RNode n3 = new RNode("k3", "data3");
        RNode n4 = new RNode("k4", "data4");

        lru.insert(n1.key, n1);
        lru.insert(n2.key, n2);
        lru.insert(n3.key, n3);

        lru.print();

        Ut.l();
        lru.insert(n4.key, n4);

        lru.print();
        
        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        LRUCacheNew lru = new LRUCacheNew(3);
        RNode n1 = new RNode("k1", "data1");
        RNode n2 = new RNode("k2", "data2");
        RNode n3 = new RNode("k3", "data3");
        RNode n4 = new RNode("k2", "data4");
        RNode n5 = new RNode("k1", "data5");

        lru.insert(n1.key, n1);
        lru.insert(n2.key, n2);
        lru.insert(n3.key, n3);

        
        lru.print();

        Ut.l();
        lru.insert(n4.key, n4);
        Print.pb("insert k2  data4");
        lru.print();
        Ut.l();
        lru.insert(n5.key, n5);
        Print.pb("insert k1  data5");
        lru.print();

        Aron.end();
    }
} 

public class LeastDiff 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] arr = {1, 2, 3, 20, 30};
        int lo = 0;
        int hi = arr.length-1;
        int key = 5;
        int[] m = new int[1];
        m[0] = Integer.MAX_VALUE;
        LeastDiff(arr, lo, hi, key, m);
        System.out.println("m="+m[0]);
    }
    public static boolean LeastDiff(int[] arr, int lo, int hi, int key, int[] m)
    {
        if(lo <= hi)
        {
            int mid = (lo+hi)/2;
            if(key < arr[mid])
            {
                m[0] = Math.min(m[0], Math.abs(key - arr[mid]));
                return LeastDiff(arr, lo, mid-1, key, m);
            }
            else if(key > arr[mid])
            {
                m[0] = Math.min(m[0], Math.abs(key - arr[mid]));
                return LeastDiff(arr, mid+1, hi, key, m);
            }
            else
            {
                m[0] = 0;
                return true;  
            }
        }
        return false;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

class LevelOrder {
    public static Node prev = null;
    public static void main(String args[]) {
        test0();    
        test1();    
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);

        Node r = b1.getRoot();
        Queue<Node> q = new LinkedList<Node>();
        q.offer(b1.getRoot());
        LevelOrderRecursion(q);
        System.out.println("");
        LevelOrder(b1.getRoot());
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);
        LevelOrder(b1.root);
        LevelOrderOneQueue(b1.root);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 

    //level order recursion levelorder recursion
    public static void LevelOrderRecursion(Queue<Node> q) {
        Queue<Node> q1 = new LinkedList<Node>();
        while(q.peek() != null) {
            Node node = q.poll();
            Print.pb(node.data);
            if(node.left != null)
                q1.offer(node.left);
            if(node.right != null)
                q1.offer(node.right);
        }
        System.out.println();
        if(q1.peek() != null)
            LevelOrderRecursion(q1);
    }

    // level order with one queue
    public static void LevelOrderOneQueue(Node root) {
        if(root != null){
            Queue<Node> queue = new LinkedList<Node>();
            queue.offer(root);
            while(queue.peek() != null){
                Node curr = queue.remove();
                Print.pb(curr.data);
                if(curr.left != null)
                    queue.offer(curr.left);
                if(curr.right != null)
                    queue.offer(curr.right);

            }
        }
    }

    //level order with two queues
    public static void LevelOrder(Node cur) {
        Queue<Node> Q1 = new LinkedList<Node>();
        Queue<Node> Q2 = new LinkedList<Node>();
        Q1.offer(cur);
        while(Q1.peek() != null || Q2.peek() != null) {
            while(Q1.peek() != null) {
                Node top = Q1.poll();
                System.out.print(top.data + " ");
                if(top.left != null)
                    Q2.offer(top.left);
                if(top.right != null)
                    Q2.offer(top.right);
            }
            System.out.println();
            while(Q2.peek() != null) {
                Node top = Q2.poll();

                System.out.print(top.data + " ");
                if(top.left != null)
                    Q1.offer(top.left);
                if(top.right != null)
                    Q1.offer(top.right);
            }
            System.out.println();
        }
    }
}
import java.util.*;

public class LexicographicOrder 
{
    public static void main(String[] args)
    {
        System.out.println("Try it");
        test1();
        System.out.println("===========");
        printLexico(5);
        System.out.println("===========");
        printLexico(10);
        System.out.println("===========");
        printLexico(100);
        System.out.println("===========");
        printLexico(105);
        System.out.println("===========");
        printLexico(1234);
        System.out.println("===========");
    }
    public static void printLexico(int n)
    {
        System.out.println("n=["+n+"]");
        for(int down = 1; down <10; down++)
        {
            int base = down;
            while(base <= n)
            {
                System.out.print("["+base+"] ");
                base *= 10;
            }

            base /=10;
            while(base >=10 && base <= n)
            {
                int sum = base;
                for(int i=1; i<10 && base+i <=n; i++)
                {
                    sum = base + i;
                    System.out.print("["+sum+"] ");
                }
                base = sum/10 + 1;
                if(base*10 <= n)
                    base *=10;
            }
        }
    }
    public static void test1()
    {
        String s = "abc";
        for(int i=0; i<s.length(); i++)
        {
            String str = s.substring(0, i+1);
            System.out.println("str="+str);
        }
    }
}
import java.util.List;
import java.util.ArrayList;
class Node
{
    int data;
    Node root;
    Node left;
    Node right;
    public Node(int data)
    {
        this.data = data;
        this.root = null;
        this.left = null;
        this.right = null;
    }
    public Node(Node root)
    {
        this.root = root;
    }
}
class SLinkedList
{
    Node head;
    public SLinkedList()
    {
        head = null;
    }
    public void addBST(Node root)
    {
        if(head == null)
            head = new Node(root);
        else
        {
            Node curr = head;
            while(curr.right != null)
            {
                curr = curr.right;
            }
            curr.right = new Node(root);
        }
    }
    public void add(int data)
    {
        if(head == null)
        {
            head = new Node(data);
        }
        else
        {
            Node curr = head;
            while(curr.right != null)
            {
                curr = curr.right; 
            }
            curr.right = new Node(data);
        }
    }
    public void show()
    {
        Node curr = head;
        while(curr != null)
        {
            System.out.print("["+curr.data+"]");
            curr = curr.right;
        }
    }
    public void inorder(Node r)
    {
        if( r != null)
        {
            inorder(r.left);
            System.out.print("["+r.data+"]");
            inorder(r.right);
        }
    }
    public void showBST()
    {
        Node curr = head;
        while(curr != null)
        {
            Node tmp = curr;
            inorder(tmp.root);    
            curr = curr.right;
            System.out.println("=========");
        }
    }
}

class BST
{
    Node root;
    public BST()
    {
        root = null;
    }
    public void insert(int data)
    {
        if(root == null)
        {
            root = new Node(data);
        }
        else
        {
            Node curr = root;
            boolean done = false;
            while(!done)
            {
                if(data < curr.data)
                {
                    if(curr.left != null)
                    {
                        curr = curr.left;
                    }
                    else
                    {
                        curr.left = new Node(data);
                        done = true;
                    }
                }    
                else
                {
                    if(curr.right != null)
                    {
                        curr = curr.right;
                    }
                    else
                    {
                        curr.right = new Node(data);
                        done = true;
                    }
                }
            }
        }
    }
}


public class LinkedListBST 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SLinkedList sll = new SLinkedList();
        //sll.add(1);
        //sll.add(2);
        //sll.add(3);
        //sll.add(4);
        //sll.show();

        BST bst1 = new BST();
        BST bst2 = new BST();
        BST bst3 = new BST();
        System.out.println("=========");
        bst1.insert(10); 
        bst1.insert(5); 
        bst1.insert(15); 
        bst1.insert(7); 
        bst1.insert(30); 
        bst1.insert(12); 
        bst1.insert(1); 
        bst1.insert(2); 
        bst1.insert(0); 
        inorder(bst1.root);

        System.out.println("=========");
        bst2.insert(100); 
        bst2.insert(50); 
        bst2.insert(15); 
        bst2.insert(70); 
        bst2.insert(200); 
        bst2.insert(140); 
        bst2.insert(300); 
        inorder(bst2.root);

        System.out.println("=========");
        bst3.insert(30); 
        bst3.insert(60); 
        bst3.insert(105); 
        bst3.insert(9); 
        bst3.insert(50); 
        bst3.insert(10); 
        bst3.insert(1); 
        inorder(bst3.root);


        System.out.println("=========");
        sll.addBST(bst1.root);
        sll.addBST(bst2.root);
        sll.addBST(bst3.root);
        System.out.println("=========");
        sll.showBST();

        System.out.println("----------");
        List<List<Integer>> listList = new ArrayList<List<Integer>>();
        List<Integer> list = new ArrayList<Integer>(); 
        DFS(sll.head, sll.head.root, list, listList);
    }
    public static void DFS(Node curr, Node root, List<Integer> list, List<List<Integer>> listList)
    {
        if(curr != null)
        {
            if(root != null)
            {
                DFS(curr, root.left, list, listList);
                DFS(curr, root.right, list, listList);
                if(root.left == null && root.right == null)
                {
                    //System.out.print("{"+root.data+"}");
                    list.add(root.data);
                }
                if(list.size() > 1 || (list.size() > 0 && curr.root == root))
                {
                    System.out.println("");
                    List<Integer> tmpList = new ArrayList<Integer>(list);
                    listList.add(tmpList);
                    list.clear();
                    if(curr.right != null)
                    {
                        DFS(curr.right, curr.right.root, list, listList);
                        list.clear();
                        if(listList.size() > 0)
                            listList.remove(listList.size()-1);
                    }
                    else
                    {
                        for(List<Integer> mylist : listList)
                        {
                            for(Integer num : mylist)
                            {
                                System.out.print("["+num+"]");
                            }
                            System.out.println();
                        }
                        if(listList.size() > 0)
                            listList.remove(listList.size()-1);
                    }
                }
            }
        }
    }
    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
            System.out.print("["+node.data+"]");
            inorder(node.right);
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class LinkedListToBST{
    public static void main(String[] args) {
        //test0_buildTree();
        test01_buildTree();
        test2_middleLinkedList();
        test3_middleLinkedList();
        test4_buildTree2();
        test0_buildTree3();
        test0_buildTree4();
    }
    static void test0_buildTree() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int lo = 0;
        int hi = arr.length-1;
        Node root = buildTree(arr, lo, hi);
        Aron.levelOrder(root);
        Aron.inorder(root);
        Aron.binImage(root);

        Aron.end();
    }

    static void test01_buildTree() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        int lo = 0;
        int hi = arr.length-1;
        Node root = buildTree(arr, lo, hi);
        Aron.levelOrder(root);
        Aron.inorder(root);
        Aron.binImage(root);

        Aron.end();
    }
    public static Node buildTree(int[] arr, int lo, int hi) {
        if(lo <= hi) {
            int mid = 0;
            if ((lo + hi)%2 == 1)
                mid = (lo + hi)/2 + 1;
            else
                mid = (lo + hi)/2;
            Node parent = new Node(arr[mid]);
            parent.left = buildTree(arr, lo, mid-1);
            parent.right = buildTree(arr, mid+1, hi);
            return parent;
        }
        return null;
    }
    static int index = 0;
    public static Node buildTree2(int[] arr, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree2(arr, count/2);
            Node parent = new Node(arr[index]);
            parent.left = left;

            index++;
            parent.right = buildTree2(arr, count - count/2 - 1);
            return parent;
        }
    }

    public static Node buildTree3(Iterator<Integer> ite, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree3(ite, count/2);
            Node parent = new Node(ite.next());
            parent.left = left;

            parent.right = buildTree3(ite, count - count/2 - 1);
            return parent;
        }
    }

    static void test0_buildTree3(){
        Aron.beg();
        Integer[] arr = {1, 2, 3, 4}; 
        final Iterator<Integer> ite = Arrays.asList(arr).iterator();
        int count = arr.length;
        Node parent = buildTree3(ite, count);
        Aron.inorder(parent);
        Aron.line();
        Aron.preorder(parent);

        Aron.end();
    }

    static void test0_buildTree4(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        int count = 3;
        Node parent = buildTree4(sll.head, count);

        Aron.inorder(parent);
        Ut.l();
        Aron.preorder(parent);

        Aron.end();
    }
    public static Node buildTree4(Node curr, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree4(curr, count/2);
            Node parent = new Node(curr.data);
            parent.left = left;
            parent.right = buildTree4(curr.next, count - count/2 - 1);
            return parent;
        }
    }

    public static Node middleLinkedList(Node head){
        int steps = 2;
        int count = 0;

        Node first = head;
        if(first != null) {
            Node second = first.next;
            while(second != null && second.next != null) {
                first = first.next;
                while(count < steps && second != null) {
                   second = second.next;
                    count++;
                }
                steps++;
                count = 0;
            }
        }
        return first;
    }

    static void test2_middleLinkedList(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node node = middleLinkedList(sll.head);
        Test.t(node.data, 2);

        Aron.end();
    } 
    static void test3_middleLinkedList(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node node = middleLinkedList(sll.head);
        Test.t(node.data, 1);

        Aron.end();
    } 
    
    static void test4_buildTree2(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        
        
        int[] arr = {1, 2, 3, 4}; 
        int index = 0;
        int count = arr.length;

        Node parent = buildTree2(arr, count);
        Aron.levelOrder(parent);
        Aron.inorder(parent);

        Aron.end();
    }
}

import classfile.*;

class LinkedListToBST2 {
    /* head node of link list */
    static LNode head;

    /* Link list Node */
    class LNode {
        int data;
        LNode next, prev;

        LNode(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* A Binary Tree Node */
    class TNode {
        int data;
        TNode left, right;

        TNode(int d) {
            data = d;
            left = right = null;
        }
    }

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    TNode sortedListToBST() {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --> No. of nodes in the Doubly Linked List */
    TNode sortedListToBSTRecur(int n) {
        /* Base Case */
        if (n <= 0)
            return null;

        /* Recursively construct the left subtree */
        TNode left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        TNode root = new TNode(head.data);

        // Set pointer to left subtree
        root.left = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.right = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(LNode head) {
        int count = 0;
        LNode temp = head;
        while (temp != null) {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        LNode new_node = new LNode(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList(LNode node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(TNode node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    /* Drier program to test above functions */
    public static void main(String[] args) {
        LinkedListToBST2 llist = new LinkedListToBST2();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7->6->5->4->3->2->1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList(head);

        /* Convert List to BST */
        TNode root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}

import classfile.*;

class LinkedListToBalancedBST {
    /* head node of link list */
    static LNode head;

    /* Link list Node */
    class LNode {
        int data;
        LNode next, prev;

        LNode(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* A Binary Tree Node */
    class TNode {
        int data;
        TNode left, right;

        TNode(int d) {
            data = d;
            left = right = null;
        }
    }

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    TNode sortedListToBST() {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --> No. of nodes in the Doubly Linked List */
    TNode sortedListToBSTRecur(int n) {
        /* Base Case */
        if (n <= 0)
            return null;

        /* Recursively construct the left subtree */
        TNode left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        TNode root = new TNode(head.data);

        // Set pointer to left subtree
        root.left = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.right = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(LNode head) {
        int count = 0;
        LNode temp = head;
        while (temp != null) {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        LNode new_node = new LNode(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList(LNode node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(TNode node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    /* Drier program to test above functions */
    public static void main(String[] args) {
        LinkedListToBalancedBST llist = new LinkedListToBalancedBST();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7->6->5->4->3->2->1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList(head);

        /* Convert List to BST */
        TNode root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}

// This code has been contributed by Mayank Jaiswal(mayank_24)
import java.util.*;

public class ListAndSet 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
        test3();
        test4();
    }
    public static Set<Integer> clone(Set<Integer> set)
    {
        Set<Integer> s = new LinkedHashSet<Integer>(); 
        for(Integer ele: set)
            s.add(ele);

        return s;
    }
    public static void test1()
    {
        System.out.println("test1"); 
        int[] list = {1, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2)); 
        System.out.println(match(list, set));

    } 
    public static void test2()
    {
        System.out.println("test2"); 
        int[] list = {1, 4, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2)); 
        System.out.println(match(list, set));

    } 
    public static void test3()
    {
        System.out.println("test3"); 
        int[] list = {2, 4, 3, 1, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2, 3)); 
        System.out.println(match(list, set));
    } 
    public static void test4()
    {
        System.out.println("test4"); 
        int[] list = {2, 4, 3, 1, 2};
        Set<Integer> set = new HashSet<Integer>(); 
        System.out.println(match(list, set));
    } 
    public static boolean match(int[] list, Set<Integer> set)
    {
        Set<Integer> set1 = clone(set);
        if( list != null && set != null)
        {
            if(set1.isEmpty())
                return true;

            boolean start = false;
            for(int ele: list)
            {
                if(set1.contains(ele))
                {
                    set1.remove(ele);
                    start = true; 
                }
                else{
                    if(start)
                        set1 = clone(set);           
                    start = false;
                }

                if(set1.isEmpty())
                    return true;
            }
        }
        return false;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

//[ file=lock.html title=""
class MyLock{
    private boolean isLocked = false;

    public synchronized boolean lock(){
        if(!isLocked){
            isLocked = true;
            return isLocked;
        }
        return false;
    }
    public synchronized void unlock(){
        isLocked = false;
        notify();
    }
}
//]

public class LockExample{
    public static void main(String[] args) {
    }
    public static void print(){
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;


// logger, logging example, logger example, java logger
public class LoggerExample{
    private final static Logger LOGGER = Logger.getLogger(LoggerExample.class.getName());
    static private FileHandler fileTxt;
    static private SimpleFormatter formatterTxt;

    public static void main(String[] args) {
        try{
            test0();
        }catch(IOException e){
        }
    }
    public static void test0() throws IOException {
        Aron.beg();

        fileTxt = new FileHandler("./text/Logging.txt");
        formatterTxt = new SimpleFormatter();
        LOGGER.setLevel(Level.INFO);
        fileTxt.setFormatter(formatterTxt);
        LOGGER.addHandler(fileTxt);

        LOGGER.info("Logging an INFO-level message {0}");
        

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import classfile.Print;
import java.util.stream.*;
import java.util.stream.Collectors;

public class LongMultiplication{
    public static void main(String[] args) {
        test0();
        test1();
    }
    //  8 9 1
    //8 9 1
    public static void test0(){
        Aron.beg();
        int[] a = {9, 9};
        int[] b = {9, 9};
        int[] c = longMulti(a, b);
        Aron.printArray(c);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    public static int[] longMulti(int[] col, int[] row){
        int[] ret = null;
        if(col != null && row != null){
            int lc = col.length;
            int lr = row.length;
            int k = lc + lr;
            int kInx = k - 1;
            int[][] arr = new int[lc][k];
            for(int c=lc-1; c >= 0; c--){
                int carry = 0;
                int rc = lc - 1 - c;
                for(int r=lr-1; r >=0; r--){
                    int n = col[c]*row[r];
                    int rr = lr - 1 - r;
                    arr[c][kInx - rc - rr] = (carry + n) % 10;
                    carry = (carry + n) / 10;
                }
                // carry 
                arr[c][kInx - rc - lr] = carry;
            }
            ret = new int[k];
            int c = 0;
            for(int i=k-1; i >= 0; i--){
                int s = 0;
                for(int j=0; j<lc; j++){
                    s += arr[j][i];
                }
                ret[i] = (c + s) % 10;
                c = (c + s) / 10;
            }
        }
        return ret;
    }
} 

public class LongestContinuousSum 
{
    public static void main(String[] args)
    {
        test0(); 
        test1(); 
        test2(); 
        test3(); 
        test4(); 
        test5(); 
        test6(); 
        test7(); 
        test8(); 
    }
    public static int Sum(int[] array)
    {
        int max = 0;
        if(array != null)
        {
            int len = array.length;
            int[] result = new int[len];
            if(len > 0)
            {
                result[0] = array[0];
                for(int i=1; i<len; i++)
                {
                    result[i] = result[i-1] + array[i] > array[i] ? result[i-1] + array[i] : array[i];
                }
                for(int i=0; i<len; i++)
                {
                    if(max < result[i])      
                        max = result[i];
                }
            }
        }
        return max;
    }

    public static void test0()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 8, -5, 20, 3, -2}; 
        int max = Sum(array);
        System.out.println("max=" + max);
    }

    public static void test1()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{1, -5, 8, -2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test2()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{1, -5, 8, 4, -2, 3, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test3()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 1, -5, 8, 4, -2, 3, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test4()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 4, 2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test5()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 4, 2, -8}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test6()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test7()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{8}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test8()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{8, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void maxSumWithIndex(int[] array)
    {
        if(array != null && array.length > 0)
        {
            int len = array.length;
            int[] maxArr = new int[len];
            maxArr[0] = array[0]; 

            int first = 0;
            int second = 0;
            int max = array[0];
            for(int i=1; i < len; i++)
            {
                maxArr[i] = Math.max(maxArr[i-1] + array[i], array[i]);            
                if(maxArr[i] > max)
                {
                    if(i-1 >=0 && maxArr[i-1] < 0)
                        first = i;
                    second = i;
                    max = maxArr[i];
                }
            }

            /*
            max = maxArr[0];
            for(int i=1; i<len; i++)
                if(maxArr[i] > max)
                    max = maxArr[i];
            */
            System.out.println("max=" + max);
            System.out.println("first=" + first);
            System.out.println("second=" + second);
        }
    }
}
import java.io.*;

class LongestEmptyArray 
{
	public static void main(String args[])
	{
		// 0 means empty
		// 1 means non-empty 
		int[] Arr = {0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0}; 
		System.out.println("cool");
		int max = Longest(Arr);
		System.out.println("max=" + max);
	}
	// go right and go down
	public static int Longest(int[] Arr)
	{
		int max=0;
		if( Arr != null)
		{
			int len = Arr.length;
			int[] A = new int[len];

			if(Arr[0] == 0)
				A[0] = 1;
			else 
				A[0] = 0;

			for( int i=1; i<len; i++)
			{ if(Arr[i] == 0)
					A[i] = A[i-1]+1;	
			}
			
			for(int i=0; i<len; i++)
			{
				if(A[i] > max)
					max = A[i];
			}
		}		
		return max;
	}
}
import classfile.*;

public class LongestIncreasingSubsequence {
    public static void main(String[] args) {
        //test0();
        test1();
        test2();
        test3();
        test4();
    }

    static void test0() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        int m = LISDP(array);

        System.out.println();
        int recm = LISRecursion(array, len);
        int len2 = array.length;
        System.out.println("==========================");
        int recm2 = LISRecursion2(array, len2);
        System.out.println("max LIS=["+m+"]");
        System.out.println("max LISRecursion=["+recm+"]");
        System.out.println("max LISRecursion2=["+recm2+"]");
        System.out.println("==========================");
        LISTree(array, len2);

        Aron.end();
    }

    static void test1() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        Aron.printArray(array);
        int len = array.length;
        int max = LISRecursion(array, len);

        System.out.println("LISRecursion=["+ max +"]");
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        Aron.printArray(array);
        int len = array.length;
        int max = LISRecursion2(array, len);
        System.out.println("LISRecursion2=["+ max +"]");

        Aron.end();
    }

    static void test3() {
        Aron.beg();

        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        LISTree(array, len);

        Aron.end();
    }

    static void test4() {
        Aron.beg();

        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        LISRecursion_debug(array, len);

        Aron.end();
    }

    //L[i] = 1 + Max(L[i-1]) where j < i && arr[j] < arr[i]
    public static int LISRecursion_debug(Integer[] array, int len) {
        if(len == 1)
            return 1;
        else {
            int max = 1;
            for(int i=1; i < len; i++) {
                int m = LISRecursion_debug(array, i);
                //System.out.print("array["+(i-1)+"]="+array[i-1]+" array["+(len-1)+"]="+array[len-1]+"\n");
                System.out.print("("+ array[i-1] + " , "+ array[len-1] + ")");
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
                //System.out.println("max=["+max+"]");
            }
            System.out.println();
            return max;
        }
    }


    //Find the longest increasing subsequence integers
    //{2, 4, 1, 5} => 2->4->5
    //{2, 4, 1, 2, 3} => 1->2->3
    //L[i] = 1 + Max(L[i-1]) where j < i && arr[j] < arr[i]
    public static int LISRecursion(Integer[] array, int len) {
        if(len == 1)
            return 1;
        else {
            int max = 1;
            for(int i=1; i < len; i++) {
                int m = LISRecursion(array, i);
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
            }
            System.out.println();
            return max;
        }
    }

    public static void LISTree(Integer[] array, int len) {
        if(len == 1) {
            //System.out.println("["+array[len-1]+"]");
        } else {
            for(int i=1; i<len; i++) {
                LISTree(array, i);
                System.out.println("["+array[i-1]+"]->["+array[len-1]+"]");
            }
        }
    }
    public static int LISRecursion2(Integer[] array, int len) {
        int max = 1;
        if(len == 1)
            return max;
        else {
            for(int i=1; i<len; i++) {
                int m = LISRecursion2(array, len-1);
                System.out.print("array["+(i-1)+"]="+array[i-1]+" array["+(len-1)+"]="+array[len-1]+"\n");
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
            }
            System.out.println("-----------------------");
        }
        return max;
    }

    //Dynamic programming algorithm solves Longest Increasing Subsequence
    //with complexity O(n^2)
    public static int LISDP(Integer[] array) {
        int len = array.length;
        int[] maxlist = new int[len];
        for(int i=0; i<len; i++)
            maxlist[i] = 1;

        for(int i=1; i<len; i++) {
            for(int j=0; j<i; j++) {
                if(array[j] < array[i])
                    maxlist[i] = Math.max(1 + maxlist[j], maxlist[i]);
            }
        }

        int m = Integer.MIN_VALUE;
        for(int i=0; i<len; i++) {
            if(maxlist[i] > m)
                m = maxlist[i];
        }
        return m;
    }
}
    //Dynamic programming algorithm solves Longest Increasing Subsequence
    //with complexity O(n^2)
    public static int LISDP(int[] array)
    {
        int len = array.length;
        int[] maxlist = new int[len];
        for(int i=0; i<len; i++)
            maxlist[i] = 1;

        for(int i=1; i<len; i++)
        {
            for(int j=0; j<i; j++)
            {
                if(array[j] < array[i])            
                    maxlist[i] = Math.max(1 + maxlist[j], maxlist[i]);
            }            
        } 
        
        int m = Integer.MIN_VALUE;
        for(int i=0; i<len; i++)
        {
            if(maxlist[i] > m)
                m = maxlist[i];
        }
        return m;
    }
public class LongestPalindromeSubstringN2 {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        int maxlen = longestPalindromeSubstring("abkbf");
        System.out.println("maxlen="+maxlen);
    }
    public static int longestPalindromeSubstring(String str) {
        int maxlen = 0;
        if(str != null && str.length() > 1) {
            int len = str.length();
            maxlen = 1;
            for(int i=0; i<len; i++) {
                int currlen = 0;
                for(int j=0; j<len; j++) {
                    if(i+1 < len && str.charAt(i) == str.charAt(i+1)) {
                        if(i-j >=0 && i+1+j < len && str.charAt(i-j) == str.charAt(i+1+j)) {
                            if(j==0)
                                currlen +=1;
                            else {
                                if(currlen > maxlen)
                                    maxlen = currlen;
                            }
                        }
                    }
                    else {
                        if(i-j >= 0 && i+j < len && str.charAt(i-j) == str.charAt(i+j)) {
                            currlen += 2;
                            if(currlen > maxlen)
                                maxlen = currlen;
                        }
                    }
                }
            }
        }
        return maxlen;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*; 

class LowestCommonAncestor{
    public static Node prev = null;
    public static void main(String args[]) {
        test0_findNode();
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }
    public static void test0_findNode() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        Node r = findNode(b1.root, 17);
        Test.t(r.data, 17);

        Aron.end();
    }


    public static void test00() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);

        Node r = b1.getRoot();
        Node lca = LCABinTree(r, 12, 15);
        System.out.println("lca.data=" + lca.data);
        Aron.end();
    }

    public static void test0() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        Node lca = LCA2(b1.root, 1, 7);
        if(lca != null)
            Test.t(lca.data, 5);

        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        Node lca = LCA2(b1.root, 5, 7);
        Test.t(lca.data, 5);

        Aron.end();
    }

    public static void test2() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        b1.insert(15);
        b1.insert(18);
        b1.insert(19);
        b1.insert(35);
        Node lca = LCA2(b1.root, 15, 35);
        Test.t(lca.data, 15);
        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        b1.insert(15);
        Node lca = LCA2(b1.root, 12, 15);
        Test.t(lca.data, 12);
        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        Node lca = LCA2(b1.root, 10, 12);
        Test.t(lca.data, 10);

        Aron.end();
    }

    public static void test5() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(11);
        b1.insert(12);
        Node lca = LCA2(b1.root, 12, 10);
        Test.t(lca.data, 10);

        Aron.end();
    }


//    public static Node LCA(Node r, int value1, int value2) {
//        Node ret=null;
//        if(r != null) {
//            if((r.left != null && (value1 == r.left.data || value2 == r.left.data)) ||
//                    (r.right != null && (value1 == r.right.data || value2 == r.right.data)))
//                ret = r;
//            else if(value1 < r.data && value2 < r.data)
//                ret=LCA(r.left, value1, value2);
//            else if(value1 > r.data && value2 > r.data)
//                ret=LCA(r.right, value1, value2);
//            else
//                ret = r;
//        }
//        return ret;
//    }
//
    //[ file=findnode.html title=""
    public static Node findNode(Node root, int n){
        if(root != null){
            if( root.data == n)
                return root;
            Node l = findNode(root.left, n);
            Node r = findNode(root.right, n);
            if(l != null)
                return l;
            else if(r != null)
                return r;
        }
        return null;
    }
    //]

    //[ file=lcanew.html title=""
    public static Node LCA_BasedOnFindNode(Node r, int n1, int n2){
        if(r != null){
            if(r.data == n1 || r.data == n2)
                return r;

           Node left = LCA_BasedOnFindNode(r.left, n1, n2); 
           Node right = LCA_BasedOnFindNode(r.right, n1, n2);

           if(left != null && right != null)
               return r;
           else if(left != null)
               return left;
           else if(right != null)
               return right;
           
        }
        return null;
    }
    //]

    public static Node LCA(Node root, int n1, int n2){
        if(root != null){
            if( root.data == n1 || root.data == n2)
                return root;

            Node l = LCA(root.left, n1, n2);
            Node r = LCA(root.right, n1, n2);
            if(l != null && r != null)
                return root;
            else if(l != null)
                return l;
            else if(r != null)
                return r;
        }
        return null;
    }
    public static Node LCA2(Node r, Node n1, Node n2) {
        Node ret=null;
        if(r != null && n1 != null && n2 != null) {
            if( r.left != null && (r.left.data == n1.data || r.left.data == n2.data) ||
                    r.right != null && (r.right.data == n1.data || r.right.data == n2.data))
                ret = r;
            else if(n1.data < r.data && n2.data < r.data)
                ret=LCA2(r.left, n1, n2);
            else if(n1.data > r.data && n2.data > r.data)
                ret=LCA2(r.right, n1, n2);
            else
                ret=r;
        }
        return ret;
    }

    //LCA for Binary Tree
    public static Node LCABinTree(Node r, int value1, int value2) {
        if( r != null) {
            if( r.data == value1 || r.data == value2)
                return r;
            Node nl = LCABinTree(r.left, value1, value2);
            Node nr = LCABinTree(r.right, value1, value2);
            if( nl != null && nr != null)
                return r;
            else if( nl != null)
                return nl;
            else if( nr != null)
                return nr;

        }
        return null;
    }

    public static boolean equalBinaryTree(Node r1, Node r2) {
        if(r1==null && r2==null)
            return true;
        else if(r1 != null && r2 != null) {
            if(r1.data != r2.data)
                return false;
            if(!equalBinaryTree(r1.left, r2.left))
                return false;
            if(!equalBinaryTree(r1.right, r2.right))
                return false;
        } else
            return false;
        return true;
    }

    // lowest common ancestor, least common ancestor, lca, LCA
    public static Node LCA2(Node root, int n1, int n2) {
    if(root != null){
        if(root.data == n1 || root.data == n2)
            return root;

        Node l = LCA2(root.left, n1, n2);
        Node r = LCA2(root.right, n1, n2);
        if(l != null && r != null)
            return root;
        else if( l != null)
            return l;
        else if( r != null)
            return r;
    }
    return null;
    }

}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class  MagicSquareSolver{ 
 public static void main(String[] args) {
        System.out.println("Hello World!");
        MagicSquare mag = new MagicSquare();
        mag.test2();
    }
    static String remove(String str, int k){
        String s = "";
        for(int i=0; i<str.length(); i++){
            if(i != k)
                s += str.charAt(i) + "";
        }
        return s;
    }

    static void perm(String prefix, String str){
        if(str.length() == 0){
            System.out.println(prefix);
        }
        else{
            for(int i=0; i<str.length(); i++){
                perm(prefix + str.charAt(i), remove(str, i));
            }
        }
    }
}
import java.lang.reflect.InvocationTargetException;
 
import org.codehaus.commons.compiler.CompileException;
import org.codehaus.janino.ExpressionEvaluator;
 
public class TryCompiler{
 
    public static void
    main(String[] args) throws CompileException, InvocationTargetException {
 
        // Now here's where the story begins...
        ExpressionEvaluator ee = new ExpressionEvaluator();
 
        // The expression will have two "int" parameters: "a" and "b".
        ee.setParameters(new String[] { "a", "b" }, new Class[] { int.class, int.class });
 
        // And the expression (i.e. "result") type is also "int".
        ee.setExpressionType(int.class);
 
        // And now we "cook" (scan, parse, compile and load) the fabulous expression.
        ee.cook("a + b");
 
        // Eventually we evaluate the expression - and that goes super-fast.
        int result = (Integer) ee.evaluate(new Object[] { 19, 23 });
        System.out.println(result);
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Majority 
{
	public static void main(String args[])
	{
	  int[] A={2, 3, 2}; 
		System.out.println(majority(A));
	}
	public static boolean majority(int[] A)
	{
		boolean ret = false;
		if( A != null)
		{
			int len = A.length;
			if(len == 1)
				ret = true;
			else if(len > 1)
			{
				int c=1;
				int mj=0;
				for(int i=1; i<len; i++)
				{
					if(A[mj] == A[i])
					 c++; 
					else
					{ c--;
						if(c == 0)
						{ mj = i; c=1;}
					}
				}
				int count=0;
				for(int i=0; i<len; i++)
				{
					if(A[mj] == A[i])
						count++;
				}
				if(count > len/2)
					ret = true;
			}
		}
		return ret;
	}
}

import java.io.*;
import java.util.*;
import classfile.Print;
import classfile.Aron;

public class ManhattanProblem {
    public static void main(String[] args) {
        Print.pl("Hello World!");
        int[][] array2d = new int[3][2];

        Print.pl("array2.length=" + array2d.length);
        Print.pl("array2[0].length="+array2d[0].length);

        for(int i=0; i<3; i++) {
            for(int j=0; j<2; j++)
                Print.pl("["+array2d[i][j]+"]");
            Print.pl("");
        }

        test8();
        test9();
        test10();
        test11();
        test12();
    }
    
    public static int[][] readFile(){
        int[][] array2d = null;
        try {
            BufferedReader bufferReader = new BufferedReader(new InputStreamReader(System.in));
            int count =0;
            int numRow = 0;
            String line = null;
            int row = 0;
            while((line = bufferReader.readLine()) != null){
                String[] array = line.split(" ");
                if(count == 0){
                    if(array.length > 0){
                        numRow = Aron.toInt(array[0]);
                        array2d  = new int[numRow][numRow];
                    }
                } 
                else{
                    if(numRow != array.length){
                        System.out.print("ERROR"); 
                        return null;
                    }else{
                        for(int i=0; i<array.length; i++){
                            array2d[row][i] = Integer.parseInt(array[i]);        
                        }
                    }
                    row++;
                }
                count++;
            }
        } catch (Exception e) {
        }
        return array2d;
    }

    public static void test8() {
        Print.pl("test8");
        int[][] arr = { 
            {1,3,3},
            {0,3,9},
            {0,3,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 3;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                ret = manhattan(arr, h, w, k, arr[h][w]); 
                Print.pl("ret =" + ret);
            }
        }
        Print.pl("--ret =" + ret);
    }

    public static void test12() {
        List<ArrayList<Integer>> list = Aron.readFileInt("/tmp/ff.x");
        Print.printList2d(list);
    }
    public static void test11() {
        Print.pl("test11");
        int[][] arr = { 
            {0,3,1},
            {0,1,4},
            {7,1,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 4;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                Print.pl("ret =" + ret);
            }
        }
        Print.pl("--ret =" + ret);
    }

    public static void test10() {
        Print.pl("test10");
        int[][] arr = { 
            {1,3,6},
            {0,4,4},
            {7,9,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 4;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                Print.pl("ret =" + ret);
            }
        }
        Print.pl("--ret =" + ret);
    }

    public static void test9() {
        Print.pl("test9");
        int[][] arr = { 
            {1,3,6},
            {0,4,4},
            {7,9,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 1;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                Print.pl("ret =" + ret);
            }
        }
        Print.pl("--ret =" + ret);
    } 
    //[file=manhattan.html title=""
    public static boolean manhattan(int[][] arr, int h, int w, int k, int num){
        final int visited = -1000; 
        boolean ret0 = false;
        boolean ret1 = false;
        boolean ret2 = false;
        boolean ret3 = false;
        boolean ret4 = false;
        int height = arr.length;
        int width = arr[0].length;

        if( k == 0){
            ret0 = num == arr[h][w];
        }else if(arr[h][w] != visited){
            int tmp = arr[h][w];
            arr[h][w] =  visited;
            if(w + 1 < width){
                 arr[h][w] = visited;
                 ret1 = manhattan(arr, h, w+1,k-1, num);
                 arr[h][w] = tmp;
                 if(ret1)
                     return ret1;
             }

            if(w - 1 >= 0){
                 arr[h][w] = visited;
                 ret2 = manhattan(arr,  h, w-1,k-1, num);
                 arr[h][w] = tmp;
                 if(ret2)
                     return ret2;
             }

            if(h - 1 >= 0){
                 ret3 = manhattan(arr,  h-1, w, k-1, num);
                 arr[h][w] = tmp;
                 if(ret3)
                     return ret3;
             }

             if(h + 1 < height){
                 ret4 = manhattan(arr, h+1, w, k-1, num);
                 arr[h][w] = tmp;
                 if(ret4)
                     return ret4;
             }
        }
        return ret0 || ret1 || ret2 || ret3 || ret4;
    }
}
import java.io.*;
import java.util.*;
class Mapdemo
{
	public static void main(String args[])
	{
		Map ml = new HashMap();		
		ml.put("cool", "89");
		System.out.println(ml);

		if(ml.containsKey("cool"))
		{
			System.out.println("yup");
		}
		else
		{
			System.out.println("no");
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MatchNum{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
    }
    public static void test0(){
        Aron.beg();
        String str = "12";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String str = "1200";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        String str = "a";
        boolean isNum = isNumeric(str);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        String str = "0314";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);
        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        String str = "-123";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test8(){
        Aron.beg();
        String str = "+12";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test9(){
        Aron.beg();
        String str = "+";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test10(){
        Aron.beg();
        String str = "-";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test11(){
        Aron.beg();
        String str = "+-";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }

    // is positive Integer from [-n -1 0 1 n] 
    public static boolean isNumeric(String str){
        //return str.matches("[1-9][0-9]+");
        return str.matches("[-+]?[1-9][0-9]*|0");
    }
} 

public class MatrixDiagonal {
    public static void main(String[] args) {
        int[][] array = { {1, 2, 3, 4},
            {2, 3, 4, 5},
            {6, 7, 9, 8},
            {3, 2, 1, 2}
        };
        int len = array.length;
        for(int i=0; i<len; i++) {
            for(int j=0; j<len; j++) {
                System.out.print("["+array[i][j]+"]");
            }
            System.out.println("");
        }

        System.out.println("Print all diagonals of matrix");
        printDiagonal(array);
    }
    //Given square matrix
    public static void printDiagonal(int[][] array) {
        if(array != null) {
            int len = array.length;
            for(int i=0; i<2*len-1; i++) {

                for(int j=0; j<len && j+i<len; j++) {
                    if(j == j+i) {
                        System.out.print("["+array[j][j]+"]");
                    }
                }
                if(i==0)
                    System.out.println("");
                for(int j=0; j<len && j+i < len; j++) {
                    if(j < j+i) {
                        System.out.print("["+array[j][j+i]+"]");
                    }
                }
                if(i != 0)
                    System.out.println("");
                for(int j=0; j<len && j+i<len; j++) {
                    if(j < j+i) {
                        System.out.print("["+array[j+i][j]+"]");
                    }
                }
                if(i != 0)
                    System.out.println("");
            }
        }
    }
}
public class MatrixMulti {
    public static void main(String[] args) {
        test0();
        test1();
    }

    // multiply matrix, mul matrix, mult matrix
    public static int[][] multiply(int[][] A, int[][] B) {
        int[][] C = null;
        if( A != null && B != null) {
            int alen = A.length;
            int blen = B.length;
            int clen = alen;
            C = new int[alen][alen];
            for(int c = 0; c < clen; c++) {
                for(int i = 0; i < alen; i++) {
                    int s = 0;
                    for(int j = 0; j < blen; j++) {
                        s += A[i][j]*B[j][c];
                    }
                    C[i][c] = s;
                }
            }
        }
        return C;
    }

    //[ file=matrixmul.html title=""
    // Better way to multiply matrix, mul matrix, mult matrix
    public static int[][] multiply2(int[][] arr1, int[][] arr2) {
        int[][] arr3 = null;
        if( arr1 != null && arr2 != null) {
            int height = arr1.length;
            int width = arr1[0].length;
            int len = height;
            arr3 = new int[height][height];
            for(int k = 0; k < len; k++) {
                for(int i = 0; i < height; i++) {
                    for(int j = 0; j < width; j++) {
                        arr3[i][j] += arr1[i][k]*arr2[k][j];
                    }
                }
            }
        }
        return arr3;
    }
    //]
    
    static void test0(){
        System.out.println("---------------------------------\n");
        int[][] A = {{1}};
        int[][] B = {{2}};
        int[][] C = multiply2(A, B);
        Aron.printArray2D(C);

        System.out.println("---------------------------------\n");
    }
    static void test1(){
        System.out.println("---------------------------------\n");
        int[][] A = {{1, 1},
                    {0, 1}
        };
        int[][] B = {{2, 0},
                    {0, 3}
        };
        int[][] C = multiply2(A, B);
        Aron.printArray2D(C);
        System.out.println("---------------------------------\n");
    }
}
public class MatrixMultiNew 
{
    public static void main(String[] args)
    {
        System.out.println("New Algorithm for Matrix Multiplication!");
        int[][] A = {{1, 2},
                     {3, 4}}; 
        int[][] B = {{2, 3},
                     {4, 5}}; 

        int[][] C = Multiply(A, B);
        for(int i=0; i<C.length; i++)
        {
            for(int j=0; j<C.length; j++)
            {
                System.out.print("["+C[i][j]+"]");
            }
            System.out.println();
        }
    }
    public static int[][] Multiply(int[][] A, int[][] B)
    {
        int[][] C = null;
        if(A != null && B != null)
        {
            C = new int[A.length][A.length];
            for(int i=0; i<A.length; i++)
            {
                for(int j=0; j<A.length; j++)
                {
                    for(int k=0; k<A.length; k++)
                    {
                        
                         C[k][j] += A[k][i]*B[i][j];
                    }
                }
            }
        }
        return C;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;


// max sum, max continuous sum, consecutive sum, max consecutive sum 
// maximum continuous sum, maximum consecutive sum, max array sum, max sum array
// max sum with index, 
// max sum index, first index, last index, first last index
// maxsum
public class MaxConsecutiveArray{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();

        test00();
        test11();
        test12();
        test_maxConsecutiveSum_1();
        test_maxConsecutiveSum_2();
        test_maxConsecutiveSum_3();
        test_maxConsecutiveSum_4();
        test_maxConsecutiveSum_5();
    }
    //[ file=consecutive.html title=""
    //  4, -5, 9, 7, -8, 3
    //--------------------------------------------------------------------------------
    // m = 0
    // max = 0
    //--------------------------------------------------------------------------------
    // m = max(m, m+3) = 3
    // max = 3
    //--------------------------------------------------------------------------------
    // m = max(m, m+-8) = -5 = 0
    // max = 3
    //--------------------------------------------------------------------------------
    // m = max(m, m+7) = 7
    // max = 7
    //--------------------------------------------------------------------------------
    // m = max(m, m+9) = 16
    // max = 16
    //--------------------------------------------------------------------------------
    // m = max(m, m -5) = 11
    // max = 16
    //--------------------------------------------------------------------------------
    // m = max(m, m + 4) = 15
    // max = 16
    //-------------------------------------------------------------------------------- 
    public static int maxConsecutive(int[] arr) {
        int m = 0, max = 0;
        int startIndex = 0;
        int endIndex   = 0;
        if(arr != null) {
            for(int i=0; i<arr.length; i++) {
                if(m + arr[i] > 0){
                    m = Math.max(m + arr[i], arr[i]);

                    if(m > max){
                        max = m;
                    }
                }
                else{
                    m = 0;
                }
            }
        }
        return max;
    }
    //]

    //[ file=maxsumnegative.html  title=""
    // wrong code
    public static int maxConsecutiveNegative(int[] arr) {
        int max_so_far = arr[0], currMax = arr[0];
        if(arr != null) {
            for(int i=1; i<arr.length; i++) {
                max_so_far = Math.max(arr[i], currMax + arr[i]);
                currMax = Math.max(currMax, max_so_far);
            }
        }
        return currMax;
    }
    //]

    // -4, 2 
    // 2, 
    // -4, 2, -1, 5
    // -4, 2, -3, 5
    // first and last index
    static int maxConsecutiveSum(int[] arr){
        int max = 0;
        if(arr != null){
            int len = arr.length;
            if(len > 0){
                max = arr[0];
                int sum = arr[0];
                int first = 0;
                int second = 0;
                int tmpFirst = 0;
                for(int i=1; i<len; i++){
                    if(sum < 0){
                        sum = 0;
                        tmpFirst = i;
                    }
                    sum += arr[i];
                    if(max < sum){
                        max = sum;
                        first = tmpFirst;
                        second = i;
                    }
                }
                Print.pb("first=" + first);
                Print.pb("second=" + second);
            }
        }
        return max;
    } 

    static void test0() {
        Aron.beg();
        int[] arr = {1, -2, 8, 9, -4, 5};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 18);
        Aron.end();
    }

    static void test1() {
        Aron.beg();
        int[] arr = {1};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 1);
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        int[] arr = {1, -9};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 1);
        Aron.end();
    }
    static void test3() {
        Aron.beg();
        int[] arr = {4, 1, -9, 10};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 10);
        Aron.end();
    }
    static void test4() {
        Aron.beg();
        int[] arr = {4, 1, -9, 10, 4, -5, 7};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 16);
        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        int[] arr = {2, -3, -2, 4, -3, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        int[] arr = {2, -3, 2, -2, 5, -3, 2, 1}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        int[] arr = {-2, 0, 0, 7, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 7);

        Aron.end();
    }
    public static void test8(){
        Aron.beg();
        int[] arr = {-2, -3, -1, -4, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, -1);

        Aron.end();
    }
    public static void test00(){
        Aron.beg();
        int[] arr = {-2, -3, -1, -4, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, -1);

        Aron.end();
    }
    public static void test11(){
        Aron.beg();
        int[] arr = {-2, 0, 0, 7, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, 7);

        Aron.end();
    }
    public static void test12(){
        Aron.beg();
        int[] arr = {-3, 2, -4, 9}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, 9);

        Aron.end();
    }

    public static void test_maxConsecutiveSum_1(){
        Aron.beg();
        int[] arr = {-4, 2, -3, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_2(){
        Aron.beg();
        int[] arr = {-4, 2, -1, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_3(){
        Aron.beg();
        int[] arr = {-4, 2}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 2);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_4(){
        Aron.beg();
        int[] arr = {2}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 2);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_5(){
        Aron.beg();
        int[] arr = {2, 3}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 5);

        Aron.end();
    }
}

public class MaxContinuous 
{
    public static void main(String[] args)
    {
        int[] array = {2, 4, 7, 1, 5, 8, 10, 11, 12, 13, 11, 14, 15, 16, 0, 1, 2, 3, 5, 6, 7};
        maxContinuous(array);
    }
    public static void maxContinuous(int[] array)
    {
        if(array != null)
        {
            int len = array.length;
            int[] arr = new int[len];
            for(int i=0; i<len; i++)
                arr[i] = 1;

            int maxIndex = 0;
            int max = arr[0];
            for(int i=1; i<len; i++)
            {
                if(array[i] > array[i-1])
                    arr[i] = arr[i-1] + 1;

                if(arr[i] > max)
                {
                    max = arr[i];
                    maxIndex = i;
                }
            }
            System.out.println("beginIndex=" + (maxIndex - max + 1));
            System.out.println("maxIndex=" + maxIndex);
            System.out.println("max=" + max);
        }
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.List;
import java.util.*;
import java.lang.Math;

import classfile.*;

public class MaxContinuousList {
    public static void main(String[] args) {
        test8();
        test9();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
    }
    static void test8() {
        Aron.beg();
        Integer[] arr = {2, -5, 8, -2, 3};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test9() {
        Aron.beg();
        Integer[] arr = {-1, -5, 8, -4, 5, -2, 3, -2};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test10() {
        Aron.beg();
        Integer[] arr = {-1, -5, 8};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void test11() {
        Aron.beg();
        Integer[] arr = {6, -5, 8};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test12() {
        Aron.beg();
        Integer[] arr = {3, -4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test13() {
        Aron.beg();
        Integer[] arr = {-4, 5};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test14() {
        Aron.beg();
        Integer[] arr = {-4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test15() {
        Aron.beg();
        Integer[] arr = {4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test16() {
        Aron.beg();
        Integer[] arr = {4, 0};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test17() {
        Aron.beg();
        Integer[] arr = {0, 4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test18() {
        Aron.beg();
        Integer[] arr = {-2, 4, 3, -8, 3};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void getAllPaths(Node n, Map<Node, Node> map, int num, List<Node> list) {
        if(n.data == num) {
            for(Node node : list) {
                System.out.println("[" + node.data + "]");
            }
            System.out.println("\n---------------------------------");
        } else {
            Node curr = map.get(n);
            while(curr != null) {
                list.add(curr);
                getAllPaths(curr, map, num, list);

                if(list.size() > 0)
                    list.remove(list.size()-1);

                curr = curr.next;
            }
        }
    }

    //[ file=maxlistindex.html title=""
    //
    // only work when not all elem are negative
    //
    // Sun Sep 25 18:03:40 PDT 2016
    // Fix bug: start gets the wrong index
    // 
    static int maxList(Integer[] arr) {
        int tmp_start = 0;
        int end = 0;
        int start = 0;
        int max = 0;
        int sum = 0;
        for(int i=0; i<arr.length; i++) {
            if(sum == 0) {
                tmp_start = i;
            }

            if(sum + arr[i] > 0) {
                int m = Math.max(arr[i], sum + arr[i]);
                if(m > max) {
                    max = m;
                    start = tmp_start;
                    end = i;
                }
                sum += arr[i];
            } else {
                sum = 0;
            }
        }
        Print.p("start[" + start + "]");
        Print.p("end  [" + end + "]");
        return max;
    }
    //]
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class MaxDepthIteration 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(10);
		
		b1.Insert(5);
		b1.Insert(1);
		b1.Insert(7);
		b1.Insert(9);
		
		
		
		
		int c = MaxDepthIteration(b1.getRoot());
		System.out.println("c=" + c);
	}
	//in order traversal using iteration
	public static int MaxDepthIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		int max=0;
		int c=0;
		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					st.push(cur);
					c++;
					if(c>max)
						max=c;
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					if(no.right == null) //last traversal node has to be the right node observation from the recursive Inorder traversal 
						c--;
					System.out.println("no.data=" + no.data);
					cur = no.right;
				}
			}
		}
		return max;
	}
	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MaxDiff{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0() {
        Aron.beg();
        int[] arr = {2, 4}; 
        int max = maxDiff(arr);
        Test.t(max, 2);
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        int[] arr = {2, 4, 7, 1, 7, 2}; 
        int max = maxDiff(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        int[] arr = {4, 1, 7}; 
        int max = maxDiff(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        int[] arr = {15, 10, 17, 1, 9}; 
        int max = maxDiff(arr);
        Test.t(max, 8);

        Aron.end();
    }

    //[file=maxdiff.html title=""
    // [2, 4, 7, 1, 7, 2]
    // [4, 2] => 0
    // [1, 3, 4]
    // [3, 1, 7]
    public static int maxDiff(int[] arr){
        int maxDiff = 0;
        if(arr != null && arr.length > 1){
            int len = arr.length;
            int min = arr[0];
            for(int i=1; i<len; i++){

                if(arr[i-1] < min)
                    min = arr[i-1];
                    
                if(arr[i] - min > maxDiff)
                    maxDiff = arr[i] - min;
            } 
        }
        return maxDiff;
    }
    //]
}

import java.io.*;
import java.lang.String;
import java.util.*;
class MaxDistance {
    public static void main(String args[]) {
        int[] Arr = {10, 11, 2, 1, 0, 4};
        int max = MaxDistance(Arr);
        System.out.println("max=" + max);
    }


    public static int MaxDistance(int[] Arr) {
        int max_d = 0;
        if( Arr != null) {
            int len = Arr.length;
            int[] InxArr = new int[len];

            if(len > 0) {
                InxArr[0] = 0;
                int c=1;
                for(int i=1; i<len; i++) {
                    if(Arr[i-1] > Arr[i]) {
                        InxArr[c] = i;
                        c++;
                    }
                }
                int k=0;
                for(int i=0; i<len; i++) {
                    for(int j=k; j<c; j++) {
                        int d = len-1-i - InxArr[c-1-j];
                        if(d > 0 && Arr[len-1-i] > Arr[InxArr[c-1-j]]) {
                            if(d > max_d) {
                                max_d = d;
                                k=j;
                            }
                        }
                    }
                }
            }
        }
        return max_d;
    }
}
public class MaxDistanceThreeSortIntegers
{
    public static void main(String[] args)
    {
        System.out.println("hello world!");
        int[] arr1 = {1, 4, 500, 600};
        int[] arr2 = {2, 5, 10, 500};
        int[] arr3 = {6, 20, 30, 500, 501};

        printArray(arr1);
        printArray(arr2);
        printArray(arr3);
        int min = findMaxAbsSum(arr1, arr2, arr3);
        System.out.println("min["+min+"]");
    }
    public static int findMaxAbsSum(int[] arr1, int[] arr2, int[] arr3)
    {
        int gmin = Integer.MAX_VALUE;
        if(arr1 != null && arr2 != null && arr3 != null)
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len3 = arr3.length;
            int inx1 =0, inx2 = 0, inx3 = 0;
            while(inx1 < len1  && inx2 < len2 && inx3 < len3)
            {
                int min = Math.min(Math.min(arr1[inx1], arr2[inx2]), arr3[inx3]);
                int max = Math.max(Math.max(arr1[inx1], arr2[inx2]), arr3[inx3]);
                int sum = 2*(max - min);
                if(sum == 0)
                    return 0;

                if(sum < gmin)
                    gmin = sum;

                if(min == arr1[inx1]) inx1++;
                if(min == arr2[inx2]) inx2++;
                if(min == arr3[inx3]) inx3++;
            }
        }    
        return gmin;
    }
    public static void printArray(int[] arr)
    {
        if(arr != null)
        {
            for(int i=0; i<arr.length; i++)
                System.out.println("arr["+i+"]["+arr[i]+"]");
        }
        System.out.println("===============");
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// graph with weight
// maximum path in graph, max path in graph, max path tree, 
// maximum graph in tree, maxpath, path tree
//
// gx /Library/WebServer/Documents/zsurface/image/maxpath.png
public class MaxPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath.png
    public static void test0(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 3, 0},
            {0, 0, 7, 3},
            {0, 0, 0, 6},
            {0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 3;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 14);
    
        Aron.end();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath2.png
    public static void test1(){
        Aron.beg();

        int[][] arr2d = {
            {0, 3, 7, 7, 0},
            {0, 0, 9, 2, 4},
            {0, 0, 0, 20,0},
            {0, 0, 0, 0, 9},
            {0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 4;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 41);

        Aron.end();
    }

    public static void test2(){
        Aron.beg();

        int[][] arr2d = {
            {0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 0;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 0);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();

        int[][] arr2d = {
            {0, 3},
            {0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 1;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 3);

        Aron.end();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath.png
    public static int mathPathGraph(int[][] arr, int n1, int n2, int width){
        int max = 0;
        if(n1 != n2){
            for(int i=0; i<width; i++){
                if(n1 != i){
                    if(arr[n1][i] > 0){
                        int m = mathPathGraph(arr, i, n2, width) + arr[n1][i]; 
                        max = Math.max(max, m);
                    }
                }
            } 
        }
        return max;
    }

    // max path in tree, max path tree, maxpath binarytree
    public static int maxPathTree(Node r){
        if(r != null){
            int left = maxPathTree(r.left);
            int right = maxPathTree(r.right);
            return Math.max(left, right) + r.data;
        }
        return 0;
    }
} 

import java.io.*;
import java.lang.*;
import java.util.*;

class MaxRepeatingChar 
{
	public static void main(String args[])
	{
		int c = maxrepeating("aacc");
		System.out.println(c);
	}
	public static int maxrepeating(String str)
	{
		int max = 0;
		if( str != null && str.length() > 0)
		{
			int len=str.length();
			int c=1; max=1;
			if(len > 1)
			{
				for(int i=1; i<len; i++)
				{
					if(str.charAt(i-1) == str.charAt(i))
					{ c++; if(c > max) max = c; }
					else
						c=1;
				}
			}
		}
		return max;
	}
}

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class MaxSumPathBT 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        
        System.out.println("Before Swap");
        inorder(b1.getRoot());

        System.out.println("============");
        System.out.println("After Swap");

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        //swap(199, 16, b1.getRoot(), first, second);
        
        System.out.println("Max Sum in a path=" + MaxSumPath(b1.getRoot()));
        inorder(b1.getRoot());
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }
    
    public static int MaxSumPath(Node node)
    {
        if(node != null)
        {
            int left = MaxSumPath(node.left) + node.data;
            int right = MaxSumPath(node.right) + node.data;
            if(left > right)
                return left;
            else
                return right;  
        }
        else
        {
            return 0;
        }
    }
}
public class MaxTupleInAscendingOrder 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int[] findMax(int[] arr)
    {
        if( arr != null)
        {
            int[] tuple = new int[3];
            int count = 0;
            tuple[0] = arr[0];
            for(int i=1; i<arr.length; i++)
            {
                for(int j=0; j<=count; j++)
                {
                    if(tuple[j] < arr[i])    
                }
            }
        }
    }
}
public class MazeFindPath 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        /*
        int[][] maze = { {0,0, 4, 4},
                         {4,0, 0, 0},
                         {4,0, 4, 0},
                         {4,0, 0, 3}
                        }; 
        int row = 0;
        int col = 0;
        for(int i=0; i<maze.length; i++)
        {
            for(int j=0; j<maze.length; j++)
            {
                System.out.print("["+maze[i][j]+"]");
            }
            System.out.println();
        }

        int[] path = new int[50];
        int level = 0;
        //findAllPath(maze, row, col, path, level);
        //findPath(maze, row, col);
        int min=100;
        int[] minPath = new int[100];
        int m = findTheShortestPath(maze, col, row, path, minPath, level, min);
        for(int i=0; i<m; i++)
        {
            int c = minPath[i]/maze.length;
            int r = minPath[i]%maze.length;
            System.out.println("["+c+"]["+r+"]");
        }
        */

        test1();

    }

    public static boolean findPath(int[][] maze, int row, int col)
    {
        if(maze != null && row < maze.length && col < maze.length)
        {
               if(maze[row][col] == 3)
               {
                   System.out.println("["+row+"]["+col+"]");
                   return true;
               }
               if(maze[row][col] == 0)
               {
                    maze[row][col] = 2;
                    if(findPath(maze, row, col+1))
                    { 
                       System.out.println("["+row+"]["+col+"]");
                       return true;
                    }
                    if(findPath(maze, row+1, col))
                    {
                       System.out.println("["+row+"]["+col+"]");
                       return true;
                    }
               }
        }
        return false;
    }

    public static void findAllPath(int[][] maze, int row, int col, int[] path, int level)
    {
        if(maze != null && row < maze.length && col < maze.length)
        {
               if(maze[row][col] == 3)
               {
                   path[level] = row*maze.length+col;
                   for(int i=0; i<=level; i++){
                       int r = path[i]/maze.length;
                       int c = path[i]%maze.length; 
                       System.out.println("["+r+"]["+c+"]");
                   }
                   System.out.println("");
               }
               if(maze[row][col] == 0)
               {
                   path[level]=row*maze.length + col;
                    findAllPath(maze, row, col+1, path, level+1);
                    findAllPath(maze, row+1, col, path, level+1);
               }
        }
    } 
    public static int findTheShortestPath(int[][] maze, int col, int row, int[] path, int[] minPath, int level, int min)
    {
        if( maze != null)
        {
            if(maze[col][row] == 3)
            {
                path[level] = col*maze.length+row;
                System.out.println("{"+col+"}{"+row+"}");
                System.out.println("minPath["+level+"]="+path[level]);
                if(level < min)
                {
                    min = level;                    
                    for(int i=0; i<=level; i++)
                    {
                        minPath[i] = path[i];
                    }
                }
            }
            else if(maze[col][row] == 0)
            {
                path[level] = col*maze.length+row;
                System.out.println("{"+col+"}{"+row+"}");
                maze[col][row] = 2;
                int r = 100, d = 100, l = 100, u = 100;
                if(row+1 < maze.length)
                    r = findTheShortestPath(maze, col, row+1, path, minPath, level+1, min);
                if(col+1 < maze.length)
                    d = findTheShortestPath(maze, col+1, row, path, minPath, level+1, min);
                if(row-1 > 0)
                    l = findTheShortestPath(maze, col, row-1, path, minPath, level+1, min);
                if(col-1 > 0)
                    u = findTheShortestPath(maze, col-1, row, path, minPath, level+1, min);
                min = Math.min(Math.min(r, d), Math.min(l, u));
            }
        }
        return min;
    }
    public static void test1()
    {
        int[][] maze = { 
                         {0,0, 4, 4, 0, 0},
                         {0,0, 0, 0, 0, 0},
                         {0,4, 0, 4, 4, 0},
                         {0,4, 0, 4, 0, 0},
                         {0,0, 0, 0, 4, 0},
                         {0,4, 4, 0, 0, 3}
                        }; 
        int row = 0;
        int col = 0;
        for(int i=0; i<maze.length; i++)
        {
            for(int j=0; j<maze.length; j++)
            {
                System.out.print("["+maze[i][j]+"]");
            }
            System.out.println();
        }

        int[] path = new int[100];
        int[] minPath = new int[100];
        int level = 0;
        int min=100;

        int m = findTheShortestPath(maze, col, row, path, minPath, level, min);
        System.out.println("m["+m+"]");
        for(int i=0; i<=m; i++)
        {
            int c = minPath[i]/maze.length;
            int r = minPath[i]%maze.length;
            System.out.println("["+c+"]["+r+"]");
        }
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MedianOfStream{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        Integer[] arr = {2, 1, 3, 4, 5, 0};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Integer[] arr = {2, 1};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        Integer[] arr = {1, 2};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        Integer[] arr = {2};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }

    // test [2, 1] = > [1, 2], pivot = [0]
    public static void quickSort(Integer[] arr, int lo, int hi){
        if(lo < hi){
            int pivot = partition(arr, lo, hi);
            quickSort(arr, lo, pivot -1);
            quickSort(arr, pivot + 1, hi);
        }
    }

    public static int partition(Integer[] arr, int lo, int hi){
        int big = lo;
        int pivot = arr[hi];
        for(int i=lo; i<=hi; i++){
            if(arr[i] <= pivot){
                swap(arr, big, i);
                if(i < hi)
                    big++;
            }
        }
        return big;
    }
    public static void swap(Integer[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    
    public static void Median(int[] arr){
                    
    }
} 

import java.util.*;

public class MergeArrayLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("merge array and merge linkedlist");
    }

    public static int[] merge(int[] arr1, int[] arr2) {
        int[] arr = null; 
        if(arr1 == null)
            return arr2;
        else if(arr2 == null)
            return arr1;
        else {
            int len1 = arr1.length;
            int len2 = arr2.length;
            arr = new int[len1+len2];
            int inx1 = 0;
            int inx2 = 0;
            int k=0;

            while(inx1 < len1 || inx2 < len2) {
                if(inx1 >= len1) {
                    arr[k] = arr1[inx2];
                    inx2++;
                }
                else if(inx2 >= len2) {
                    arr[k] = arr2[inx1];
                    inx1++;
                }
                else {
                    if(arr1[inx1] < arr2[inx2]) {
                        arr[k] = arr1[inx1];
                        inx1++;
                    }
                    else if(arr1[index] == arr2[inx]){
                        arr[k] = arr1[inx1];
                        k++;
                        inx1++;
                        arr[k] = arr2[inx2];
                        k++;
                        inx2++;
                    }
                    else {
                        arr[k] = arr2[inx2];
                        inx2++;
                    }
                }
                k++;
            }
        }
        return arr;
    }
    public static Node mergeList(Node s1, Node s2)
    {
        Node curr = null;
        Node head = curr;
        while( s1 != null || s2 != null)
        {
            if(s1 == null)
            {
                if(curr == null)
                   head = curr = s2;
                else
                {
                    curr.next = s2;
                    curr = curr.next;
                }
                s2 = s2.next;
            }
            else if(s2 == null)
            {
                if(curr == null)
                    head = curr = s1;
                else
                {
                    curr.next = s1;
                    curr = curr.next;
                }
                s1 = s1.next;
            }
            else
            {
                if(s1.data < s2.data)
                {
                    if(curr == null)
                        head = curr = s1;
                    else
                    {
                        curr.next = s1;
                        curr = curr.next;
                    }
                    s1 = s1.next;
                }
                else
                {
                    if( curr == null)
                        head = curr = s2;
                    else
                    {
                        curr.next = s2;
                        curr = curr.next;
                    }
                    s2 = s2.next;
                }
            }
        }
        return head;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MergeExtraSpace{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    static void test0(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 7, 9, 0}; 
        Integer[] arr2 = {3}; 
        int len = 4;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test1(){
        Aron.beg();
        Integer[] arr1 = {4, 0}; 
        Integer[] arr2 = {3}; 
        int len = 1;



        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0}; 
        Integer[] arr2 = {3}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {3, 9}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {4, 5}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {4, 5}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge2(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {2, 3}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge2(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    //[ file=mergespace.html title=""
    // 2, 4, [] []
    // [2] 3, {4}
    // [3]x
    public static void merge(Integer[] arr1, int len, Integer[] arr2){
        if(arr1 != null && arr2 != null){
            int len2 = arr2.length;
            for(int i=len-1; i>=0; i--){
                arr1[i+len2] = arr1[i];    
            }
            int p1 = len2;
            int p2 = 0; 
            int k = 0;

            while(p2 < len2 || p1 < len + len2){
                if(p2 >= len2){
                    arr1[k] = arr1[p1];
                    p1++;
                }else if(p1 >= len + len2){
                    arr1[k] = arr2[p2];
                    p2++;
                }else{
                    if(arr1[p1] < arr2[p2]){
                        arr1[k] = arr1[p1];
                        p1++;
                    }else{
                        arr1[k] = arr2[p2];
                        p2++;
                    }
                }
                k++;
            }
        }
    } 

    // [2][]
    // [3]
    public static void merge2(Integer[] arr1, int len1, Integer[] arr2){
        if(arr1 != null && arr2 != null){
            if(arr1.length > 0 || arr2.length > 0){
                int len2 = arr2.length;
                int k = len2 + len1 - 1;
                int p1 = len1 - 1;
                int p2 = len2 - 1;

                while(p1 >= 0 || p2 >= 0){ 
                    if(p1 < 0){
                        arr1[k] = arr2[p2];
                        p2--;
                    }else if(p2 < 0){
                        arr1[k] = arr1[p1];
                        p1--;
                    }else{
                        if(arr1[p1] > arr2[p2]){
                            arr1[k] = arr1[p1];
                            p1--;
                        }else{
                            arr1[k] = arr2[p2];
                            p2--;
                        }
                    }
                    k--;
                }
            }
        }
    }

    //]
} 
package classfile;

import java.io.*;
import java.lang.String;
import java.util.*;

class MergeHalfList{
    public static void main(String args[]) {
    }

    public static Node mergeHalf(Node head) {
        Node curr = head;
        Queue<Node> q0 = new LinkedList<Node>();
        Queue<Node> q1 = new LinkedList<Node>();
        int count = 0;
        while(curr != null) {
            System.out.println("curr[" + curr.data+"]");
            q1.add(new Node(curr.data));
            curr = curr.next;
        }

        int halfsize = q1.size()/2;
        int size = q1.size();
        System.out.println("q1size[" + q1.size()+"]");
        System.out.println("q1size/2[" + halfsize +"]");
        for(int i=0; i<= size/2; i++) {
            Node node = q1.remove();
            System.out.println("node[" + node.data+"] i=[" + i+"]");
            q0.add(new Node(node.data));
        }

        System.out.println("q0.size[" + q0.size()+"]");
        Node prevPair = null;
        Node currPair = null;
        Node newHead = null;
        while(q0.peek() != null) {
            Node n0 = q0.remove();
            Node n1 = null;
            if(q1.peek() != null) {
                n1 = q1.remove();
                System.out.println("q1[" + n1.data+"]");
            }

            n0.next = n1;
            currPair = n0;

            if(prevPair!= null)
                prevPair.next.next = currPair;
            else
                newHead = currPair;
            prevPair = currPair;
        }
        return newHead;
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

//[ file=mergeintervals.html title=""
class Interval implements Comparable<Interval>{
    public int begin;
    public int end;
    public Interval(int begin, int end){
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter){
        if(this.begin > inter.begin)
           return 1; 
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString(){
        return "[" + begin + " " + end + "]";
    }
}

public class MergeIntervals{
    public static void main(String[] args) {
        test00();
    }
    static void test00(){
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};
        
        for(int i=0; i<arr1.length; i++){
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0){
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()){
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else{
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()){
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }
        
        Aron.end();
    }
}
//]
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MergeListList{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        Map<String, List<List<String>>> map1 = new HashMap<>();
        Map<String, List<List<String>>> map2 = new HashMap<>();
        // mutable list
        List<String> list1 = new ArrayList<>(Arrays.asList("cat", "dog", "cow"));
        List<String> list2 = new ArrayList<>(Arrays.asList("cat1", "dog1", "cow1"));
        List<String> list3 = new ArrayList<>(Arrays.asList("pig", "fox", "rat"));
        List<List<String>> listList1 = new ArrayList<>();
        listList1.add(list1);
        List<List<String>> listList2 = new ArrayList<>();
        listList2.add(list2);

        List<List<String>> listList3 = new ArrayList<>();
        listList3.add(list3);
        //
        map1.put("key1", listList1);
        map2.put("key2", listList2);
        map2.put("key1", listList3);
        Map<String, List<List<String>>> map = Aron.mergeMapListList(map1, map2);
        //
        for(Map.Entry<String, List<List<String>>> entry : map.entrySet()){
            //System.out.println("[" + entry.getKey());
            for(List<String> list : entry.getValue()){
                for(String s : list)
                    System.out.println("[" + entry.getKey() + "]->[" + s + "]");
            }
        }

        Aron.end();
    }
    public static Map<String, List<List<String>>>  mergeMapListList(
        Map<String, List<List<String>>> map1, 
        Map<String, List<List<String>>> map2){

        for(Map.Entry<String, List<List<String>>> entry : map1.entrySet()){
            System.out.println("[" + entry.getKey());
            
            // merge map1 => map2
            List<List<String>> list2 = map2.get(entry.getKey());
            if (list2 != null){
                for(List<String> ls: entry.getValue()){
                    list2.add(ls);
                }
            }else{
                map2.put(entry.getKey(), entry.getValue()); 
            }
        }
        return map2;
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

public class MergeSortArray 
{
    public static void main(String[] args)
    {
        System.out.println("Merge Sort Array");
        test1();
        test2();
        test3();
        test4();
    }

    public static void test1()
    {
        int[] A = {3, 2, 1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test2()
    {
        int[] A = {2, 1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test3()
    {
        int[] A = {1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test4()
    {
        int[] A = {10, 1, 9, 100, 6, 3, 3, 5};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }
    public static void merge(int[] A, int lo, int mid, int hi)
    {
        if( A != null)
        {
            int[] B = new int[hi-lo+1];

            int index1 = lo;
            int index2 = mid+1;
            int k=0;
            while(k < (hi-lo+1))
            {
                if(index1 > mid)
                {
                    B[k] = A[index2];
                    index2++;
                }
                else if(index2 > hi)
                {
                    B[k] = A[index1];
                    index1++;
                }
                else
                {
                    if(A[index1] < A[index2])
                    {
                        B[k] = A[index1]; index1++;
                    }
                    else
                    {
                        B[k] = A[index2]; index2++;
                    }
                }
                k++;
            }
            for(int i=0; i<B.length; i++)
                A[lo+i] = B[i];
        }
    }
    public static void mergeSort(int[] A, int lo, int hi)
    {
        if(lo<hi)
        {
            int mid = (lo+hi)/2;
            mergeSort(A, lo, mid);
            mergeSort(A, mid+1, hi);
            merge(A, lo, mid, hi);
        }
    }
}
class Node 
{
	Node next;
	int data;
	public Node(int n)
	{ next = null; data = n;}
}

class SLL
{
	Node head;
	public SLL()
	{ head = null;}

    public void append(int n)
    {
        Node cur = head;
		if(head == null)
			head = new Node(n);
		else
		{
			while(cur.next != null)
			{ 
                cur = cur.next; 
            }
			cur.next = new Node(n);
		}

    }

	public void append(Node no)
	{
		Node cur = head;
		if(head == null)
			head = no;
		else
		{
			while(cur.next != null)
			{ cur = cur.next; }
			cur.next = no;
		}
	}

	//recursive 
	static Node next=null;
	public void Reverse(Node cur)
	{
		if(cur != null)
		{
			Reverse(cur.next);
			if(next != null)
				next.next = cur;	
			else 
				head = cur;
			next = cur;
			cur.next = null;
		}
	}
	//iteration
	public void Reverse1(Node cur)
	{
		if(head != null)
		{
			Node prev = null;
			Node next = cur.next;

			while(cur != null)
			{
				cur.next = prev;
				prev = cur;
				cur = next;
				if(next != null)
					next = next.next;
			}
			head = prev;
			
		}
	}
	public Node getHead()
	{ return head;}
	public void Remove(Node no)
	{
		if(no != null && head != null)
		{
			Node cur = head;	
			Node prev = null;
			while(cur != no)
			{
				prev = cur;
				cur = cur.next;
			}
			if(prev != null && no.next != null)
			{ prev.next = no.next; no.next = null; }
			else if(prev == null && no.next != null)
			{ head = no.next; no.next = null; }
			else if(prev != null && no.next == null)
			{ prev.next = null; }
			else 
			{ no = null; head = null;}
		}	
	}
	public void show()
	{
		Node cur=head;
		while(cur != null)
	 	{ System.out.println("cur.data=" + cur.data); cur=cur.next;}
	}
    public Node getTail()
    {
        Node curr = head;
        while(curr != null && curr.next != null)
        {
            curr = curr.next;
        }
        return curr;
    } 
}

//Merge sort on single linkedlist
public class MergeSortLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Merge Sort linkedlist");
        test1();
        test2();
        test3();
        test4();

    }

    public static void test1()
    {
        System.out.println("Test1()");
        SLL s3 = new SLL();

        s3.append(2);
        s3.append(1);

        show(s3.getHead());
        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test1()=======================");

    }

    public static void test2()
    {
        System.out.println("Test2()");
        SLL s3 = new SLL();

        s3.append(1);
        s3.append(2);
        s3.append(3);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test2()=======================");
    }


    public static void test3()
    {
        System.out.println("Test3()");
        SLL s3 = new SLL();

        s3.append(6);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test3()=======================");
    }

    public static void test4()
    {
        System.out.println("Test4()");
        SLL s3 = new SLL();

        s3.append(6);
        s3.append(5);
        s3.append(3);
        s3.append(100);
        s3.append(1);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test4()=======================");
    }
    public static void show(Node head)
    {
        Node curr = head;
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }
    public static Node getTail(Node head)
    {
        Node curr = head;
        while(curr != null && curr.next != null)
            curr = curr.next;
        return curr;
    }

    public static Node mergeSortLinkedList(Node lo, Node hi)
    {
        if(lo != null && lo != hi)
        {
            Node m = median(lo);
            Node m1 = m.next;
            m.next = null;

            Node left = mergeSortLinkedList(lo, m);
            Node right = mergeSortLinkedList(m1, hi);
            return mergeLinkedList(left, right);
        }
        else
            return lo;
    }

    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }

    public static Node mergeLinkedList(Node s1, Node s2)
    {
        Node curr1 = s1;
        Node curr2 = s2;
        Node curr = null;
        Node head = curr;
        if(curr1 == curr2)
            head = s1;
        else
        {
            while(curr1 != null || curr2 != null)
            {
                if(curr1 == null)
                {
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else
                    {
                        curr.next = new Node(curr2.data);
                        curr = curr.next;
                    }
                    curr2 = curr2.next;
                }
                else if(curr2 == null)
                {
                    if(curr == null)
                    {
                        head = curr = new Node(curr1.data);
                    }
                    else
                    {
                        curr.next = new Node(curr1.data);
                        curr = curr.next;
                    }
                    curr1 = curr1.next;
                }
                else 
                {
                    if(curr1.data < curr2.data)
                    {
                        if(curr == null)
                            head = curr = new Node(curr1.data);
                        else
                        {
                           curr.next = new Node(curr1.data); 
                           curr = curr.next;
                        }
                        curr1 = curr1.next;
                    }
                    else
                    {
                        if(curr == null)
                            head = curr = new Node(curr2.data);
                        else
                        {
                            curr.next = new Node(curr2.data);
                            curr = curr.next;
                        }
                        curr2 = curr2.next;
                    }
                }
            }
        }
        return head;
    }
}
import java.io.*;
import java.util.*;
class MergeSortedList 
{
	public static void main(String args[])
	{
		int[] Arr1 = new int[10]; 
		Arr1[0] = 5; 
		Arr1[1] = 6; 
		Arr1[2] = 7; 
		Arr1[3] = 8; 
		Arr1[4] = 9; 
		Arr1[5] = 10; 
		int[] Arr2 = {11, 20, 30, 40};
		int[] Arr = Merge(Arr1, Arr2);
		for(int i=0; i< Arr.length; i++)
			System.out.println(Arr[i]);
	}

	public static int[] Merge(int[] Arr1, int[] Arr2)
	{
		int[] ret=null;
		if(Arr1 !=null && Arr2 !=null) 
		{
			int i=Arr1.length-5, j=Arr2.length-1, k=Arr1.length-1;	
			while(j !=-1)
			{
				System.out.println("i=" + i + "  " + "j=" + j);
				if(i == -1)
				{
					Arr1[k] = Arr2[j]; j--;
				}
				else if(Arr1[i] > Arr2[j])
				{
					Arr1[k] = Arr1[i]; i--;
				}
				else 
				{
					Arr1[k] = Arr2[j]; j--;
				}
				k--;
					
			}
		}
		return Arr1;
	}
}
import java.io.*;
import java.util.*;
class MergeSortedListToArray {
    public static void main(String args[]) {
        int[] Arr1 = {1, 9, 12};
        int[] Arr2 = {2, 15};
        int[] Arr3 = {5, 7, 20};
        int[] Arr = Merge(Merge(Arr1, Arr2), Arr3);
        for(int i=0; i< Arr.length; i++)
            System.out.println(Arr[i]);
    }

    public static int[] Merge(int[] Arr1, int[] Arr2) {
        int[] A=null;
        if( Arr1 != null && Arr2 != null) {
            int len1 = Arr1.length;
            int len2 = Arr2.length;
            A = new int[len1+len2];
            int i=0, j=0, c=0;
            while(i<len1 || j<len2) {
                if(i == len1) {
                    A[c]=Arr2[j];
                    j++;
                } else if( j == len2) {
                    A[c]=Arr1[i];
                    i++;
                } else {
                    if(Arr1[i]<Arr2[j]) {
                        A[c] = Arr1[i];
                        i++;
                    } else {
                        A[c] = Arr2[j];
                        j++;
                    }
                }
                c++;
            }
        }
        return A;
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

public class MergeSortedSingleLinkedList{
    public static void main(String[] args) {
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=mergesortedsll.html title=""
    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }
    //]
}
import classfile.*;

public class MergeThreeSortList 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
    }
    public static void test1()
    {
        int[] arr1 = {1};
        int[] arr2 = {2, 8, 10, 40};
        int[] arr3 = {5};
        int[] arr = mergeThreeList(arr1, arr2, arr3);
        Aron.printArray(arr1);
        Aron.printArray(arr2);
        Aron.printArray(arr3);
        Aron.printArray(arr);
    }

    public static void test2()
    {
        int[] arr1 = {1, 9, 20, 30};
        int[] arr2 = {2, 8, 10, 40};
        int[] arr3 = {5, 18, 21, 29};
        int[] arr = mergeThreeList(arr1, arr2, arr3);
        Aron.printArray(arr1);
        Aron.printArray(arr2);
        Aron.printArray(arr3);
        Aron.printArray(arr);
    }
    public static int[] mergeThreeList(int[] arr1, int[] arr2, int[] arr3)
    {
        int[] arr = null;
        if(arr1 != null && arr2 != null && arr3 != null)
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len3 = arr3.length;
            int inx = 0;
            int inx1=0, inx2=0, inx3=0;
            arr = new int[len1+len2+len3];
            while(inx1 < len1 || inx2 < len2 || inx3 < len3)
            {
                if(inx1 >= len1 && (inx2 < len2 && inx3 < len3))
                {
                    arr[inx] = Math.min(arr2[inx2], arr3[inx3]);
                    if( arr[inx] == arr2[inx2]) inx2++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                else if(inx2 >= len2 && (inx1 < len1 && inx3 < len3))
                {    
                    arr[inx] = Math.min(arr1[inx1], arr3[inx3]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                else if(inx3 >= len3 && (inx1 < len1 && inx2 < len2))
                {    
                    arr[inx] = Math.min(arr1[inx1], arr2[inx2]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr2[inx2]) inx2++;
                }
                else if(inx1 >= len1 && inx2 >= len2 && inx3 < len3)
                {
                    arr[inx] = arr3[inx3]; inx3++;
                }
                else if(inx2 >= len2 && inx3 >= len3 && inx1 < len1)
                {
                    arr[inx] = arr1[inx1]; inx1++;
                }
                else if(inx1 >= len1 && inx3 >= len3 && inx2 < len2)
                {
                    arr[inx] = arr2[inx2]; inx2++;
                }
                else
                {
                    arr[inx] = Math.min(Math.min(arr1[inx1], arr2[inx2]), arr3[inx3]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr2[inx2]) inx2++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                inx++;
            }
        }
        return arr;
    }
}
public class Min 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] str = {4};  
        int m  = min(str);
        System.out.println("m="+m);
    }
    public static int min(int[] array)
    {
        int min = Integer.MAX_VALUE;
        if(array != null)
        {
            int len = array.length;
            if(len > 0)
            {
                min = array[0];
                for(int i = 1; i<len; i++)
                {
                    if(min > array[i])
                        min = array[i];
                }
            }
        }
        return min;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MinSumNum {
    public static void main(String[] args) {
        test0();
        test1();
        test11();
        test12();
//        test2();
//        test3();
//        test4();
        //test5();
        //test6();
    }

    public static int minSquareTermDY(int n, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(n == 0) {
//            for(Integer e : list) {
//                System.out.print("[" + e + "]");
//            }
//            System.out.println();
            return 0;
        } else if(n > 0) {
            int inx =(int)Math.sqrt(n) + 1;
            for(int i=1; i<= inx; i++) {

                list.add(i);
                Integer value = map.get(n-i*i);
                Integer m = value;
                if(value == null){
                    m = minSquareTermDY(n-(i*i), map, list);
                    if(m < Integer.MAX_VALUE)
                        m += 1;
                }
                min = Math.min(min, m);
                System.out.println("n-i*i=[" + (n-i*i) + "] min[" + min + "]"); 
                
                if(n - i*i < 0)
                    map.put(n-i*i, Integer.MAX_VALUE);
                else
                    map.put(n-i*i, min);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        } 
        return min;
    }
    public static int minSquareTerm(int n, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(n == 0) {
//            for(Integer e : list) {
//                System.out.print("[" + e + "]");
//            }
//            System.out.println();
            return 0;
        } else if(n > 0) {
            int inx =(int)Math.sqrt(n) + 1;
            for(int i=1; i<= inx; i++) {

                list.add(i);
                int m = minSquareTerm(n-(i*i), map, list);
                if(m < Integer.MAX_VALUE)
                    m += 1;

                min = Math.min(min, m);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        } 
        return min;
    }

    public static int minCoin(int s, Integer[] arr, Map<Integer, Integer> map) {
        int min = Integer.MAX_VALUE;
        if(s == 0)
            return 0;
        else if(s > 0) {
            if(arr != null) {
                for(Integer n : arr) {
                    Integer value = map.get(s-n);
                    Integer m = 0;
                    if(value == null){
                        m = minCoin(s-n, arr, map);
                        if(m < Integer.MAX_VALUE)
                            m += 1;
                    }else{
                       m = value;
                    }

                    min = Math.min(min, m);

                    map.put(s-n, min);
                }
            }
        }
        return min;
    }

    static void test0() {
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(4, map, list);
        System.out.println("min=[" + min + "]");
        Aron.end();
    }
    static void test1() {
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(10, map, list);
        System.out.println("min=[" + min + "]");
        Aron.end();
    }
    static void test11() {
        Aron.beg();
        StopWatch sw = new StopWatch();
        sw.start();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(50, map, list);
        //System.out.println("min=[" + min + "]");

        sw.printTime(); 

        Aron.end();
    }

    static void test12() {
        Aron.beg();
        StopWatch sw = new StopWatch();
        sw.start();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTermDY(50, map, list);
        //System.out.println("min=[" + min + "]");

        sw.printTime(); 

        Aron.end();
    }
    static void test2() {
        Aron.beg();
        Integer[] arr = {1, 2}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test3() {
        Aron.beg();
        Integer[] arr = {1}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test4() {
        Aron.beg();
        Integer[] arr = {3}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test5() {
        Aron.beg();
        Integer[] arr = {2, 5}; 
        int s = 10;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }
    static void test6() {
        Aron.beg();
        Integer[] arr = {2, 5, 100}; 
        int s = 100;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }
}
public class MiniDiffSortedArray 
{
    public static void main(String[] args)
    {
        System.out.println("MiniDiffSortedArray");
        test1();
    }
    public static void test1()
    {
        int[] arr1 = {2, 4, 9, 20};
        int[] arr2 = {1, 14, 16, 80};
        int min = miniDiff(arr1, arr2);
        System.out.println("min=["+min+"]");
    }

    public static int miniDiff(int[] arr1, int[] arr2)
    {
        int diff = Integer.MAX_VALUE;
        if(arr1 != null && arr2 != null)
        {
            int inx1 = 0;
            int inx2 = 0;
            while(inx1 < arr1.length && inx2 < arr2.length)
            {
                diff = Math.min(diff, Math.abs(arr1[inx1] - arr2[inx2]));
                int min = Math.min(arr1[inx1], arr2[inx2]); 
                if(min == arr1[inx1]) inx1++;
                if(min == arr2[inx2]) inx2++;
            }
        }
        return diff;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

// Find the minimum distance between two given words
public class MinimumDistanceWord{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    static void test0(){
        Aron.beg();
        String[] arr = {"a", "b", "c", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "b";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String[] arr = {"a", "b", "c", "e"}; 
        String word1 = "a";
        String word2 = "e";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 3);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "e";
        String word2 = "a";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "e";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "a";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 0);

        Aron.end();
    }
    //[ file=minidistanceword.html title=""
    static int minimumDistance(String[] wordArray, String word1, String word2){
        int minDistance = Integer.MAX_VALUE;
        if(word1 != null && word2 != null){
            int index1 = -1;
            int index2 = -1;
            for(int i=0; i<wordArray.length; i++){
                if(word1.equals(wordArray[i]))
                    index1 = i; 
                
                if(word2.equals(wordArray[i]))
                    index2 = i;

                if(index1 != -1 && index2 != -1){
                    int dist = Math.abs(index1 - index2);
                    minDistance = Math.min(dist, minDistance);
                }
            }
        }
        return minDistance;
    }
    //]
} 
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.stream.Collectors;

public class MinimumPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   1,   0,  1},
            { 0,   0,   1,  1},
            { 0,   0,   0,  1},
            { 0,   0,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length;
        
        int k = 2; 
        int h = 0;
        int w = 1;
        printPath(arr2d, h, w, k);
        
        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        int[][] arr2d = {
            { 1,   2,   9,  1},
            { 0,   0,   3,  4},
            { 0,   0,   0,  1},
            { 0,   0,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length;
        
        int k = 2; 
        int h = 0;
        int w = 1;
        int m = findMaxPath(arr2d, h, w, k);
        Print.pl("m=" + m);

        Aron.end();
    }
    public static void test2(){
        List<Integer> list = Arrays.asList(1, 2, 3);
        int s = 5;
        int n = minCoins(list, s);
        Test.t(n == 2); 
    }
    public static void test3(){
        List<Integer> list = Arrays.asList(1, 2, 3);
        int s = 2;
        int n = minCoins(list, s);
        Test.t(n == 1); 
    }
    public static void test4(){
        List<Integer> list = Arrays.asList(1, 2, 3);
        int s = 3;
        int n = minCoins(list, s);
        Test.t(n == 1); 
    }
    public static void test5(){
        List<Integer> list = Arrays.asList(1, 2, 3);
        int s = 6;
        int n = minCoins(list, s);
        Test.t(n == 2); 
    }
    /*
        Precondition: given node: [h][w] > 0 and k > 0 
        If k = 0, then no edge, do nothing
        If k > 0 and arr[h][w] > 0
    */
    public static int findMaxPath(int[][] arr, int h, int w, int k){
        if(arr != null && arr[h][w] > 0){
            if(k - 1 == 0)
                return arr[h][w];
            else
                return maxPath(arr, w, k - 1);            
            
        }
        return 0;
    }

    // The method handles k = 0
    public static void printPath(int[][] arr2d, int h, int w, int k){
        if(arr2d[h][w] > 0){
            if(k == 0)
                Print.pl("[" + h + "][" + w + "]=" + arr2d[h][w]);
            else {
                allPaths(arr2d, w, k - 1);
            }
        }
    }

    // find all the paths that have length k
    // if k == 0, then print the root node, if node has loop 
    // if node has loop, it is trick => you can loop forever 
    // (0) - 1 > (1) => [1][2] = 1
    public static void allPaths(int[][] arr, int h, int k){
        if(arr != null){
            int height = arr.length;
            int width  = arr[0].length;
            for(int w = 0; w < width; w++){
                if(h != w && arr[h][w] > 0){
                    if(k == 0){
                        Print.pl("[" + h + "][" + w + "]=" + arr[h][w]);
                    }else{
                        allPaths(arr, w, k - 1); 
                    }
                }
            }
        }
    }
    
    /*
            [ m
                [
                  3
                ]
                [
                  2
                ]
              3
            ]
    */

    public static int maxPath(int[][] arr, int h, int k){
        int m = 0;
        if( arr != null){
            int height = arr.length;
            int width = arr[0].length;
            for(int w = 0; w < width; w++){
                if(h != w && arr[h][w] > 0){
                    if(k == 0){
                        return arr[h][w];
                    }else{
                        m = Math.max(m, maxPath(arr, w, k - 1));
                    }
                }
            }
        }
        return m;
    }

    /* 
        (4) -> (4 - 2) -> (2 - 2)
        {2} s = 4
        [ s=4
                [ s=2
                        [ s = 0
                          

                      0 <-]
              1 <-]
     2 <-]
    */
    public static int minCoins(List<Integer> list, int s){
        int min = Integer.MAX_VALUE;
        if( list != null){
            if (s < 0){
                return Integer.MAX_VALUE;
            }
            else if( s == 0){
                return 0;
            }else{
                for(Integer n : list){
                    min = Math.min(min, minCoins(list, s - n));
                }
            }
        }
        return min + 1;
    }
} 

public class ModifyBinSearch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] array = {1, 2, 10, 4};
        int left = 0; int right = array.length-1;
        int max = max2(array, left, right);
        System.out.println("max="+max);
    }
    public static int max2(int[] array, int left, int right)
    {
        if(array != null)
        {
            int mid = (left + right)/2;
            if(mid < right)
            {
                if(array[mid] < array[mid + 1])
                {
                    return max2(array, mid+1, right);
                }
                else
                    return max2(array, left, mid);
            }
            else
                return array[mid];
        }
        return -1000;
    }
    public static int max(int[] array, int left, int right)
    {
        if(array != null)
        {
            if(array.length == 0)
            {
                return -1000;
            }
            else if(array.length == 1)
            {
                return array[0]; 
            }
            else //two or more elements 
            {
                int mid = (left + right)/2;
                if(right - left > 1)
                {
                    if(array[mid-1] < array[mid])
                        return max(array, mid, right);
                    else
                        return max(array, left, mid-1);
                }
                else
                {
                    return array[left] < array[right]? array[right]:array[left];
                }
            }
        }
        return -1000;
    }
}
import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.control.TextArea;
import javafx.scene.layout.VBox;
import javafx.stage.Stage;

public class MultipleTextArea extends Application {
  public static void main(String[] args) { launch(args); }
  @Override public void start(Stage stage) throws Exception {
    System.out.println("JavaFX Version: " + System.getProperties().get("javafx.runtime.version"));
    VBox layout = new VBox(10);
    for (int i = 0; i < 3; i++) layout.getChildren().add(new TextArea("Area " + i));
    layout.setStyle("-fx-background-color: cornsilk; -fx-padding: 10;");
    stage.setScene(new Scene(layout));
    stage.show();
  }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*; 

class MultiplyArrayInteger {
    public static void main(String args[]) {
        test00();
        test0();
        test1();
    }

    //[ file=multiply.html title=""
    /**
    * Multiple all the integers except the current one
    * No Division is allowed
    * Runtime is O(n)
    * [2, 3, 4] => [3*4, 2*4, 2*3] => [12, 8, 6]
    */ 
    public static int[] multiple(int[] arr){
        if (arr == null){
            throw new IllegalArgumentException("arr must not be null.");
        }else{
            int len = arr.length;
            int[] arr1 = new int[len];
            int[] arr2 = new int[len];
            if(len > 1){
                arr1[0] = arr2[len-1] = 1;
                for(int i=1; i<len; i++){
                    arr1[i] = arr[i-1]*arr1[i-1];
                    arr2[len-1 - i] = arr[len-i]*arr2[len-i];
                }
                for(int i=0; i<len; i++)
                arr1[i] = arr1[i]*arr2[i];
            }
            return arr1;
        }
    } 
    //]
    public static void test00() {
        Aron.beg();
        int[] arr1 = {2}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);

        Aron.end();
    }

    public static void test0() {
        Aron.beg();
        int[] arr1 = {2, 3}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        int[] arr1 = {2, 3, 4}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);
        Aron.end();
    }

}
public class MultiplyBlockMatrix
{
    public static void main(String[] args)
    {
        System.out.println("Multiply Block Matrix!");
    }
    public static int[][] multiply(int[][] A, int col_lo_a, int col_hi_a, 
                                              int row_lo_a, int row_hi_a,
                                    int[][] B,int col_lo_b, int col_hi_b,
                                              int row_lo_b, int row_hi_b)
    {
        int[][] C = null;
        int col_mid_a = (col_lo_a + col_hi_a)/2;
        int row_mid_a = (row_lo_a + row_hi_a)/2;
        int col_mid_b = (col_lo_b + col_hi_b)/2;
        int row_mid_b = (row_lo_b + row_hi_b)/2;

        int[][] a11 = multiply(A, B, col_lo_a, col_mid_a, row_lo_a, row_mid_a,
                                     col_lo_b, col_mid_b, row_lo_b, row_mid_b);

        int[][] a12 = multiply(A, B, col_mid_a, col_hi_a, row_lo_a, row_mid_a, 
                                     col_mid_b, col_hi_b, row_lo_b, row_mid_b);
        int[][] a21 = multiply(A, B, col_lo_a,  col_mid_a,row_mid_a,row_hi_a,
                                     col_lo_b,  col_mid_b,row_mid_b,row_hi_b);
        int[][] a22 = multiply(A, B, col_mid_a, col_hi_a, row_mid_a,row_hi_a,
                                     col_mid_b, col_hi_b, row_mid_b,row_hi_b);
        return C;
    }
}
import java.io.*;
import classfile.*;

class MultiplyLongInt
{
	public static void main(String args[])
	{
        test1();
        test2();
        test3();
        test4();
        test5();
        test1_multiplynew();
        test2_multiplynew();
        test3_multiplynew();

	}
    //[file=multiplynew.html title=""     
    public static int[] multiplynew(int[] arr1, int[] arr2){
        int len1 = arr1.length;
        int len2 = arr2.length;
        int len = len1 + len2;
        int[][] arr = new int[len1][len1+len2];

        for(int i=len2-1; i >= 0; i--){
            int carry = 0;
            int j=0;
            for(j=len1-1; j >= 0; j--){
                int shiftLeft = i + 1;
                arr[i][j + shiftLeft] = (arr1[j]*arr2[i] + carry) %10;
                carry = (arr1[j]*arr2[i]+carry) / 10;
            }
            arr[i][(i+1)+j] = carry;
        }

        int[] total = new int[len];
        int carry = 0;
        for(int j=len-1; j >= 0; j--){
            int s=0;
            for(int i=0; i < len2; i++){
                s += arr[i][j];
            }
            total[j] = (s + carry) % 10;
            carry = (s + carry)/10;
        }
        return total;
    }
    //]

    //[file=multiplylong.html title="multiply long integer"
    public static int[] multiply(int[] arr1, int[] arr2) {
        if(arr1 != null && arr2 != null && arr1.length > 0 && arr2.length > 0) {
            int len1 = arr1.length;
            int len2 = arr2.length;
            Reverse(arr1);        
            Reverse(arr2);
            int[][] array = new int[len1][len1+len2];

            for(int i=0; i<len1; i++) {
                int carrying = 0;
                int j=0;
                for(j=0; j<len2; j++) {
                    int t = arr1[i]*arr2[j] + carrying;
                    array[i][j + i] = t % 10;
                    carrying = t / 10;
                }
                array[i][j + i] = carrying;
            }

            int[] total = new int[len1+len2];
            int carrying = 0;
            for(int i=0; i<len1 + len2; i++) {
                int s = 0;
                for(int j=0; j < len1; j++) {
                    s += array[j][i];
                }
                total[i] = (s + carrying) % 10; 
                carrying = (s + carrying) / 10;
            }
            Reverse(total);
            return total;
        }
        return null;
    }

    public static void Reverse(int[] A) {
        if(A != null) {
            int len = A.length;
            for(int i=0; i<len/2; i++) {
                int tmp = A[i];
                A[i] = A[len-1-i];
                A[len-1-i] = tmp;
            }
        }
    }
    //]
    

    static void test1(){
        Aron.beg();
		int[] A = {9, 9, 9};
		int[] B = {9, 0, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);
        Aron.end();
    }
    static void test2(){
        Aron.beg();
		int[] A = {9, 9, 9};
		int[] B = {9, 9, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
		int[] A = {9};
		int[] B = {9, 9, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    } 

    static void test4(){
        Aron.beg();
		int[] A = {9};
		int[] B = {1};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    } 

    static void test5(){
        Aron.beg();
		int[] A = {9, 9};
		int[] B = {9};
		int[] S = multiply(A, B);
        Aron.printArray(S);
        Aron.end();
    } 

    static void test1_multiplynew(){
        Aron.beg();
        int[] A = {9, 9};
		int[] B = {9};
		int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }

    static void test2_multiplynew(){
        Aron.beg();
		int[] A = {1};
		int[] B = {9};
	    int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }

    static void test3_multiplynew(){
        Aron.beg();
		int[] A = {0};
		int[] B = {0};
	    int[] S = multiplynew(A, B);
        Aron.printArray(S);
        Print.p(0*0);

        Aron.end();
    }
    static void test4_multiplynew(){
        Aron.beg();
		int[] A = {9};
		int[] B = {9};
		int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

class Node
{
    int coeff;
    int power;
    String data;
    Node next;
    public Node(int coeff, int power, String data)
    {
        this.coeff = coeff;
        this.power = power;
        this.data = data;
        this.next = null;
    }
}

class SLinkedList
{
    Node head;
    public SLinkedList()
    {
        this.head = null;
    }
    public void add(Node node)
    {
        if(this.head == null)
        {
            this.head = node;
        }
        else
        {
            Node curr = this.head;
            while(curr.next != null)
            {
                curr = curr.next;
            }
            curr.next = node; 
        }
    }
    public void show()
    {
        Node curr = this.head;
        while(curr != null)
        {
            System.out.println("["+curr.coeff+"]["+curr.power+"]");
            curr = curr.next;
        }
    }
}

public class MultiplyPolynomial 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SLinkedList poly1 = new SLinkedList();
        SLinkedList poly2 = new SLinkedList();
        poly1.add(new Node(1, 2, "x"));
        poly1.add(new Node(2, 3, "x"));
        poly2.add(new Node(4, 5, "x"));
        poly2.add(new Node(6, 7, "x"));
        poly1.show();
        System.out.println("================");
        poly2.show();
        System.out.println("================");
        multiply(poly1, poly2);
        System.out.println("================");
        add(poly1, poly2);
        System.out.println("================");
        TestPolyArray();
    }
    public static void TestPolyArray()
    {
        int[] p1 = {1, 2, 3};
        int[] p2 = {2, 0, 4, 5};
        int[] p = MultiplePolyArray(p1, p2);

        for(int i=0; i<p1.length; i++)
            System.out.print("p1["+p1[i]+"]");
        System.out.println();

        for(int i=0; i<p2.length; i++)
            System.out.print("p2["+p2[i]+"]");
        System.out.println();

        for(int i=0; i<p.length; i++)
            System.out.print("["+p[i]+"]");

        System.out.println();
    }
    public static SLinkedList add(SLinkedList poly1, SLinkedList poly2)
    {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        SLinkedList poly = new SLinkedList();
        if(poly1 != null && poly2 != null && poly1.head != null && poly2.head != null)
        {
            Node curr1 = poly1.head; 
            while(curr1 != null)
            {
                Integer coeff = (Integer)map.get(curr1.power);
                if(coeff != null)
                {
                    map.put(new Integer(curr1.coeff + coeff), new Integer(curr1.power));  
                }
                else
                {
                    map.put(new Integer(curr1.coeff), new Integer(curr1.power));
                }
                curr1 = curr1.next;
            }

            Node curr2 = poly2.head; 
            while(curr2 != null)
            {
                Integer coeff = (Integer)map.get(curr2.power);
                if(coeff != null)
                {
                    map.put(new Integer(curr2.coeff + coeff), new Integer(curr2.power));  
                }
                else
                {
                    map.put(new Integer(curr2.coeff), new Integer(curr2.power));
                }
                curr2 = curr2.next;
            }
            Set<Map.Entry<Integer, Integer>> set = map.entrySet();
            for(Map.Entry<Integer, Integer> entry : set)
            {
                Integer coeff = entry.getKey();
                Integer power = entry.getValue();
                poly.add(new Node(coeff, power, "x"));
            }
            poly.show();
        }
        return poly;
    }
    public static SLinkedList multiply(SLinkedList poly1, SLinkedList poly2)
    {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        SLinkedList poly = new SLinkedList();
        if(poly1 != null && poly2 != null && poly1.head != null && poly2.head != null)
        {
            Node curr1 = poly1.head; 
            Node curr2 = poly2.head;
            while(curr1 != null)
            {
                curr2 = poly2.head;
                while(curr2 != null)
                {
                    Node node = new Node(curr2.coeff*curr1.coeff, curr2.power+curr1.power, "x"); 
                    Integer coeff = (Integer)map.get(new Integer(node.power));
                    if(coeff != null)
                    {
                        map.put(new Integer(node.coeff + coeff), new Integer(node.power));  
                    }
                    else
                    {
                        map.put(new Integer(node.coeff), new Integer(node.power));
                    }
                    curr2 = curr2.next;
                }
                curr1 = curr1.next;
            }
        }
        Set<Map.Entry<Integer, Integer>> set = map.entrySet();
        for(Map.Entry<Integer, Integer> entry : set)
        {
            Integer coeff = entry.getKey();
            Integer power = entry.getValue();
            poly.add(new Node(coeff, power, "x"));
        }
        poly.show();
        return poly;
    }

    public static int[] MultiplePolyArray(int[] p1, int[] p2)
    {
        if(p1 != null && p2 != null)
        {
            int len1 = p1.length;
            int len2 = p2.length;
            if(len1 > 0 && len2 > 0)
            {
                int[][] p = new int[len1][len1+len2];
                for(int i=0; i<len1; i++)
                {
                   for(int j=0; j<len2; j++)
                   {
                       p[i][j+i] = p1[i]*p2[j];
                   } 
                }

                for(int j=0; j<len1+len2; j++)
                {
                    int s=0;
                    for(int i=0; i<len1; i++)
                    {
                        s += p[i][j];
                        if(i == len1-1)
                            p[i][j] = s;
                    }
                }
                return p[len1-1];
            }
        }
        return null;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;

public class MyDict{
    public static void main(String[] args) {
        //test0();
        Print.pbl("len=" + args.length);
        if(args.length > 0){
            Print.pbl("args[0]=" + args[0]);
            find(args[0]);
        }
        //test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "/Users/cat/myfile/github/java/text/mydict.txt";
        List<ArrayList<String>> list2d = Aron.readFileSaperater(file);
        Aron.printList2dArr(list2d);

        Aron.end();
    }

    public static void find(String word){
        String pattern = "\\w+";
        Pattern r = Pattern.compile(word, Pattern.CASE_INSENSITIVE);

        String file = "/Users/cat/myfile/github/java/text/mydict.txt";
        List<ArrayList<String>> list2d = Aron.readFileSaperater(file);
        for(ArrayList<String> list : list2d){
            String[] arr = list.get(0).split("\\s+");

            Matcher mat = r.matcher(arr[0]);
            if(mat.find()){
                Print.pbl("w=" + arr[0] + " " + list);
            }
        }
        //Aron.printList2dArr(list2d);
    } 
    public static void test1(){
        Aron.beg();
        find("abacus");
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

class GNode{
    int data;
    GNode next;
}

class Graph{
    private Map<GNode, GNode> map = new HashMap<GNode, GNode>();
    private Set<GNode> set = new HashSet<GNode>();
    public Graph(){
    }
    public void addNode(GNode node){
        set.add(node);
    }
    public void deleteNode(GNode node){
        set.remove(node);
        GNode curr = map.get(node);
        if(curr != null){
           map.put(curr, null);
        }
    }
    public void addEdge(GNode fromNode, GNode toNode){
        GNode curr = map.get(fromNode);        
        if(curr != null){
            while(curr.next != null ){
                curr = curr.next;
            }
            curr.next = toNode;
        }
    }

    public void removeEdge(){
    }

    public List<GNode> adjacentNode(GNode node){
        List<GNode> list = new ArrayList<GNode>(); 
        GNode curr = map.get(node);

        while(curr != null){
            list.add(curr);
            curr = curr.next;
        }
        return list; 
    }
}

public class MyGraph{
    public static void main(String[] args) {
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.util.*;
import java.io.*;
import classfile.*;

//[ file=hashmap1.html title=""
class Entry{
    public String key;
    public Object value;
    public Entry next;
    public Entry(String key, Object value){
        this.key = key;
        this.value = value;
    }
}

class Hash{
    public Entry[] arr;
    public int max;
    public int count = 0;
    public Hash(int max){
        this.max = max;
        arr = new Entry[max];
    }

    public Node get(String key){
        int hash = key.hashCode() % max;
        return (Node)arr[hash].value;
    }
    public void delete(String key){
        if(key != null){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr != null){
                Entry prev = null;
                while(curr != null){
                    if(curr.key == key)
                        break;
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(prev == null){
                    arr[hash] = curr.next;
                    count--;
                }else{
                    if(curr != null){
                        prev.next = curr.next;
                        count--;
                    }
                }
            }
        }
    }
    public void put(String key, Node node){
        if(count < max){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr == null){
                arr[hash] = new Entry(key, node);
                count++;
            }
            else{
                Entry prev = null;
                while(curr != null){
                    if(curr.key.equals(key)){
                        // Replace with new value
                        curr.value = node;
                        break;
                    }
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                // No key is found
                if(curr == null){
                    prev.next = new Entry(key, node);
                    count++;
                }
            }
        }
        
    }
}
//]


public class MyHash{
    public static void main(String[] args) {
        test00_hash();
        test01_hash();
        test02_hash();
        test03_hash();
        test04_hash();
        test05_hash();
        test06_hash();
        test07_hash();
        test08_hash();
        test09_hash();
        test010_hash();
        test011_hash();
        test012_hash();
    }
    
        
    static void test00_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        Node node = (Node)hash.get("a");

        Test.f(node, null);
        Test.f(node, new Node(3));
        Test.t(node, new Node(1));

        Aron.end();
    }
    static void test01_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("a", new Node(2));
        Node node = (Node)hash.get("a");
        Test.t(node, new Node(2));

        Aron.end();
    }
    static void test02_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test03_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        hash.put("e", new Node(5));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test04_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.delete("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
        }

        Aron.end();
    }
    static void test05_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.delete("a");
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test06_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test07_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 1);

        Aron.end();
    }
    static void test08_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 0);

        Aron.end();
    }
    static void test09_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        Test.t(hash.count, 2);

        Aron.end();
    }
    static void test010_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        Test.t(hash.count, 1);

        Aron.end();
    }
    static void test011_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
    static void test012_hash(){
        Aron.beg();
        Hash hash = new Hash(3);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
}
class MyNode
{
	public MyNode left;
	public MyNode right;
	public int data;
	public MyNode(int n)
	{ data = n; left = null; right = null; }
	public MyNode left()
	{ return left; }
	public MyNode right()
	{ return right; }
	public void setLeft(MyNode l)
	{ left = l;}
	public void setRight(MyNode r)
	{ right = r;}

    public MyNode prev()
	{ return left;}
    public MyNode next()
    { return right;}

    public void setPrev(MyNode p){
        left = p;
    }
    public void setNext(MyNode n){
        right = n;
    }
    public int data(){
        return data;
    }
}


import java.util.*;
import java.io.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import classfile.*;

enum Type{
    MOTORCYCLE,
    COMPACT,
    BUS,
}

class Ticket{
    int id;
    double price;
    
    LocalDateTime startTime;
    LocalDateTime endTime;
    public Ticket(int id, int price,  LocalDateTime startTime, LocalDateTime endTime){
        this.id = id;
        this.price = price;
        this.startTime = startTime;
        this.endTime = endTime;
    }
}

class Parking{
    public Vehicle vehicle;
    public Parking(Vehicle v){
        vehicle = v;
    }
}

interface Vehicle{
    public Type getType();
}

class Motorcycle implements Vehicle{
    public Type type;
    public Motorcycle(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class Compact implements Vehicle{
    public Type type;
    public Compact(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class Bus implements Vehicle{
    public Type type;
    public Bus(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class ParkingLot{
    double total;
    Map<Ticket, Parking>  parkMap = new HashMap<Ticket, Parking>();
    int compactMax;
    int compactCount;
    int motorcycleMax;
    int motocycleCount;
    int busMax;
    int busCount;

    public ParkingLot(int cm, int mm, int bm){
        total = 0;
        compactMax = cm;
        motorcycleMax = mm;
        busMax = bm;
    }

    public int getTicket(LocalDateTime st, LocalDateTime et){
        int count = 0;
        for(Map.Entry<Ticket, Parking> entry : parkMap.entrySet()){
            count++;
        }
        return count;
    }

    public double ticketPrice(){
        return 1;
    }
    public void add(Ticket t, Parking p){
        if(!isFull()){
            if(p.vehicle.getType() == Type.COMPACT && compactCount < compactMax)
                compactCount++;
            else if(p.vehicle.getType() == Type.MOTORCYCLE && motocycleCount < motorcycleMax)
                motocycleCount++;
            else if(p.vehicle.getType() == Type.BUS && busCount < busMax)
                busCount++;

            parkMap.put(t, p);
        }
    }
    public void remove(Ticket t){
        Parking p = parkMap.get(t);
        if(p != null){
            if(p.vehicle.getType() == Type.COMPACT)
                compactCount--;

            if(p.vehicle.getType() == Type.MOTORCYCLE)
                motocycleCount--;

            if(p.vehicle.getType() == Type.BUS)
                busCount--;
            
            parkMap.remove(t);

            t.endTime = LocalDateTime.now();
            parkMap.put(t, p);
        }
    }
    public boolean isFullCompact(){
        return compactCount < compactMax;
    }
    public boolean isFullMotorcycle(){
        return motocycleCount < motorcycleMax;
    }
    public boolean isFullBus(){
        return busCount < busMax;
    }
    public boolean isFull(){
        return (compactCount + motocycleCount + busCount) < (compactMax + motorcycleMax + busMax) ? false : true;
    }
}


public class MyParking{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        ParkingLot pl = new ParkingLot(4, 5, 6);
        LocalDateTime time1 = LocalDateTime.parse("2007-12-03T10:15:30", DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        Ticket t1 = new Ticket(1, 100, time1, null);
        Parking park1 = new Parking(new Compact(Type.COMPACT));
        pl.add(t1, park1);
        System.out.println("compactCount[" + pl.compactCount + "]"); 
        System.out.println("motocycleCount[" + pl.motocycleCount+ "]"); 
        System.out.println("busCount[" + pl.busCount+ "]"); 
        
        pl.remove(t1);
        
        System.out.println("\n---------------------------------"); 

        System.out.println("compactCount[" + pl.compactCount + "]"); 
        System.out.println("motocycleCount[" + pl.motocycleCount+ "]"); 
        System.out.println("busCount[" + pl.busCount+ "]"); 

        Aron.end();
    }
} 
import javafx.application.Application;
import javafx.geometry.Rectangle2D;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.stage.Screen;
import javafx.stage.Stage;

public class MyScreen extends Application {
    @Override
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 500, 200);
        stage.setScene(scene);

        Rectangle2D primaryScreenBounds = Screen.getPrimary().getVisualBounds();

        //set Stage boundaries to visible bounds of the main screen
        stage.setX(primaryScreenBounds.getMinX());
        stage.setY(primaryScreenBounds.getMinY());
        stage.setWidth(primaryScreenBounds.getWidth());
        stage.setHeight(primaryScreenBounds.getHeight());

        stage.show();
        
    }
    public static void main(String[] args) {
        launch(args);
    }
}
interface Shape
{
    public double getArea();
}

class Circle implements Shape
{
    double x;
    double y;
    double radial;
    public Circle(double x, double y, double radial)
    {
        this.x = x;
        this.y = y;
        this.radial = radial;
    }
    public double getArea()
    {
        return 3.14*radial*radial;
    }
}

class Rectangle implements Shape
{
    double topx;
    double topy;
    double bottomx;
    double bottomy;
    public Rectangle(double topx, double topy, double bottomx, double bottomy)
    {
        this.topx = topx;
        this.topy = topy;
        this.bottomx= bottomx;
        this.bottomy= bottomy;
    }
    public double getArea()
    {
        return Math.abs(bottomx - topx)*Math.abs(bottomy - topy);
    }
}


public class MyShape 
{
    public static void main(String[] args)
    {
        Shape s1 = new Circle(3.0, 4.0, 5.0); 
        Shape s2 = new Rectangle(3.0, 4.0, 5.0, 6.0); 
        System.out.println("s1=" + s1.getArea());
        System.out.println("s2=" + s2.getArea());
    }
}
import classfile.*;

class StopWatch {
    private long startTime = 0;
    private long stopTime = 0;
    private boolean running = false;

    public void StopWatch(){
        this.startTime = System.currentTimeMillis();
        this.running = true;
    }
    

    public void start() {
        this.startTime = System.currentTimeMillis();
        this.running = true;
    }

    public void stop() {
        this.stopTime = System.currentTimeMillis();
        this.running = false;
        long elapsed = ((System.currentTimeMillis() - startTime) / 1000000);
        Print.pbl(elapsed);
        Print.pbl("startTime=" + startTime);
        Print.pbl("stopTime=" + stopTime);
        Print.pbl("diff=" + (startTime - stopTime));
    }

    //elaspsed time in milliseconds
    public long getElapsedTime() {
        long elapsed;
        if (running) {
            elapsed = (System.currentTimeMillis() - startTime);
        } else {
            elapsed = (stopTime - startTime);
        }
        return elapsed;
    }

    public void diff() {
        Print.pbl(getElapsedTime());
    }

    //elaspsed time in seconds
    public long getElapsedTimeSecs() {
        long elapsed;
        if (running) {
            elapsed = ((System.currentTimeMillis() - startTime) / 1000);
        } else {
            elapsed = ((stopTime - startTime) / 1000);
        }
        return elapsed;
    }
}

public class MyStopWatch {
    public static void main(String[] args) {
        StopWatch sw = new StopWatch();
        for(int i=0; i < 100; i++)
            System.out.println(i);
        sw.stop();
    }
}

import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class TNode {
    boolean isWord;
    TNode[] array = new TNode[26];
}

class Tries {
    TNode root;
    public Tries() {
        root = new TNode();
        root.isWord = true;
    }
    public int map(char ch) {
        return (int)ch - 'a';
    }

    //[ file=newtries.html title=""
    public  void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();

            add(r.array[arr[k]], arr, k+1);
        }else if(k == arr.length){
            r.isWord = true;
        }
    }

    public  boolean contains(TNode r, int[] arr, int k) {
        if(r != null){
            if(k < arr.length) {
                return contains(r.array[arr[k]], arr, k+1);
            }else if (k == arr.length){
                return r.isWord;
            }
        }
        return false;
    }
    public  void addWord(TNode r,  String word, int k) {
        if( k < word.length()) {
            if(r.array[map(word.charAt(k))] == null)
                r.array[map(word.charAt(k))] = new TNode();

            addWord(r.array[map(word.charAt(k))], word, k+1);
        }else{
            r.isWord = true;
        }
    }
    public  boolean containsWord(TNode r, String word, int k) {
          if(r != null){
              if(k == word.length())
                  return r.isWord;
              else if(k < word.length()){
                  return containsWord(r.array[map(word.charAt(k))], word, k+1);
              }
          }
          return false;
    }
    //]
}

class MyTries {
    public static void main(String args[]) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();

        test11();
        test12();
        test13();
        test14();
        test15();
    }
    
    public static void test0() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test1() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test2() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0, 0, 1};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0, 0, 1};
        int[] arr1 = {0, 0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test4() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0};
        int[] arr1 = {0,0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test5() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr1 = {0,0,0};
        int[] arr3 = {0};
        add(t.root, arr1, k);
        add(t.root, arr3, k);

        int[] arr2 = {0,0};
        System.out.println("[" + (t.contains(t.root, arr1, h) == true)+ "]"); 
        System.out.println("[" + (t.contains(t.root, arr2, h) == false)+ "]"); 
        System.out.println("[" + (t.contains(t.root, arr3, h) == true)+ "]"); 

        Aron.end();
    }
    // 'a'-> 0
    // 'b'-> 1
    // 'z'-> 25
    public static int map(char ch) {
        return (int)ch - 'a';
    }
    public static void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();
            add(r.array[arr[k]], arr, k+1);
        }else{
            r.isWord = true;
        }
    }

    public static void test11() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "abc";
        t.addWord(t.root, word, k);
        System.out.println("[" + (t.containsWord(t.root, word, h) == true ) + "]"); 
        Aron.end();
    }
    public static void test12() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "abc";
        t.addWord(t.root, word, k);
        String word1 = "ab";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == false) + "]"); 
        Aron.end();
    }
    public static void test13() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "a";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == true) + "]"); 

        Aron.end();
    }
    public static void test14() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "aa";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == false) + "]"); 

        Aron.end();
    }
    public static void test15() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == true) + "]"); 

        Aron.end();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

class Node{
    boolean isStr;
    Node[] arr; 
    public Node(boolean isStr){
        this.isStr = isStr;
        arr = new Node[26];
    }
    public Node(){
        this.isStr = true;
        arr = new Node[26];
    }
}

public class MyTries_bad{
    public static void main(String[] args) {
        test0();
    }
    public static void test0() {
        Aron.beg();
        Node root = new Node();
        String str1 = "a";
        String str2 = "aa";
        String str3 = "ac";
        String str4 = "";
        String str5 = "aaa";
        add(str1, root, 0);
        add(str2, root, 0);

        print(root, "");

        Print.p(str1 + "=" + find(root, str1, 0));
        Print.p(str2 + "=" + find(root, str2, 0));
        Print.p(str3 + "=" + find(root, str3, 0));
        Print.p("abb" + "=" + find(root, "abb", 0));


        Aron.end();

    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
    public static void add(String str, Node node, int n){
        if (n < str.length()){
            int index = str.charAt(n) - 'a';
            if(node.arr[index] == null){
                node.arr[index] = new Node(false);
            }
            add(str, node.arr[index], n+1);
        }else{
            node.isStr = true;
        }
    }
    public static boolean find(Node node, String str, int k){
        if (node != null){
            if (k == str.length())
                return node.isStr;
            else{
                int index = str.charAt(k) - 'a';
                return find(node.arr[index], str, k+1);
            }
        }
        return false;
    }
    public static void print(Node node, String str){
        if(node != null){
            if(node.isStr){
                Print.p(str);
            }
            for(int i=0; i<26; i++){
                if(node.arr[i] != null){
                    String s = "" + (char)('a' + i);
                    print(node.arr[i], str + s);
                }
            }
        }else{
            Print.p(str);
        }
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class MyNode{
    String data;
    int count;
    public MyNode(String data, int count){
        this.data = data;
        this.count = count;
    }
}

class TextMap{

    public TextMap(){
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }
}

public class AnimalLogic{
    public static void main(String[] args) {
//        test0();
//        test1();
        //test2();
//        test3();
//        test4();
//        test5();
//        test00();
//        test11();
//        test12();
        test13();
    }

    static void test00(){
        Aron.beg();
        
        int n = random(1);
        Print.pbl("n=" + n);

        for(int i=0; i<10; i++){
            int n1 = random(2);
            Print.pbl("n1=" + n1);
        }

        Aron.end();
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public static void test12(){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }

    public static void test13(){
        Aron.beg();

        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        Map<Map<String, String>, Map<Integer, String>> revMap = createBiMap(map);

        String seedFirst = "one";
        String seedSecond = "two";
        int numWords = 10;
        List<String> wordList = generateText(numWords, seedFirst, seedSecond, map, revMap);
        Aron.printList(wordList);
    }

    public static List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }

//    public static Map<String, String> newKeyMap(Map<String, String> map, String newWord){
//        map.get
//    }

    public static Map<Map<String, String>, Map<Integer, String>> createBiMap(Map<Map<String, String>, Map<String, Integer>> map){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 
        return revMap;
    }

    public static void test11(){
        Aron.beg();
        String[] arr = {"dog", 
                        "cat", 
                        "cow", 
                        "dog", 
                        "cat", 
                        "cow", 
                        "rat", 
                        "pig"}; 

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();

        List<String> list = getWords("./text/animal_logic.txt"); 
        //Map<Map<String, String>, Map<String, Integer>> map = createMap(arr); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }


    public static Map<Map<String, String>, Map<String, Integer>> createMap(List<String> list){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        for(int i=0; i<list.size() - 2; i++){
            Map<String, String> key = new HashMap<String, String>(); 
            Map<String, Integer> value = new HashMap<String, Integer>(); 
            key.put(list.get(i), list.get(i+1)); 
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key); 
            if(v == null){
                map.put(key, value);
            }else{
                Integer n = v.get(list.get(i+2));
                if(n == null){
                    v.put(list.get(i+2), 1);
                }else{
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    public static Map<Map<String, String>, Map<String, Integer>> createMap(String[] arr){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        List<String> list = Arrays.asList(arr); 
        map = createMap(list);
        return map;
    }
    public static void test0(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");

        String fileName = "text/myfile.txt";
        List<String> list = getWords(fileName); 

        for(String s : list){
            List<String> pairList = pair(s); 
            for(String k : pairList){
                if(map.containsKey(k)){
                    int count = map.get(k);
                    count++;
                    map.put(k, count);
                }else{
                    map.put(k, 1);
                }
            }
        }
        
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        } 
        
        Aron.printList(list);

        Aron.end();
    }
    public static List<String> pair(String s){
        List<String> list = new ArrayList<String>(); 
        if(s.length() > 1){
            for(int k=0; k < s.length(); k++){
                for(int i=0; i < s.length()-(1 + k); i++){
                    list.add(s.substring(i, i+(2 + k)));
                }
            }
        }
        return list;
    }

    // read a text file capture all words
    // word: non-whitespace char 
    public static List<String> getWordsNonWhiteSpace(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)\\S+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read a text file and capture all words
    // word: a-z char
    public static List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }
    public static void test1(){
        Aron.beg();
        
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
                
        String fileName = "text/textfile.txt";
        List<String> list = getWordsNonWhiteSpace(fileName);
        Aron.printList(list);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        String s = "abc";                
        int len = s.length();

            // "abc" [ "" -> "abc"]
            //       [ "a" -> "bc"]
            //       [ "ab"-> "c" ]
            for(int j=0; j<len-1; j++){
                    String prefix = s.substring(0, j);
                    String suffix = s.substring(j, len);
                    Print.pbl("prefix=" + prefix);
                    Print.pbl("suffix=" + suffix);
            }

        Aron.end();
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public static Map<Integer, String> inverseMap(Map<String, Integer> map){

        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        return revMap;
    }
    public static void test5(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        Map<Integer, String> revMap = inverseMap(map); 

        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        String s = "abc";                
        
        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        
        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        // 1 -> k1
        // 2 -> k2
        // 3 -> k2

        Aron.end();
    }
} 

import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import classfile.*;

final class TextMap {
    String fileName;
    Map<List<String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() {
    }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = Aron.readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    public Map<List<String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<List<String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            List<String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.add(list.get(i));
            key.add(list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String prefix, String suffix, Map<List<String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {

        List<String> list = new ArrayList<String>();


        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            Print.pbl("firstPrefix =" + firstPrefix);
            Print.pbl("secondPrefix=" + secondPrefix);
            Print.pbl("inputSuffix=" + inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {

                        int ranKey = random(revValueMap.size());

                        String newSuffix = revValueMap.get(ranKey);
                        Print.pbl("newSuffix=" + newSuffix + " " + "ranKey=" + ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<List<String>, Map<String, Integer>> map) {

        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<List<String>, Map<String, Integer>> entry : map.entrySet()) {

            List<String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()) {
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        }
        return tableMap;
    }

    public List<String> textGeneMap() {

        List<String> list = getWords();
        map = prefixSuffixMap(list);
        // Map<List<String>, Map<String, Integer>> 

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<List<String>,  Map<String, Integer>> entry : map.entrySet()) {
            List<String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";

                for(String s : key){
                    Print.pp(s + " ");
                    str += s + " ";
                }
                str += "=>"

//                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "[" + valueEntry.getValue() + "]");
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                Ut.l();
                str += "\n";
                Print.pp("\n");
            }
            retList.add(str);
            Ut.l();
        }
        return retList;
    }

    public List<String> processFile(int maxWords, String prefix, String suffix) {
        Aron.beg();

        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class OpenFileFX extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");


        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                Print.pbl("file =" + file);
                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            Print.pbl("s=" + s);
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                Aron.beg();

                if(fileName != null) {
                    List<String> list = Aron.getWords(fileName);
                    Aron.printList(list);

                    if(prefixTF.getText().length() > 0 && prefixTF.getText().length() > 0) {
                        Print.pbl("prefixTF=" + prefixTF.getText());
                        Print.pbl("suffixTF=" + suffixTF.getText());
                        Print.pbl("maxWordsLable=" + maxWordsLable.getText());

                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            Print.pbl("maxWords=" + maxWords);
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                Print.pbl("s=" + s);
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }

                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }

                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 800, 600));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class NimGame{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        int num = 8;
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(num);
        boolean flag = false;
        boolean boo = nim(num, num, flag, list);
        System.out.println("nim[" + boo + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int num = 1;
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(num);
        boolean flag = false;
        boolean boo = nim(num, num, flag, list);
        System.out.println("nim[" + boo + "]"); 
        Aron.end();
    }
    // Init level = 0 
    public static boolean nim(int n, int prev, boolean flag, List<Integer> list){
        boolean ret = false;
        if(n == 0){
            if(prev == 1 && flag){
                for(Integer item : list){
                    System.out.println("item[" + item + "]"); 
                }
                ret = true;
            }
        }else if(n > 0){
            for(int i=1; i<=3; i++){
                list.add(n-i);
                System.out.println("[" + n + "]->(" + i + ")[" + (n-i) + "] flag[" + flag + "] prev[" + prev + "] i[" + i + "]"); 
                ret = nim(n-i, n, !flag, list);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        }
        return ret;
    } 
}

import java.util.*;
import java.io.*;
import classfile.*;

public class NonConsecutive{
    public static void main(String[] args) {
         test00_maxNonConsecutiveSum();
         test01_maxNonConsecutiveSum();
         test02_maxNonConsecutiveSum();
         test03_maxNonConsecutiveSum();
         test04_maxNonConsecutiveSum();
    }

    //[file=nonconsecutive.html title="maximum consecutive sum"
    // [ ] {4} 5
    // 
    // [4, 7]
    // m = 4
    // curr = 7 
    // max = 4 
    // => max = 7
    // --------------- 
    // [4, 7, 5]
    // m = 4 
    // curr = 7
    // max = 4
    // ------
    // m = 7
    // curr = 4 + 5 
    // max = 7
    // => max(9, 7) = 9
    // ---------------
    public static int maxNonConsecutiveSum(int[] arr){
        int max = 0;
        if(arr != null && arr.length > 0){
            int len = arr.length;
            int pmax = 0;
            max = arr[0];
            for(int i=1; i<len; i++){
                int m1 = Math.max(pmax + arr[i], arr[i]);
                int m2 = Math.max(max, arr[i]);
                pmax = max;
                max = Math.max(m1, m2);
            } 
        }
        return max;
    }
    //]

    static void test00_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 4);
        Aron.end();
    }
    static void test01_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 7);
        Aron.end();
    }
    static void test02_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 9);
        Aron.end();
    }
    static void test03_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5, 9, 1, 2, -4, 20}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 38);
        Aron.end();
    }
    static void test04_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5, 9, 90, 100}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 116);
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;


class Node {
    public Node left;
    public Node right;
    public Node next;
    public Character data;
    public boolean isVisited;
    public Node(Character n) {
        left = right = null;
        data = n;
        isVisited = false;
    }
}


public class NonRepeatingChar{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }

    static void test0(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a'}; 

        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 1;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test1(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a', 'c'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 9;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a', 'b', 'e', 'b'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 2;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Character[] arr = {'a'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 'a';
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test4(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a'}; 
        int len = arr.length;
        Character value = 'b';
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        Character[] arr = {'a', 'a', 'a', 'b', 'a'}; 
        int len = arr.length;
        Character value = 'b';
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    //[ file=nonrepeatingchar.html title=""
    static Character nonRepeatingChar(Character[] arr, int index){
        List<Node> list =  new LinkedList<Node>();
        if(arr != null){
            Map<Character, Node> map = new HashMap<Character, Node>();

            for(int i=0; i<arr.length; i++){
                if(i <= index){
                    Character ch = arr[i];
                    if(!map.containsKey(ch)){
                        Node node = new Node(ch);
                        list.add(node);
                        map.put(ch, node);
                    }else{
                        Node vNode = map.get(ch);
                        if(vNode != null){
                            list.remove(vNode);
                            map.put(ch, null);
                        }
                    }
                }else{
                    break;
                }
            }
        }
        if(list.size() > 0)
            return list.get(0).data;
        else
            return null;
    }
    //]
} 
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.List;

public class NumOperator{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test();
    }
    static int numOperator(int n){
        List<Integer> list = new ArrayList<Integer>();
        if(n == 0)
            list.add(0);
        else if(n > 0){
            while(n > 0){
                int r = n % 2;
                list.add(r);
                n = n/2;
            }
        }

        int sum = 0;
        for(int i=0; i<list.size(); i++){
            if(list.get(i) == 1)
                sum += i+1;
        }
        return sum;
    }
    static void test(){
        System.out.println(numOperator(5));
        System.out.println(numOperator(3));
    }
}
import java.util.*;

//Convert numerical number to English spoken words
class ConvertNumberToEnglish
{
    Map<Integer, String> map = new HashMap<Integer, String>();
    public ConvertNumberToEnglish()
    { }
    public void InitMap()
    {
        map.put(0, "[zero]");
        map.put(1, "[one]");
        map.put(2, "[two]");
        map.put(3, "[three]");
        map.put(4, "[four]");
        map.put(5, "[five]");
        map.put(6, "[six]");
        map.put(7, "[seven]");
        map.put(8, "[eight]");
        map.put(9, "[nine]");

        map.put(10, "[ten]");
        map.put(11, "[eleven]");
        map.put(12, "[twelve]");
        map.put(13, "[thirteen]");
        map.put(15, "[fifteen]");
        map.put(16, "[sixteen]");
        map.put(17, "[seventeen]");
        map.put(18, "[eighteen]");
        map.put(19, "[nineteen]");

        map.put(20, "[twenty]");
        map.put(30, "[thirty]");
        map.put(40, "[forty]");
        map.put(50, "[fifty]");
        map.put(60, "[sixty]");
        map.put(70, "[seventy]");
        map.put(80, "[eighty]");
        map.put(90, "[ninety]");

        map.put(100, "[hundred]");
        map.put(1000, "[thousand]");
        map.put(1000000, "[million]");
        map.put(1000000000, "[billion]");
    }
    public void convert(int num)
    {
        System.out.print("{"+num+"}=");
        if(num == 0)
            System.out.print(map.get(num));
        else if(num > 0)
        {
            int[][] array = table(num);
            int len = array.length;
            String s = "";
            for(int c=0; c < array.length; c++)
            {
                s = processRow(array[c], c) + s;
            }
            System.out.print(s);
        }
    }
    public int[][] table(int num)
    {
        int numRow = 0;
        if(num > 0)
            numRow = (int)(Math.log(num)/Math.log(1000)) + 1;

        int[][] array = new int[numRow][3];
        int col = 0;
        while(num > 0)
        {
           int r = num % 1000; 
           num /= 1000;
           int row = 0;
           while(r > 0)
           {
                int rr = r % 10;
                r /= 10;
                array[col][row] = rr;
                row++;
           }
           col++;
        }
        return array;
    }
    public String processRow(int[] row, int pow)
    {
        String first = "";
        String second = "";
        String third = "";
        String s ="";
        if(row[0] != 0 || row[1] != 0 || row[2] != 0)
        {
            if(row[0] > 0)
            {
                first = map.get(row[0]);
            }
            if(row[1] > 0)
            {
                second = map.get(row[1]*10);
            }
            if(row[2] > 0)
            {
                int r = row[2] % 100;
                third = map.get(r) + map.get(100);
            }
            if(pow > 0)
                s = third + second + first + map.get((int)Math.pow(1000, pow));
            else 
                s = third + second + first;
        }
        return s;
    }
}

public class NumberToWord
{
    public static void main(String[] args)
    {
        System.out.println("Convert Number to English Words");
        ConvertNumberToEnglish con = new ConvertNumberToEnglish();
        con.InitMap();
        con.convert(0);
        System.out.println();
        con.convert(123);
        System.out.println();
        con.convert(20004);
        System.out.println();
        con.convert(200005);
        System.out.println();
        con.convert(123346789);
        System.out.println();
        con.convert(987654321);
        System.out.println();
        con.convert(90000001);
        System.out.println();
        con.convert(100000000);
        System.out.println();
    }
}
import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import classfile.*;

final class TextMap {
    String fileName;
    Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() {
    }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = Aron.readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    public Map<Map<String, String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            Map<String, String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.put(list.get(i), list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String prefix, String suffix, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {

        List<String> list = new ArrayList<String>();


        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            Print.pbl("firstPrefix =" + firstPrefix);
            Print.pbl("secondPrefix=" + secondPrefix);
            Print.pbl("inputSuffix=" + inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {

                        int ranKey = random(revValueMap.size());

                        String newSuffix = revValueMap.get(ranKey);
                        Print.pbl("newSuffix=" + newSuffix + " " + "ranKey=" + ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<Map<String, String>, Map<String, Integer>> map) {

        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()) {
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        }
        return tableMap;
    }

    public List<String> textGeneMap() {

        List<String> list = getWords();
        map = prefixSuffixMap(list);

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");
                str += keyEntry.getKey() + " " + keyEntry.getValue() + " => ";

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "[" + valueEntry.getValue() + "]");
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                Ut.l();
                str += "\n";
                Print.pp("\n");
            }
            retList.add(str);
            Ut.l();
        }
        return retList;
    }

    public List<String> processFile(int maxWords, String prefix, String suffix) {
        Aron.beg();

        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class OpenFileFX extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");


        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                Print.pbl("file =" + file);
                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            Print.pbl("s=" + s);
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                Aron.beg();

                if(fileName != null) {
                    List<String> list = Aron.getWords(fileName);
                    Aron.printList(list);

                    if(prefixTF.getText().length() > 0 && prefixTF.getText().length() > 0) {
                        Print.pbl("prefixTF=" + prefixTF.getText());
                        Print.pbl("suffixTF=" + suffixTF.getText());
                        Print.pbl("maxWordsLable=" + maxWordsLable.getText());

                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            Print.pbl("maxWords=" + maxWords);
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                Print.pbl("s=" + s);
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }

                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }

                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 800, 600));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import org.apache.commons.lang3.StringUtils;

// padding example 
// use apache common lib
// jar file /Users/cat/myfile/github/JavaLib/commons-lang3-3.5.jar
public class PaddingExample{
    public static void main(String[] args) {
        String s1 = StringUtils.leftPad("reccoon", 10, '-');
        Print.pbl(s1);
        String s2 = StringUtils.leftPad("bat", 5, '=');
        Print.pbl(s2);
    }
}

public class PalindromeSpace
{
    public static void main(String[] args)
    {
        System.out.println("Palindrome With Space");
        
        boolean ret0 = isPalindrome(null);
        boolean ret1 = isPalindrome("");
        boolean ret2 = isPalindrome(" ");
        boolean ret3 = isPalindrome(" a");
        boolean ret4 = isPalindrome("a ");
        boolean ret5 = isPalindrome("ab");
        boolean ret6 = isPalindrome("aa");
        boolean ret7 = isPalindrome("a a");
        boolean ret8 = isPalindrome("a b");
        boolean ret9 = isPalindrome("a b ba");
        System.out.println("[null]["+ret0+"] []["+ret1+"] [ ]["+ret2+"] [ a]["+ret3+"] [a ]["+ret4+"] [ab]["+ret5+"] [aa]["+ret6+"] [a a]["+ret7+"] [a b]["+ret8+"] [a b ba]["+ret9+"]");
    }
    public static boolean isPalindrome2(String str) 
    {
        if( str != null)
        {
            int len = str.length();
            int i=0;
            for(i=0; i<len && str.charAt(i) != str(len-1-i); i++);
            return i == len;
        }
    }
    public static boolean isPalindrome(String str)
    {
        boolean ret = true;
        boolean done = false;
        if(str != null && str.length() > 1)
        {
            int len = str.length();
            int i = 0; 
            int j = len - 1;
            while(!done && ret)
            {
                if(str.charAt(i) == str.charAt(j)) 
                {
                    if(i == j || i == j - 1)
                        done = true;
                    else
                    {
                        if(i < len - 1)
                            i++;
                        if(j > 0)
                            j--;
                    }
                }
                else
                {
                    if(str.charAt(i) == ' ')
                    {
                        if(i < len - 1)
                            i++;
                    }
                    else if(str.charAt(j) == ' ') 
                    {
                        if(j > 0)
                            j--;
                    }
                    else
                    {
                        ret = false;
                    }
                }
            }
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;
import classfile.*;

enum Type{
    OPEN,
    CLOSE,
    ITEM,
    NONE
}

public class ParseBracketTree{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    public static void test0(){
        Aron.beg();

        String str = "[ 1 ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        Aron.printList(list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" [ 14 ]"
                    +"  [ 111 "
                         +" [ 112 ]"
                         +" [ 113 ]"
                    +"  ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        String str = "[ 1 ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        List<String> list2 = new ArrayList<String>(); 

        for(String s : list){
            if(getTokenType(s) != Type.OPEN)
                list2.add(s);
        }
        
        Iterator<String> ite = list2.iterator(); 
        Node root = buildTreeRecursion(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" [ 14 ]"
                    +"  [ 111 "
                         +" [ 112 ]"
                         +" [ 113 ]"
                    +"  ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        List<String> list2 = new ArrayList<String>(); 

        for(String s : list){
            if(getTokenType(s) != Type.OPEN)
                list2.add(s);
        }

        Aron.printList(list2, "(");
        
        Iterator<String> ite = list2.iterator(); 
        Node root = buildTreeRecursion(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static boolean validate(String fname){
        try{
            BufferedReader br = new BufferedReader(new FileReader(fname));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pbl(line);
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
        return true;
    }

    public static Node buildTree(Iterator<String> ite){
        Stack<Node> stack = new Stack<>();

        while(ite.hasNext()){
            String item = ite.next();
            if(getTokenType(item) == Type.ITEM){
                stack.push(new Node(item));
            }else if(getTokenType(item) == Type.CLOSE){
                if(stack.size() > 1){
                    Node node = stack.pop();
                    stack.peek().list.add(node);
                }
            }
        }
        return stack.peek();
    }
    public static Node buildTreeRecursion(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String item = ite.next();
            if(getTokenType(item) == Type.ITEM){
                root = buildTreeRecursion(ite);
            }else if(getTokenType(item) == Type.CLOSE){
                Node ret = buildTreeRecursion(ite);     
            }
        }
        return root;
    }

    public static Type getTokenType(String str){
        Pattern r = Pattern.compile("\\d+");
        if(str.equals("[")){
            return Type.OPEN;
        }else if(str.equals("]")){
            return Type.CLOSE;
        }else if(r.matcher(str).find()){
            return Type.ITEM;
        }
        return Type.NONE;
    }
    
    static void test9(){
        Aron.beg();
        Type type1 = getTokenType("[");
        Type type2 = getTokenType("]");
        Type type3 = getTokenType("123");
        Print.pbl(type1);
        Print.pbl(type2);
        Print.pbl(type3);
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Partition 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr = {1, 7};
		int left = 0;
		int right = Arr.length - 1;
		int piv = partition(Arr, left, right);
		System.out.println("piv=" + piv);
	}
	public static int partition(int[] Arr, int left, int right)
	{
		int ret = -1;
		if(Arr != null)
		{
			int len = Arr.length;
			if(len == 1)
				ret = 0;
			else if(len > 1)
			{
				int i=left;
				int j=len - 1;
				int pivot = Arr[left];
				while(i<j)
				{
					while(Arr[i] <= pivot && i < len-1) i++;
					while(Arr[j] > pivot && j > 0) j--;
					if(i < j)
					{
						int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;

				for(int k=0; k<len; k++)
				{
					System.out.println("Arr[" + k + "]=" + Arr[k]);
				}

			}
		}
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

public class PartitionArray{
    public static void main(String[] args) {
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    
    static void test3(){
        Aron.beg();
        Integer[] arr = {2, 0, 3, 0};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    } 
    static void test4(){
        Aron.beg();
        Integer[] arr = {2, 0, 3};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        Integer[] arr = {0, 0, 2, 0, 0, 3, 2, 0, 3};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        Integer[] arr = {0, 0, 0, 0, 0};
        Aron.printArray(arr);
        Aron.end();
    } 
    static void test7(){
        Aron.beg();
        Integer[] arr = {2, 3};
        Aron.printArray(arr);
        Aron.end();
    } 

    //[ file=partitionarray.html title=""
    static void partition(Integer[] arr){
        if(arr != null){
            int len = arr.length;
            int nonzero = len-1;
            for(int i=len-1; i >= 0; i--){
                if(arr[i] == 0){
                    int tmp = arr[i];
                    arr[i] = arr[nonzero];
                    arr[nonzero] = tmp;
                    nonzero--;
                }
            }
        }
    }
    //]
}
import java.util.*;
import java.io.*;
import classfile.*;

public class PartitionFB{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    public static void test0() {
        Aron.beg();

        Integer[] arr = {0, 2}; 
        Integer[] expectedArray = {2, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        Integer[] arr = {0}; 
        Integer[] expectedArray = {0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        Integer[] arr = {1}; 
        Integer[] expectedArray = {1}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();

        Integer[] arr = {1, 0}; 
        Integer[] expectedArray = {1, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();

        Integer[] arr = {0, 2, 0, 3, 0}; 
        Integer[] expectedArray = {2, 3, 0, 0, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void swap(Integer[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    //[ file=part3.html title=""
    // move all zeros to the right side of array
    // [1, 0, 3, 0] => [1, 3, 0, 0]
    public static void partition(Integer[] arr){
        if(arr != null){
            int zeroIndex = 0;
            int len = arr.length;
            for(int i=0; i<len; i++){
                if(arr[i].intValue() > 0){
                    if(i != zeroIndex)
                        swap(arr, i, zeroIndex);
                    // make sure the zeroIndex is not out of bounds
                    if(zeroIndex < len-1)
                        zeroIndex++;
                }
            }
        }
    }
    //]
}

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}

//Find the node from the Binary Tree and return the path from the current node
//to root
//The algorithm is similar to isBST() and use inorder traveral to walk through
//all the nodes, once the node is found, then recursion is terminated 
class PathToKBinarySearch 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
        
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        
        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        //swap(5, 15, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
		
        System.out.println("");
        PathToK(b1.getRoot(), 199);
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }

    public static boolean PathToK(Node node, int k)
    {
        if(node != null)
        {
            if(PathToK(node.left, k))
            {
		        System.out.println(node.data);
                return true;
            }
            if(node.data == k)
            {
		        System.out.println(node.data);
                return true;
            }
            if(PathToK(node.right, k))
            {
		        System.out.println(node.data);
                return true;
            }
        }
        return false;
    }
}
public class PatternMatch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    //"ab?"
    //Generate table for "ab?" pattern
    public static boolean match(String pattern, String str)
    {
        Map<Integer, Map<String, Integer>> map = new HashMap<Integer, Map<String, Character>>();

        /*
        for(int i=0; i<pattern.length(); i++)
        {
            char currChar = pattern.charAt(i);
            char nextChar = '0';
            if(i+1 < pattern.length())
                char nextch = pattern.charAt(i+1);
            //if(nextChar == '?')
            //else


        }
        */
    }
}
import java.io.*;
import java.lang.String;
import classfile.*; 

class PermRecursive {
    public static void main(String args[]) {
        test0_permutation();
        test1_permutation();
        test2_permutation();
        test0_permutationPrefix();
        test1_permutationPrefix();
        test2_permutationPrefix();
        test3_permutationPrefix();
        //test1();
        //test2();
    }
    
    static void test0_permutation(){
        Aron.beg();
        char[] charArr= {'a'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test1_permutation(){
        Aron.beg();
        char[] charArr= {'a', 'b'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test2_permutation(){
        Aron.beg();
        char[] charArr= {'a', 'b', 'c'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test0_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test1_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "a";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test2_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "ab";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test3_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "abc";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    public static void test1() {
        char[] charArr= {'a', 'b', 'c'};
        int[] arr = {100};
        int inx = 0;

        System.out.println("digraph G {\n");
        permu_Graph(charArr, inx, arr);
        System.out.println("}\n");
    }
    public static void test2() {
        // Print the content on the console
        //System.out.println ("cool");
        int inx=0;
        char[] charArr= {'a', 'b', 'c'};
        //char[] charArr={};
        //permu(charArr, inx);
        //String s = removeChar("abcde", 2);
        //System.out.println ("s=" + s);

        int[][] array = { {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        int col = 0;
        printUpperTriangle(array, col);
    }

    public static void permu(char[] charArr, int inx) {
        if( charArr != null) {
            if(charArr.length == inx) {
                for(int i=0; i<charArr.length; i++)
                    System.out.print(charArr[i]+" ");
                System.out.println();
            } else
                for(int i=inx; i<charArr.length; i++) {
                    char tmp = charArr[i];

//                    charArr[i] = charArr[inx];
//                    charArr[inx] = tmp;
//                    permu(charArr, inx+1);
                    Aron.swap(charArr, i, inx);

                    tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;
                }
        }
    }

    public static void permu_Graph(char[] charArr, int inx, int[] arr) {
        if( charArr != null) {
            if(charArr.length == inx) {
                for(int i=0; i<charArr.length; i++)
                    System.out.print(charArr[i]+" ");
                System.out.println();
            } else {
                for(int i=inx; i<charArr.length; i++) {
                    char tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;

                    permu_Graph(charArr, inx+1, arr);

                    tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;
                }
            }
        }
    }
    public static void printUpperTriangle(int[][] array, int col) {
        for(int row=col; row<array.length; row++) {
            printUpperTriangle(array, col+1);
            System.out.println("[" + col + "][" + row+ "]=" + array[col][row]);
        }
    }

    //[ file=permuteJava.html title=" Generate permutation for n characters"
    // generate all permutation from given char[], e.g. ['a', 'b']
    //
    public static void permutation(char[] arr, int index){
        if(index == arr.length){
            Aron.printArray(arr);
        }else{
            if(arr != null){
                int len = arr.length;
                for(int i=index; i<len; i++){
                    Aron.swap(arr, i, index);
                    permutation(arr, index + 1);
                    Aron.swap(arr, i, index);
                } 
            }
        }
    }
    //]

    
    //[ file=permutationprefix.html title=" Generate all permutation in sorted order"
    // permutations are in sorted ordering in lexicographically
    public static void permutationPrefix(String prefix, String str){
        if(str != null){
            if(str.length() == 0){
                Print.p(prefix);
            }else{
                int len = str.length();
                for(int i=0; i<len; i++){
                    String s = str.charAt(i) + "";
                    permutationPrefix(prefix + s, remove(str, i));
                } 
            }
        }
    }
    public static String remove(String str, int index){
        String s = "";
        for(int i=0; i<str.length(); i++){
            if(i != index)
                s += str.charAt(i) + "";
        } 
        return s;
    }
    //]
}
import java.util.*;
public class PermRepeated 
{
    public static void main(String[] args)
    {
        System.out.println("Print all permuation character with repeating character!");
        String s = "ABC";
        char[] array = new char[s.length()];
        int depth = 0;
        Set<Character> map = new LinkedHashSet<Character>();
        //permRepeated(s, array, depth);
        //perm(s, array, depth, map);

        int k=2;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i);

        test1();
    }

    public static void ExcelSheetRowNumber(String s)
    {
        char[] array = new char[s.length()];
        int depth = 0;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i);
    }


    //Given string character array and integer k,
    //print all permutation with repeatation string length k 
    public static void permRepeatedChooseK(String s, char[] array, int depth, int k)
    {
        if(depth == k)
        {
            for(int i=0; i<depth; i++)
            {
                System.out.print("["+array[i]+"]");
            }
            System.out.println();
        }
        else 
        {
            if(array != null && s != null)
            {
                for(int i=0; i<s.length(); i++)
                {
                    array[depth] = s.charAt(i);
                    permRepeatedChooseK(s, array, depth+1, k);
                }
            }
        }
    }

    public static void permRepeated(String s, char[] array, int depth)
    {
        if(s != null)
        {
            if(s.length() == depth)
            {
                for(int i=0; i<depth; i++)
                {
                    System.out.print("["+array[i]+"]");
                }
                System.out.println();
            }
            else
            {
                for(int i=0; i<s.length(); i++)
                {
                    array[depth] = s.charAt(i);
                    permRepeated(s, array, depth+1);
                }
            }
        }
    }
    public static void permRepeatingChar(Character[] array, int depth, Set<String> set)
    {
        if(depth == array.length)
        {
            String s="";
            for(Character ch:array)
                s += ch.toString();

            if(!set.contains(s))
                set.add(s);
        }
        else
        {
            for(int i=depth; i<array.length; i++)
            {
                Aron.swap(array, i, depth);
                permRepeatingChar(array, depth+1, set);
                Aron.swap(array, i, depth);
            }
        }
    }
    public static void perm(String s, char[] array, int depth, Set<Character> map)
    {
        if(s != null)
        {
            if(s.length() == depth)
            {
                for(Character ch: map)
                    System.out.print(ch);
                System.out.println();
            }
            else
            {
                for(int i=0; i<s.length(); i++)
                {
                    Character ch = new Character(s.charAt(i));
                    if(!map.contains(ch))
                    {        
                        map.add(ch);
                        perm(s, array, depth+1, map);
                        map.remove(ch);
                    }
                } 
            }
        }
    }
    public static void test1()
    {
        Character[] array = {'a', 'b', 'b'};
        int depth = 0;
        Set<String> set = new LinkedHashSet<String>();
        permRepeatingChar(array, depth, set);
        for(String item: set)
            System.out.println(item);
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Permu2
{
	public static void main(String args[])
	{
		per("abcd");
	}
	public static void per(String str)
	{
		Vector<String> vet = new Vector<String>();
		if(str != null)
		{
			int len = str.length();
			if(len > 0)
			{
				vet.add(str.charAt(0) + "");
				Vector<String> vet2 = new Vector<String>();
				for(int j = 1; j < len; j++)
				{
					for(int i = 0; i < vet.size(); i++)
					{
						Vector<String> vet1 = new Vector<String>();
						vet1 = Combin2(vet.get(i), str.charAt(j) + "");	

						for(int k=0; k<vet1.size(); k++)
							vet2.add(vet1.get(k));
					}	
					vet.clear();

					for(int x=0; x<vet2.size(); x++)
						vet.add(vet2.get(x));
					vet2.clear();

				}
				for(int i = 0; i < vet.size(); i++)
				{
					System.out.println(vet.get(i));
				}
			}
		}	
	}

	public static Vector<String>  Combin2(String str, String ch)
	{
		Vector<String> vet = new Vector<String>();
		for(int i = 0; i < str.length() + 1; i++)
		{
			StringBuffer sb = new StringBuffer(str);
			sb.insert(i, ch);
			vet.add(sb.toString());
		}
		return vet;
	}
	public static Vector<String>  Combin(String str, String ch)
	{
		Vector<String> vet = new Vector<String>();
		int i = 0;
		for(i = 0; i < str.length() + 1; i++)
		{
			String s = "";
			for(int j = 0; j < str.length(); j++)
			{
				if(i == j)
					s = s + ch; 
				s = s + str.charAt(j);
			}	
			if(i == str.length())
				s = s+ch;
			System.out.println (s);
		}
		return vet;
	}
}
import java.io.*;
import java.util.*;

//a1b -> a1b, A1b, a1B, A1B
//permut upper and lower cases

class PermuBin
{
	public static void main(String args[])
	{
		System.out.println("cool");
		Vector<String> v = perm("1");
		for(int i=0; i<v.size(); i++)
			System.out.println(v.get(i));
	}
	public static Vector<String> perm(String str)
	{ Vector<String> v = new Vector<String>();
		Vector<String> vet = new Vector<String>();
		v.add("$");
		if( str != null && str.length() > 0)
		{ 
			for(int j=0; j<str.length(); j++)
			{
				char ch = str.charAt(j);
				for(int i=0; i<v.size(); i++)
				{ String s="";
					if('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z')			
					{ if(j != 0 || i != 0)
						{
							s = v.get(i) + Character.toUpperCase(ch); 
							vet.add(s);
							s = v.get(i) + Character.toLowerCase(ch); 
							vet.add(s);
						}
						else
						{ 
							vet.add(Character.toUpperCase(ch)+"");
							vet.add(Character.toLowerCase(ch)+"");
						}
					}
					else
					{ if(j != 0 || i != 0)
						{ s = v.get(i) + ch; 
							vet.add(s);
						}
						else
						{ s = ch + ""; 
							vet.add(s);
						}
					}
				}
				v.clear();
				for(int i=0; i<vet.size(); i++)
					v.add(vet.get(i));
				vet.clear();
			}
		}
		return v;
	}
}
public class PermutationPrefix {
    public static void main(String[] args) {
        permute("", "abc");
    }
    public static void permute(String prefix, String s) {
        if(s.length() == 0)
            System.out.println(prefix);
        else {
            for(int i=0; i< s.length(); i++) {
                permute(prefix + (s.charAt(i) + ""), remove(s, i));
            }
        }
    }
    public static String remove(String s, int index) {
        String ret = "";
        for(int i=0; i<s.length(); i++) {
            if(i != index)
                ret += s.charAt(i) + "";
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class Pi{
    public static void main(String[] args) {
        test0();
        test1();
    }

    public static double calculatePI(int nStep){
       double pi = 1.0;
       for(int i=1; i<nStep; i++){
           if(i % 2 == 1)
               pi += (double)-1/(2*i + 1);
           else
               pi += (double)1/(2*i + 1);
       } 
       Print.pbl(4*pi);
       return 4*pi;
    }
    public static void test0(){
        Aron.beg();
        int nStep = 1000;
        calculatePI(nStep);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class Pill{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();
        int x = 4;
        int y = 5;
        pill(x, y);
        Aron.end();
    }
    static void pill(int x, int y){
        if(x > 0 && y > 0){
            System.out.println("[" + x + " " + (y-1) + "]"); 
            pill(x, y-1);
            System.out.println("[" + (x-1) + " " + y + "]"); 
            pill(x-1, y);
        }
    }
} 
// java enum type like a class
public enum Planet {
    MERCURY (3.303e+23, 2.4397e6),
    VENUS   (4.869e+24, 6.0518e6),
    EARTH   (5.976e+24, 6.37814e6),
    MARS    (6.421e+23, 3.3972e6),
    JUPITER (1.9e+27,   7.1492e7),
    SATURN  (5.688e+26, 6.0268e7),
    URANUS  (8.686e+25, 2.5559e7),
    NEPTUNE (1.024e+26, 2.4746e7);

    private final double mass;   // in kilograms
    private final double radius; // in meters
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }
    private double mass() { return mass; }
    private double radius() { return radius; }

    // universal gravitational constant  (m3 kg-1 s-2)
    public static final double G = 6.67300E-11;

    double surfaceGravity() {
        return G * mass / (radius * radius);
    }
    double surfaceWeight(double otherMass) {
        return otherMass * surfaceGravity();
    }
    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Usage: java Planet <earth_weight>");
            System.exit(-1);
        }
        double earthWeight = Double.parseDouble(args[0]);
        double mass = earthWeight/EARTH.surfaceGravity();
        for (Planet p : Planet.values())
           System.out.printf("Your weight on %s is %f%n",
                             p, p.surfaceWeight(mass));
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class PreOrderToTree 
{
	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();
		
		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		/*
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		*/

		Node r = b1.getRoot();
		//PreOrder(r);

		int[] Arr = {10, 1, 12};
		ArrayList<Integer> leftArr = new ArrayList<Integer>();
		ArrayList<Integer> rightArr = new ArrayList<Integer>();

		//splitInOrder(Arr, leftArr, rightArr);

		Node myroot= PreOrderToTree(Arr);
		PreOrder(myroot);
	}
	
	public static Node PreOrderToTree(int[] Arr)
	{
		ArrayList<Integer> leftList = new ArrayList<Integer>();
		ArrayList<Integer> rightList = new ArrayList<Integer>();
		Node root=null;
		if(Arr != null && Arr.length > 0)
		{
			root = new Node(splitInOrder(Arr, leftList, rightList));

			int[] leftArr = new int[leftList.size()];
			int[] rightArr = new int[rightList.size()];
			for(int i=0; i<leftList.size(); i++)
				leftArr[i] = leftList.get(i);

			for(int i=0; i<rightList.size(); i++)
				rightArr[i] = rightList.get(rightList.size()-1 - i); //keep the order: [root] [ left subtree] [ right subtree]

			root.left = PreOrderToTree(leftArr);	
			root.right = PreOrderToTree(rightArr);
		}
		return root;
	}
	public static int splitInOrder(int[] Arr, ArrayList<Integer> leftList, ArrayList<Integer> rightList)
	{
		int rootNum=0;
		if( Arr != null && Arr.length > 0 && leftList != null && rightList != null)
		{
			int len = Arr.length;
			rootNum = Arr[0];

			if( len > 1)
			{
				int i=1;
				int j=len-1;

				int nl = 0, nr = 0;
				while(i <= j)
				{
					while(i < len && rootNum > Arr[i]) 
						leftList.add(Arr[i++]); 

					while(j > 0 && rootNum < Arr[j])
						rightList.add(Arr[j--]);
				}
				
				for(i=0; i<leftList.size(); i++)
				{ System.out.println(leftList.get(i)); }

				System.out.println(); 
				for(i=0; i<rightList.size(); i++)
				{ System.out.println(rightList.get(i)); }
			}
		}
		return rootNum;
	}
	public static void PreOrder(Node root)
	{
		if(root != null)
		{
			System.out.println("pre=" + root.data);
			PreOrder(root.left);
			PreOrder(root.right);
		}
	}
}
import java.io.IOException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;
import java.util.*;

import classfile.*;

           
//         4
//      2     5
//    1   3
//    pre [4 2 1 3 5]
//    post[1 3 2 5 4]
//
//[test0]
//--------------------------------------------------------------------------
//[4][2][1][3][5]
//--------------------------------------------------------------------------
//[1][3][2][5][4]
//--------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
public class PrePostTree{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();
        List<Integer> preList = Arrays.asList(4, 2, 1, 3, 5);
        List<Integer> postList = Arrays.asList(1, 3, 2, 5, 4);

        Node r = buildTreePrePost(preList, postList);
        Aron.preorder(r);
        Ut.l();
        Aron.postorder(r);
        Ut.l();
        Aron.end();
    }

//pre order [r][left][right]
//post order[left][right][r]

// [1, 2, 3, 4]
    public static Node buildTreePrePost(List<Integer> preList, List<Integer> postList) {
        Node parent = null;
        if(preList != null || postList != null) {
            if(preList.size() == postList.size() && preList.size() > 0) {
                parent = new Node(preList.get(0));
                List<Integer> subPreList = preList.subList(1, preList.size());
                List<Integer> subPostList = postList.subList(0, postList.size()-1);
                if(subPreList.size() == subPostList.size() && subPreList.size() > 0) {
                    Integer subRoot = subPreList.get(0);
                    List<Integer> leftPostList  = postLeft(subPostList, subRoot);
                    List<Integer> rightPostList = postRight(subPostList, subRoot);
                    List<Integer> leftPreList   = preLeft(subPreList, rightPostList);
                    List<Integer> rightPreList  = preRight(subPreList, leftPostList);
                    parent.left = buildTreePrePost(leftPreList, leftPostList);
                    parent.right = buildTreePrePost(rightPostList, rightPostList);
                }
            }
        }
        return parent;
    }
    public static List<Integer> preRight(List<Integer> list, List<Integer> leftList) {
        List<Integer> rightList = new ArrayList<Integer>(); 
        Set<Integer> set = new HashSet<Integer>(leftList);
        for(Integer n: list){
            if(!set.contains(n)){
                rightList.add(n);
            }
        }
        return rightList;
    }
    public static List<Integer> preLeft(List<Integer> list, List<Integer> rightList) {
        List<Integer> leftList = new ArrayList<Integer>(); 
        Set<Integer> set = new HashSet<Integer>(rightList);
        for(Integer n: list){
            if(!set.contains(n)){
                leftList.add(n);
            }
        }
        return leftList;
    }

    public static List<Integer> postRight(List<Integer> list, Integer r) {
        List<Integer> rightList = new ArrayList<Integer>(); 
        boolean equal = false;
        for(Integer n : list) {
            if(equal)
                rightList.add(n);

            if(n.intValue() == r.intValue())
                equal = true;
        }
        return rightList;
    }
    public static List<Integer> postLeft(List<Integer> list, Integer r) {
        List<Integer> leftList = new ArrayList<Integer>(); 
        for(Integer n : list) {
            if(n.intValue() != r.intValue())
                leftList.add(n);
        }
        return leftList;
    }
}


import java.util.*;

class Node {
    Node next;
    String key;
    String word;
    public Node(String key, String word) {
        this.key = key;
        this.word = word;
    }
}

public class PrefixMap {
    public static void main(String[] args) {
        test1();
        test2();
    }
    public static void test1() {
        String s = "abc";
        for(int i=0; i<s.length(); i++) {
            String str = s.substring(0, i+1);
            System.out.println("str="+str);
        }
    }
    public static void test2() {
        String str = "My dog is god and done what the hell is going on yep this sucks what the hell is going on yep this sucks";
        String[] array = str.split(" ");
        List<String> list = Arrays.asList(array);
        Map<String, Node> map = buildMap(list);
        for(String key:map.keySet()) {
            Node curr = map.get(key);
            System.out.print("{"+key+"}");
            while(curr != null) {
                System.out.print("->["+curr.word+"]");
                curr = curr.next;
            }
            System.out.println();
        }
    }
    public static Map<String, Node> buildMap(List<String> list) {
        Map<String, Node> map = new HashMap<String, Node>();
        for(String word:list) {
            prefixWord(word, map);
        }
        return map;
    }
    public static void prefixWord(String word, Map<String, Node> map) {
        for(int i=0; i<word.length(); i++) {
            String key = word.substring(0, i+1);
            if(map.containsKey(key)) {
                Node curr = map.get(key);
                Node prev = null;
                while(curr != null) {
                    if(curr.word.equals(word))
                        break;
                    else {
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(curr == null)
                    prev.next = new Node(key, word);
            } else {
                map.put(key, new Node(key, word));
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class PreorderIteration
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(15);
		
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		
		
		PreorderIteration(b1.getRoot());
		System.out.println();
		Inorder(b1.getRoot());
	}
	//in order traversal using iteration
	public static void InorderIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					st.push(cur);
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					System.out.println("no.data=" + no.data);
					cur = no.right;
				}
			}
		}
	}

	public static void PreorderIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					System.out.println("cur.data=" + cur.data);
					st.push(cur);
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					cur = no.right;
				}
			}
		}
	}	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

class PrettyBinPrint {
    public static Node prev = null;
    public static void main(String args[]) {
       test0(); 
       //test1(); 
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(14);
        b1.insert(17);
        b1.insert(19);

        b1.insert(16);
        b1.insert(10);
//        b1.insert(18);
//        b1.insert(60);
//        b1.insert(2);
//        b1.insert(8);
//        b1.insert(70);

        int[] Arr = new int[100];
        int len=0;
        Node r = b1.root;

        Aron.levelOrder(r); 

        System.out.println(contain(r, 15));
        System.out.println();
        int indent=1;
        Aron.prettyPrint(r, indent);
        System.out.println();

        Aron.binImage(r);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);

        int[] arr = new int[20]; 
        int index = 0;
        Aron.printAllPath(b1.root, arr, index); 

        Aron.binImage(b1.root);
        Aron.end();
    } 

    public static int MaxDepth(Node r) {
        if( r != null) {
            int nl = MaxDepth(r.left);
            int nr = MaxDepth(r.right);

            return (nl>nr?nl:nr)+1;
        }
        return 0;
    }

    public static boolean contain(Node r, int value) {
        if( r != null) {
            if(contain(r.left, value))
                return true;
            if(r.data == value)
                return true;
            if(contain(r.right, value))
                return true;
        }
        return false;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class PreviousNumberBin{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test_next();
    }
    public static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 7;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 1;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }

    public static void test2(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 15;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }

    // print previous number, previous element, previous node 
    // previous num in binary tree, previous n in binary tree, previous n in binarytree
    // microsoft interview, ms inerview, MS interview
    public static boolean previous(Node r, int n, Node prev){
        if( r != null){
            if(previous(r.left, n, prev))
                return true;
            if(r.data == n){
                if(prev == null)
                    Print.pbl(-1);
                else
                    Print.pbl(prev.data);
                return true;
            }
            if(previous(r.right, n, r))
                return true;
        }
        return false;
    }
    
    static void test_next(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 5;
        if(!next(b1.root, n)){
            Print.pp("null");
        }

        Aron.end();
    }

    // print the next node, next node,
    // next node from binary tree, next node binary tree
    static Node nextNode = null;
    public static boolean next(Node r, int n){
        if(r != null){
            if(next(r.left, n))
               return true;

            if(nextNode != null){
                Print.pb("next node=" + r.data);
                return true;
            }

            if(r.data == n){
                nextNode = r;
            }

            if(next(r.right, n))
                return true;
        }
        return false;
    }
} 

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import classfile.*;

public class Prime {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        long startTime = System.currentTimeMillis();
        Prime(100000);
        long endTime = System.currentTimeMillis();
        long diff = endTime - startTime;
        System.out.println("diff=" + diff);
    }
    

    //Find all the primes from 2 to n
    public static void Prime(int n) {
        boolean[] prime = new boolean[n];
        for(int i=0; i<n; i++)
            prime[i] = true;

        for(int i=2; i<n; i++) {
            for(int j=2; j<i && prime[i]; j++) {
                if(prime[j] && (i % j) == 0)
                    prime[i] = false;
            }
        }
        for(int i=2; i<n; i++) {
            System.out.println("[" + i + "]=" + prime[i]);
        }
    }

    // generate n primes
    public static List<Integer> nPrime(int n) {
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int count = 1;
        int num = 3;
        while(count <= n) {
            boolean isPrime = true;
            for(Integer p : list) {
                if(num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(num);
                count++;
            }
            num++;
        }
        return list;
    }
    //[ file=allprime.html title=""
    // generate all prime are up to n
    public static List<Integer> allPrime(int n) {
        List<Integer> list = new ArrayList<Integer>();
        if(n > 1) {
            list.add(2);
            for(int i=3; i<=n; i++) {
                boolean isPrime = true;
                for(int j=0; j<list.size() && isPrime; j++) {
                    if(i % list.get(j) == 0)
                        isPrime = false;
                }
                if(isPrime)
                    list.add(i);
            }
        }
        return list;
    }
    //]

    //[file=checkprime.html title=""
    public static boolean prime(int d, int n) {
        if(n == 2)
            return true;
        else if(n % d == 0)
            return false;
        else if(d*d <= n)
            return prime(d+1, n);
        else
            return true;
    }
    public static boolean isPrimeLoop(int n) {
        if( n == 2)
            return true;
        for(int d=2; d*d <= n; d++) {
            if(n % d == 0)
                return false;
        }
        return true;
    }
    //]
}
public class PrintTriangle 
{
    public static void main(String[] args)
    {
        int array[][] = new int[][]{
        { 0, 2, 3, 4, 5 },
        { 0, 0, 1, 2, 9 },
        { 0, 0, 0, 6, 5 },
        { 0, 0, 0, 0, 7 },
        { 0, 0, 0, 0, 0 }
        };
        System.out.println("Hello World!");
        int depth = 0;
        int max = Triangle(array, 0, 0);
        System.out.println("max="+max);
    }
    public static int Triangle(int[][] array, int row, int depth)
    {
        int max = 0;
        if(array != null)
        {
            int height = array.length;
            int width  = array[0] != null ? array[0].length : 0;
            //System.out.println("height="+height);
            //System.out.println("width ="+width);
            if(depth < width)
            {
                for(int i=0; i<width; i++)
                {
                    if(row < height && array[depth][i] != 0 && i != row)
                    {
                        int m = Triangle(array, i, depth+1) + array[depth][i];
                        max = max < m? m : max; 
                        System.out.println("["+depth+"]["+i+"]="+array[depth][i]);
                    }
                }
            }
        }
        return max;
    }
}
import java.util.*;
import classfile.*;

// priority heap compareto compareTo heapify heap
//[ file=priorityheap.html title=""
class Contact implements Comparable<Contact> {
    String name;
    String addr;
    int    age;
    public Contact(String name, String addr, int age) {
        this.name = name;
        this.addr = addr;
        this.age = age;
    }

    //Minimum heap
    public int compareTo(Contact c) {
        return this.age - c.age;
        //Maximum heap
        //return -(this.age - c.age);
    }

    public String toString() {
        return "["+name+"]["+addr+"]["+age+"]";
    }
}

public class PriorityQueueHeap {
    public static void main(String[] args) {
        test1();
    }
    public static void test1() {
        System.out.println("Minimum/Maximum Heap PriorityQueue");
        PriorityQueue<Contact> miniHeap = new PriorityQueue<Contact>();
        miniHeap.add(new Contact("David", "U.S", 3));
        miniHeap.add(new Contact("John", "U.S", 4));
        miniHeap.add(new Contact("Johnny", "U.S", 2));
        miniHeap.add(new Contact("Nathan", "U.S", 1));

        int k = 3;
        while(k > 0) {
            Print.p(miniHeap.remove().toString());
            k--;
        }
    }
}
//]
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.LineIterator;
import classfile.*;

// parse CVS file
public class ProcessCVS{
    public static void main(String[] args) {
        test0();
        //test1();
        //writeCrapToFile();
    }

    public static void test0() {
        long ti, tf;
        ti = System.currentTimeMillis();
        //String cvsFile = "/Users/cat/myfile/github/java/text/acl.cvs";
        String cvsFile = "/Users/cat/myfile/github/java/text/big.txt";
        String outFile = "/Users/cat/myfile/github/java/text/acl_out.txt";
        convertCVS(cvsFile, outFile);
        tf = System.currentTimeMillis();
        Print.pbl("Finish. Total time:" + (tf - ti)/1000.00); 
    }
    public static void test1() {
        long ti, tf;
        ti = System.currentTimeMillis();
        //String cvsFile = "/Users/cat/myfile/github/java/text/acl.cvs";
        String cvsFile = "/Users/cat/myfile/github/java/text/big.txt";
        String outFile = "/Users/cat/myfile/github/java/text/acl_out.txt";
        convertCVSList(cvsFile, outFile);
        tf = System.currentTimeMillis();
        Print.pbl("Finish. Total time:" + (tf - ti)/1000.00); 
    }

    public static String leftPad(String str, int max, int len) {
        int diff = max - len;
        if(diff > 0) {
            for(int i=0; i<diff; i++)
                str = " " + str;
        }
        return str;
    }
    public static String rightPad(String str, int max, int len) {
        int diff = max - len;
        if(diff > 0) {
            for(int i=0; i<diff; i++)
                str += " ";
        }
        return str;
    }

    // if str is a string, strim two double quotes. O.W return null
    public static String getString(String str) {
        if(str != null) {
            Pattern pattern = Pattern.compile("\"([^\"]*)\"");
            Matcher matcher = pattern.matcher(str);
            while(matcher.find()) {
                for(int i=1; i<=matcher.groupCount(); i++) {
                    if(matcher.group(i) != null)
                        return matcher.group(i);
                }
            }
        }
        return null;
    }

    public static int getMax(List<String> list) {
        int max = 0;
        for(String s : list) {
            if(getString(s) != null) {
                int l = s.length() - 2;
                if(l > max)
                    max = l;
            } else {
                if(s.length() > max)
                    max = s.length();
            }
        }
        return max;
    }

    public static void convertCVS(String cvsFile, String outFile) {

        // match string or number/decimal
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        FileWriter fstream = null;
        BufferedWriter out = null;

        try {
            fstream = new FileWriter(outFile);
            out = new BufferedWriter(fstream);

            LineIterator it = FileUtils.lineIterator(new File(cvsFile), "UTF-8");
            while (it.hasNext()) {
                String s = it.next();
                Matcher matcher = pattern.matcher(s);
                int len = 0;
                List<String> row = new ArrayList<String>();
                while(matcher.find()) {
                    for(int i=1; i<= matcher.groupCount(); i++) {
                        if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                            len = matcher.group(i).length();

                            String ss = matcher.group(i);
                            if(getString(ss) != null) {
                                // ss is string 
                                String str1 = ss.replace("\\r\\n", " ");
                                row.add(str1);
                            } else {
                                // ss is number or decimal 
                                row.add(matcher.group(i));
                            }
                        }
                    }
                }
                int max = getMax(row);

                for(int i=0; i<row.size(); i++){
                    String item = row.get(i);
                    String newStr = getString(item);
                    if(newStr != null) {
                        String paddedStr = rightPad(newStr, max, newStr.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }else{
                        String paddedStr = leftPad(item, max, item.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }
                }
                out.write("\r\n");
            }

            out.close();
        } catch(IOException e) {
            System.err.println(e.getMessage());
        }
    }

    public static void convertCVSList(String cvsFile, String outFile) {

        // match string or number/decimal
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        FileWriter fstream = null;
        BufferedWriter out = null;

        try {
            fstream = new FileWriter(outFile);
            out = new BufferedWriter(fstream);

            List<String> list = Aron.readFile(cvsFile);
            for(String s : list) {
                Matcher matcher = pattern.matcher(s);
                int len = 0;
                List<String> row = new ArrayList<String>();
                while(matcher.find()) {
                    for(int i=1; i<= matcher.groupCount(); i++) {
                        if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                            len = matcher.group(i).length();

                            String ss = matcher.group(i);
                            if(getString(ss) != null) {
                                // ss is string 
                                String str1 = ss.replace("\\r\\n", " ");
                                row.add(str1);
                            } else {
                                // ss is number or decimal 
                                row.add(matcher.group(i));
                            }
                        }
                    }
                }
                int max = getMax(row);

                for(int i=0; i<row.size(); i++){
                    String item = row.get(i);
                    String newStr = getString(item);
                    if(newStr != null) {
                        String paddedStr = rightPad(newStr, max, newStr.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }else{
                        String paddedStr = leftPad(item, max, item.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }
                }
                out.write("\r\n");
            }

            out.close();
        } catch(IOException e) {
            System.err.println(e.getMessage());
        }
    }
    public static void writeCrapToFile(){
        String fname = "./text/big.txt";
        List<String> list = new ArrayList<String>(); 
        for(int i=0; i<100000; i++){
            list.add("\"dog cat\"" + "," + "12334" + "," + "341.44" + "\n");
        } 
       Aron.writeFile(fname, list);
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

interface Publisher{
    public void publish(String msg);
}

class News implements Publisher{
    HashSet<Subscriber> set = new HashSet<Subscriber>();
    public void publish(String msg){
        for(Subscriber s : set){
            s.msgList.add(msg);
        }
    }

    public void addSub(Subscriber sub){
        set.add(sub);
    }
}

interface Subscriber{
    public void getPublisher();
}

class User1 implements Subscriber{
    Publisher pub;
    List<String> msgList = new ArrayList<String>();
    public Subscriber(Publisher pub){
        this.pub = pub;
    }
    public void getPublisher(){
        pub.publish();
    }
    public void add(String msg){
        msgList.add(msg);
    }
    public void show(){
        for(String s : msgList){
            Print.p(msg);
        }
    }
}


public class PublicSubscribe{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

/**
  * solve eight queen problem with backtrack 
  */
public class Queen 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        final int len = 4;
        int[][] board = new int[len][len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                board[i][j] = i*len+j;

        int[] path = new int[len];
        int row = 0;
        queen(board, row, path);
    }
    public static void queen(int[][] board, int row, int[] path)
    {
        if(board != null && board[0] != null)
        {
            int len = board.length;
            for(int col = 0; col < len && row < len; col++)
            {
                if(consistent(path, row, col))
                {
                    path[row] = col;
                    queen(board, row+1, path);
                }
            }

            if(row == len)
            {
                for(int r=0; r<len; r++)
                {
                    for(int c=0; c<len; c++)
                    {
                        if(path[r] == c)
                            System.out.print("["+"x"+"]");        
                        else
                            System.out.print("["+"0"+ "]");        

                    }
                    System.out.println("");        
                }
                System.out.println("");        
            }
        }
    }
    public static boolean consistent(int[] path, int currentRow, int currentCol) 
    {
        boolean ret = true;
        if(path != null)
        {
            int len = path.length;
            for(int row=0; row < currentRow && ret; row++)
            {
                if(path[row] == currentCol)
                    ret = false;
                else if( Math.abs(currentRow - row ) == Math.abs(currentCol - path[row]))
                    ret = false;
            }
        }
        return ret;
    }
}
public class Queen2 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        final int len = 4;
        final int width = 8;
        int[][] board = new int[len][len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                board[i][j] = i*len+j;

        int[][] path = new int[width][2];
        int depth = 0;
        queen(path, width, depth);

    }
    public static boolean consistent(int[][] path, int width, int depth, int newRow)
    {
        if(path != null)
        {
            for(int i = 0; i < depth; i++)
            {
                int currCol = path[i][0];
                int currRow = path[i][1];
                if(currRow == newRow)
                    return false;
                else if(Math.abs(depth - currCol ) ==Math.abs(newRow - currRow))
                    return false;
            }
        }
        return true;
    }
    public static void queen(int[][] path, int width, int depth)
    {
        if(depth == width)
        {
            for(int i=0; i < depth; i++)
                System.out.println("["+path[i][0]+"]["+path[i][1]+"]");
            System.out.println("");
        }
        else 
        {
            for(int row=0; row < width; row++)
            {
                if(consistent(path, width, depth, row)) 
                {
                    path[depth][0] = depth;
                    path[depth][1] = row;
                    queen(path, width, depth+1);
                }
            }
        }
    }
}
import java.io.*;
import java.util.*;

//quick sort algorithm
class QuickSort 
{
	public static void main(String args[])
	{
        Test1();
        Test2();
        Test3();
        Test4();
        Test5();
	}
    public static void Test1()
    {
        System.out.println("test case1:");
		int[] Arr = {100};
		int left = 0;
		int right = Arr.length-1;
		QuickSort(Arr, left, right);
		for(int i=0; i<Arr.length; i++)
			System.out.println("Arr[" + i + "]=" + Arr[i]);
    }
    public static void Test2()
    {
        System.out.println("test case2:");
		int[] Arr1 = {100, 1};
		int left = 0;
		int right = Arr1.length-1;
		QuickSort(Arr1, left, right);
		for(int i=0; i<Arr1.length; i++)
			System.out.println("Arr1[" + i + "]=" + Arr1[i]);
    }
    public static void Test3()
    {
		System.out.println("test case3:");
		int[] Arr2 = {1, 5};
		int left = 0;
		int right = Arr2.length-1;
		QuickSort(Arr2, left, right);
		for(int i=0; i<Arr2.length; i++)
			System.out.println("Arr2[" + i + "]=" + Arr2[i]);
    }
    public static void Test4()
    {
        System.out.println("test case4:");
		int[] Arr3 = {100, 1, 7, 6};
		//int[] Arr3 = {100, 1, 3, 9, 6, 5, 7};
		//int[] Arr3 = {9, 1, 2, 4};
		int left = 0;
		int right = Arr3.length-1;
		QuickSort(Arr3, left, right);
		for(int i=0; i<Arr3.length; i++)
			System.out.println("Arr3[" + i + "]=" + Arr3[i]);
    }

    public static void Test5()
    {
        System.out.println("test case5:");
		int[] Arr3 = {1, 7, 5};
		int left = 0;
		int right = Arr3.length-1;
		QuickSort(Arr3, left, right);
		for(int i=0; i<Arr3.length; i++)
			System.out.println("Arr3[" + i + "]=" + Arr3[i]);
    }
    public static void QuickSort(int[] Arr, int left, int right)
    {
        if(left < right)
        {
            int pivot = Partition(Arr, left, right);
            QuickSort(Arr, left, pivot-1);
            QuickSort(Arr, pivot+1, right);
        }
    }

    public static void swap(int[] arr, int left, int right)
    {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
    public static int Partition(int[] arr, int left, int right)
    {
        int prev = left;
        if(arr != null)
        {
            int pivot = arr[right];
            prev = left;
            for(int i=left; i<=right; i++)
            {
                if(arr[i] < pivot)
                {
                    swap(arr, i, prev);
                    prev++;    
                }
            }
            swap(arr, prev, right);
        }
        return prev;
    }
    //partition
	public static int Partition2(int[] Arr, int left, int right)
	{
		int ret = 0;
		if(Arr != null)
		{
			int len = right - left + 1; 
			if(len == 1)
				ret = left;
			else if(len > 1)
			{
				int pivot = Arr[left];
				int i=left;
				int j=right;
				while(i < j)
				{
					while(i < right && Arr[i] <= pivot ) i++;
					while(j > left && Arr[j] > pivot) j--;
					if(i<j)
					{ int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;
			}
		}
		return ret;
	}
}
import java.util.*;

public class QuickSortLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Try it");
        SLL s1 = new SLL();
        SLL s2 = new SLL();
        SLL s3 = new SLL();
        s1.append(2);
        s1.append(20);
        s1.append(30);
        s1.append(40);
        s1.append(50);

        System.out.println("================");
        show(s1.getHead());
        System.out.println("================");
        Node mnode = partition(s1.getHead());
        show(s1.getHead());
        System.out.println("================");
        show(mnode);
        System.out.println("================");

        Node node = median(s1.getHead());
        System.out.println("median["+node.data+"]");

        s2.append(1);
        s2.append(7);
        s2.append(10);

        s3.append(3);
        s3.append(4);
        s3.append(20);

        Node s =  mergeList(mergeList(s1.getHead(), s2.getHead()), s3.getHead());
        show(s);
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    public static void show(Node curr)
    {
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }

    public static void test4()
    {
        System.out.println("begin test4==================");
        SLL s1 = new SLL();
        
        s1.append(2);
        s1.append(40);
        s1.append(100);
        
        s1.append(50);
        
        s1.append(30);
        
        s1.append(20);
        s1.append(1);
        s1.append(6);
        s1.append(20);
        s1.append(2);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test4==================");
    }

    public static void test5()
    {
        System.out.println("begin test4==================");
        SLL s1 = new SLL();
        
        s1.append(1);
        s1.append(2);
        s1.append(3);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test5==================");
    }

    public static void test6()
    {
        System.out.println("begin test6==================");
        SLL s1 = new SLL();
        
        s1.append(30);
        s1.append(20);
        s1.append(10);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test4==================");
    }

    public static void test2()
    {
        System.out.println("begin test2()================");
        SLL s1 = new SLL();
        s1.append(4);
        s1.append(8);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test1()================");
    }

    public static void test3()
    {
        System.out.println("begin test3()================");
        SLL s1 = new SLL();
        s1.append(4);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        if(pivot != null)
            System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test3()================");
    }
    public static void test1()
    {
        System.out.println("begin test2()================");
        SLL s1 = new SLL();
        s1.append(4);
        s1.append(8);
        s1.append(3);
        s1.append(6);
        s1.append(5);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test1()================");
    }
    public static void swap(Node first, Node second)
    {
        int tmp = first.data;
        first.data = second.data;
        second.data = tmp;
    }
    public static void qsLinkedList(Node head, Node tail, Node[] prev)
    {
        Node h = head;
        Node t = tail;
        Node pivot = qsPartition(h, t, prev); 
        Node myh = h;
        Node myt = t;
        while(myh != null)
        {
            System.out.println("myh["+myh.data+"]");
            if(myh != myt)
                myh = myh.next;
            else
                break;
        }
        if(head != tail)
        {
            if(pivot != null)
                System.out.println("pivot["+pivot.data+"]");
            if(prev[0] != null)
                System.out.println("prev["+prev[0].data+"]");
            if(h != null)
                System.out.println("h["+h.data+"]");
            if(t != null)
                System.out.println("t["+t.data+"]");
            System.out.println("-----------------------");
            
            //if(h != null && prev[0] != null)
            if(h != pivot)
                qsLinkedList(h, prev[0], prev); 
            if(pivot != t)
                qsLinkedList(pivot.next, t, prev);
        }
    }
    public static Node qsPartition(Node head, Node tail, Node[] prev)
    {
        Node curr = head;
        Node big = curr;
        Node pivot = tail;
        if(head == tail)
        {
            System.out.println("head{"+head.data+"}");
            System.out.println("tail{"+tail.data+"}");
            System.out.println("pivot{"+pivot.data+"}");
            prev[0] = null;
            return null;    
        }
        else
        {
            while(curr != null)
            {
                if(curr.data < pivot.data)
                {
                    swap(curr, big);
                    prev[0] = big;
                    System.out.println("prev{"+prev[0].data+"}");
                    big = big.next;
                }                
                curr = curr.next;
            }
            if(big != null)
                swap(pivot, big);
            return big;
        }
    }
    public static Node partition(Node head)
    {
        Node mnode = median(head);
        if(mnode != null)
        {
            Node ret = mnode.next;
            mnode.next = null;
            return ret;
        }
        else
            return mnode;
    }
    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }
    public static int[] merge(int[] arr1, int[] arr2)
    {
        int[] arr = null; 
        if(arr1 == null)
            return arr2;
        else if(arr2 == null)
            return arr1;
        else 
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            arr = new int[len1+len2];
            int inx1 = 0;
            int inx2 = 0;
            int k=0;

            while(inx1 < len1 || inx2 < len2)
            {
                if(inx1 >= len1)
                {
                    arr[k] = arr1[inx2];
                    inx2++;
                }
                else if(inx2 >= len2)
                {
                    arr[k] = arr2[inx1];
                    inx1++;
                }
                else
                {
                    if(arr1[inx1] < arr2[inx2])
                    {
                        arr[k] = arr1[inx1];
                        inx1++;
                    }
                    else
                    {
                        arr[k] = arr2[inx2];
                        inx2++;
                    }
                }
                k++;
            }
        }
        return arr;
    }
    public static Node mergeList(Node s1, Node s2)
    {
        Node curr = null;
        Node head = curr;
        while( s1 != null || s2 != null)
        {
            if(s1 == null)
            {
                if(curr == null)
                   head = curr = s2;
                else
                {
                    curr.next = s2;
                    curr = curr.next;
                }
                s2 = s2.next;
            }
            else if(s2 == null)
            {
                if(curr == null)
                    head = curr = s1;
                else
                {
                    curr.next = s1;
                    curr = curr.next;
                }
                s1 = s1.next;
            }
            else
            {
                if(s1.data < s2.data)
                {
                    if(curr == null)
                        head = curr = s1;
                    else
                    {
                        curr.next = s1;
                        curr = curr.next;
                    }
                    s1 = s1.next;
                }
                else
                {
                    if( curr == null)
                        head = curr = s2;
                    else
                    {
                        curr.next = s2;
                        curr = curr.next;
                    }
                    s2 = s2.next;
                }
            }
        }
        return head;
    }
}
	public static int Partition2(int[] Arr, int left, int right)
	{
		int ret = 0;
		if(Arr != null)
		{
			int len = right - left + 1; 
			if(len == 1)
				ret = left;
			else if(len > 1)
			{
				int pivot = Arr[left];
				int i=left;
				int j=right;
				while(i < j)
				{
					while(i < right && Arr[i] <= pivot ) i++;
					while(j > left && Arr[j] > pivot) j--;
					if(i<j)
					{ int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;
			}
		}
		return ret;
	}
public class Quine {
  public static void main(String[] args) {
    System.out.printf("public class Quine {\n public static void main(String[] args) {\n System.out.printf(");
  }
}

import java.util.Random;

public class RandomNumber
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] array = RandomNum(1, 10);
        Aron.printArray(array);
    }
    // generate 0 - [n-1]
    public static int[] RandomNum(int init, int n)
    {   
        int[] array = new int[n]; 
        Random rn = new Random();
        for(int i=0; i<n; i++)
            array[i] = rn.nextInt(n) + init;

        return array;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import classfile.*;

public class RegexMatches {
    public static void main( String args[] ) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        String pattern = "([a-z]+).([a-zA-Z-]+)(/)";
        String[] strArr = {
            "www.google.com/search?q=goog/nice",
            "www.google.com/search?q=goog",
            "http://www.google.msn.ca/search?q=goog",
            "http://www.google.msn.ca/a/b/c/d"
        };

        Pattern r = Pattern.compile(pattern);
        for(int i=0; i<strArr.length; i++) {
            Matcher mat = r.matcher(strArr[i]);
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
        }

        Aron.end();
    }
    // case insensitive
    static void test1(){
        Aron.beg();
        Pattern r = Pattern.compile("captheorem", Pattern.CASE_INSENSITIVE);
        Matcher mat = r.matcher("CAPTHEOREM");
        if(mat.find()) {
            Print.p("found=" + mat.group(0));
        }
        Aron.end();
    }
}
import java.util.regex.Pattern;
import java.util.regex.Matcher;

// 411-114-3475 whatever  415-3354567 what 665335-9987 cool 6653334467
public class RegexPhone {
    public static void main(String[] args) {

        //Pattern pattern = Pattern.compile("[0-9]{3}[-]{0,1}[0-9]{3}[-]{0,1}[0-9]{4}");
        Pattern pattern = Pattern.compile("[0-9]{3}[-]?[0-9]{3}[-]?[0-9]{4}");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}

/* output
334-4467777
334666-4456
415-333-9674
4264491569
*/
import Lib.*;

public class Hello
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[][] array2d = new int[3][2];

        System.out.println("array2.length="+array2d.length);
        System.out.println("array2[0].length="+array2d[0].length);

        for(int i=0; i<3; i++)
            array2d[i] = fun();

        for(int i=0; i<3; i++)
        {
            for(int j=0; j<2; j++)
                System.out.print("["+array2d[i][j]+"]");
            System.out.println();
        }

        test1();
        testParition();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
    }

    public static void test8()
    {
        System.out.println("test8"); 
        String str = "abcde";
        int k=0;
        int p=0;
        Integer num = new Integer(0);
        dump(str, k, p, num);
    } 
    public static void test9()
    {
		BST b1 = new BST();
		b1.Insert(15);
		b1.Insert(12);
        Node prev = null;
        boolean isbst = isBST(b1.root, prev);
        System.out.println("isbst=" + isbst);

    } 
    public static void dump(String str, int k, int p, Integer num){
        if(k < str.length()){
            dump(str, k+1, p, num);
        }
        else if(k == str.length()){
            num = new Integer(3); 
            p = 10;
        }
        if(k < str.length())
            System.out.println("charAt [" + k + "]=" + str.charAt(k));
        System.out.println("p=" + p + "  num=" + num);
    }

    public static boolean isBST(Node root, Node prev)
    {
        if( root != null)
        {
            if(!isBST(root.left, prev))
                return false;
            if(prev != null && prev.data >= root.data)
                return false;
            if(!isBST(root.right, root))
                return false;
        }
        return true;
    }

    public static void kdistance(Node r, int k){
        
        if(r != null){
            if(k == 0)
                System.out.println(r.data);
            else{
                kdistance(r.left, k-1);
                kdistance(r.right, k-1);
            }
        }
    }

    public static void test7()
    {
        System.out.println("test7"); 
        int[] arr1 = {3, 1, 4, 6, 2};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test6()
    {
        System.out.println("test6"); 
        int[] arr1 = {3};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test5()
    {
        System.out.println("test5"); 
        int[] arr1 = {3, 2};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test4()
    {
        System.out.println("test4"); 
        int[] arr1 = {2, 3, 2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    //[file=mergesort1.html title=""
    public static void mergeSort(int[] arr, int lo, int hi){
        if(lo < hi){
            int mid = (lo + hi)/2;
            mergeSort(arr, lo, mid);
            mergeSort(arr, mid+1, hi);
            merge(arr, lo, mid, hi);
        }
    }
    public static void merge(int[] arr1, int lo, int mid, int hi){
        int len = hi - lo + 1; 
        int[] array = new int[len];
        if(len > 1){
            int i = lo;
            int j = mid+1;
            int k = 0;
            while(i <= mid || j <= hi){
                if(i > mid){
                    array[k] = arr1[j];
                    j++;
                }
                else if (j > hi){
                    array[k] = arr1[i];
                    i++;
                }
                else{
                    if(arr1[i] < arr1[j]){
                        array[k] = arr1[i];
                        i++;
                    }else{
                        array[k] = arr1[j];
                        j++;
                    }
                }
                k++;
            }
            for(int x=0; x<len; x++){
                arr1[x+lo] = array[x];
            }
        }
    }
    //]
    public static void testParition()
    {
        System.out.println("testParition"); 
        int[] arr1 = {2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test2()
    {
        System.out.println("test2"); 
        int[] arr1 = {2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    }
    public static void test3()
    {
        System.out.println("test3"); 
        int[] arr1 = {3, 2, 1, 5, 2, 6};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    } 
    public static void test1()
    {
        System.out.println("test1"); 
        int[] arr1 = {2};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    } 
    public static void quickSort(int[] arr, int lo, int hi){
        if(lo < hi){
            int p = partition(arr, lo, hi);
            quickSort(arr, lo, p-1);
            quickSort(arr, p+1, hi);
        }
    }
    public static int partition(int[] arr, int lo, int hi){
        int len = hi - lo + 1;
        int bigger = lo;
        if(len > 1){
            int pivot = arr[hi];
            for(int i=lo; i<len; i++){
                if(arr[i] < pivot){  
                    swap(arr, bigger, i);
                    bigger++;
                } 
            }
            swap(arr, bigger, hi);
        }
        return bigger;
    }
    public static void swap(int[] arr, int i, int j){
        int tmp  = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    public static int[] fun()
    {
        int[] array = {1, 2};
        return array;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class RemoveSpace 
{
	public static void main(String args[])
	{
		System.out.println("n=");
		String str = RemoveSpace(" ");
		System.out.println("str=[" + str + "]");
	}
	public static String RemoveSpace(String str)
	{
		String s="";
		if( str != null)
		{
			int len = str.length();
			if(len == 1)
			{ if(str.charAt(0) != ' ')	s = str; }
			else if( len > 1)
			{ String w="";
				if(str.charAt(0) != ' ')
					w = str.charAt(0) + "";
				for(int i=1; i<len; i++)
				{ if(str.charAt(i) != ' ')
						w = w + str.charAt(i);
					else if(str.charAt(i-1) != ' ')
					{ if(s.equals(""))
						{ s = w; w="";}
						else 
						{
							s = s + " " + w;
							w = "";
						}
					}
				}
				if(!w.equals(""))
					s = s + " " + w;
			}
		}
		return s;
	}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.stream.Collectors;

public class Repeat{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        String s = repeat(18, "-");
        Print.p(s);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    public static String repeat(int n, String s){
        return IntStream.range(0, n).mapToObj(i -> s).collect(Collectors.joining("")); 
    }
} 

//[ java regular expression example ]//
//[ java regular expression tutorial ]//

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.HashMap;
import java.util.Map;

public class ReplaceMultiString {
    public static void main( String args[] ) {
        // java regular, java regex, jregex
        Map<String, String> replacements = new HashMap<String, String>() {
            {
                put(":", "colon");
                put("#", "number_sign");
                put("$", "dollar");
            }
        };

        String input = "$dog";

        String regexp = "\\$";
        StringBuffer sb = new StringBuffer();
        Pattern pattern = Pattern.compile(regexp);
        Matcher match = pattern.matcher(input);

        while(match.find()) {
            match.appendReplacement(sb, replacements.get(match.group()));
        }
        match.appendTail(sb);
        System.out.println(sb.toString());
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class ReverseSingleLinkedList {
    public static void main(String args[]) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        Aron.beg();
        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);

        s.append(n1);
        s.append(n2);
        s.append(n3);
        s.print();
        Node head = ReverseIterationClone(s.head);
        s.Remove(n1);
        s.Remove(n2);
        Print.pbl("Clone and Reverse the list");
        Aron.printSLL(head);
        Ut.l();
        Print.pbl("Original List");
        Aron.printSLL(s.head);
        Aron.end();
    }
    static void test1(){
        Aron.beg();

        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        s.append(n1);
        s.append(n2);
        s.append(n3);
        s.print();
        Ut.l();
        Node head = Reverse3(s.head);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test2(){
        Aron.beg();

        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        s.append(n1);
        s.print();
        Ut.l();
        Node head = Reverse3(s.head);
        Aron.printSLL(head);

        Aron.end();
    }
    static Node head = null;
    public static Node Reverse(Node curr) {
        if(curr != null) {
            Node node = Reverse(curr.next);
            if(node != null) {
                node.next = curr;
                curr.next = null;
            } else {
                head = curr;
            }
        }
        return curr;
    }

    public static Node Reverse2(Node curr) {
        Node tmp = null;
        if(curr == null)
            return null;
        else if(curr.next == null)
            return curr;
        else {
            tmp = Reverse2(curr.next);
            curr.next.next = curr;
            curr.next = null;
        }
        return tmp;
    }

    public static Node Reverse3(Node curr) {
        Node tmpHead = null;
        if(curr != null){
            tmpHead = Reverse3(curr.next);
            if(tmpHead == null)
                tmpHead = curr;
            else{
                curr.next.next = curr;
                curr.next = null;
            }
        }
        return tmpHead;
    }
    // Modified the original list
    public static Node ReverseOriginalList(Node head) {
        Node prev = null;
        Node curr = head;
        while(curr != null) {
            Node tmpNext = curr.next;
            curr.next = prev;
            prev = curr;
            curr = tmpNext;
        }
        return prev;
    }
    //Clone the original list and reverse it
    public static Node ReverseIterationClone(Node head) {
        Node curr = head;
        Node prev = null;
        Node newCurr = null;
        Node newPrev = null;
        while(curr != null) {
            newCurr = new Node(curr.data);

            Node newNext = newCurr.next;
            newCurr.next = newPrev;

            newPrev = newCurr;
            newCurr = newNext;
            curr = curr.next;
        }
        return newPrev; //return head
    }
    public static Node ReverseCloneStack(Node mycurr) {
        Stack<Node> st = new Stack<Node>();
        Node curr = mycurr;
        while(curr != null) {
            Print.pbl(curr.data);
            st.push(curr);
            curr = curr.next;
        }
        Ut.l();

        Node head = null;
        Node newPrev = null;
        Node newCurr = null;
        while(!st.isEmpty()) {
            newCurr = new Node(st.pop().data);
            if(newPrev != null)
                newPrev.next = newCurr;
            else
                head= newCurr;
            newPrev = newCurr;
        }
        return head;

    }
    public static Node ReverseClone(Node head) {
        Node curr = head;
        Node prev = null;
        Node newCurr = null;
        Node newPrev = null;
        while(curr != null) {
            newCurr = new Node(curr.data);

            curr.next = prev;
            newCurr.next = newPrev;

            prev = curr;
            curr = curr.next;
            newPrev = newCurr;
            newCurr = newCurr.next;
        }
        return newPrev;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseStr
{
	public static void main(String args[])
	{
		int i = 0;
		System.out.println("s=" + RevStr("", i));
		System.out.println("s1=" + RevStr("a", i));
		System.out.println("s2=" + RevStr("ab", i));
		System.out.println("s3=" + RevStr("ab ", i));
	}
	public static String RevStr(String str, int i)
	{
		String s="";
		if(str != null)
		{
			if(str.length() == 1)
				s = str;
			else if(str.length() > 1 && i < str.length())
			{
				s = RevStr(str, i+1) + str.charAt(i);
			}
		}
		return s;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseStrIte
{
	public static void main(String args[])
	{
		int i = 0;
		System.out.println("s3=" + RevStr("ab"));
	}
	public static String RevStr(String str)
	{
		char[] chArr=null;
		if( str != null)
		{
			chArr = str.toCharArray();
			int len = str.length();
			for(int i=0; i<len/2; i++)
			{
				char tmp = chArr[i];
				chArr[i] = chArr[len-1-i];
				chArr[len-1-i] = tmp;
			}
		}
		return new String(chArr);
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class ReverseStrings{
    public static void main(String args[]) {
        test0();
    }
    static void test0(){
        Aron.beg();
        String str = "dog and cat hello world";
        reverseString(str);
        Aron.end();
    }
    public static void reverseString(String str){
        StringBuilder sb = new StringBuilder(str);
        StringBuilder word = new StringBuilder();
        if(str != null){
            int len = str.length();
            for(int i=0; i<len/2; i++){
                char tmp = sb.charAt(i);
                sb.setCharAt(i, sb.charAt(len-1-i));
                sb.setCharAt(len-1-i, tmp);
            }
            Print.pbl(sb.toString());
            String s = "";
            for(int i=0; i<len; i++){
                if(sb.charAt(i) != ' '){
                    word.append(sb.charAt(i));
                }else{
                    Print.pbl(word.reverse());
                    word.delete(0, word.length()); 
                }
            } 
            if(word.length() > 0)
                Print.pbl(word.reverse());
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseWord
{
	public static void main(String args[])
	{
		int k = 0;
		String s = ReverseWord("", k);
		System.out.println("s=" + s);
	}
	public static String ReverseWord(String str, int k)
	{
		String s = "";
		for(int i = k; i < str.length(); i++)
		{
			if((str.charAt(i)==' ') && !s.equals(""))
			{
				return ReverseWord(str, i+1) + " " + s;
			}
			else if(str.charAt(i) != ' ')
				s = s + Character.toString(str.charAt(i));
		}
		return s;

	}
}
package org.fxmisc.richtext.demo;

import java.time.Duration;
import java.util.Collection;
import java.util.Collections;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javafx.application.Application;
import javafx.scene.Scene;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;

import org.fxmisc.flowless.VirtualizedScrollPane;
import org.fxmisc.richtext.CodeArea;
import org.fxmisc.richtext.LineNumberFactory;
import org.fxmisc.richtext.model.StyleSpans;
import org.fxmisc.richtext.model.StyleSpansBuilder;
import org.reactfx.Subscription;

public class RichTextDemo extends Application {

    private static final String[] KEYWORDS = new String[] {
            "abstract", "assert", "boolean", "break", "byte",
            "case", "catch", "char", "class", "const",
            "continue", "default", "do", "double", "else",
            "enum", "extends", "final", "finally", "float",
            "for", "goto", "if", "implements", "import",
            "instanceof", "int", "interface", "long", "native",
            "new", "package", "private", "protected", "public",
            "return", "short", "static", "strictfp", "super",
            "switch", "synchronized", "this", "throw", "throws",
            "transient", "try", "void", "volatile", "while"
    };

    private static final String KEYWORD_PATTERN = "\\b(" + String.join("|", KEYWORDS) + ")\\b";
    private static final String PAREN_PATTERN = "\\(|\\)";
    private static final String BRACE_PATTERN = "\\{|\\}";
    private static final String BRACKET_PATTERN = "\\[|\\]";
    private static final String SEMICOLON_PATTERN = "\\;";
    private static final String STRING_PATTERN = "\"([^\"\\\\]|\\\\.)*\"";
    private static final String COMMENT_PATTERN = "//[^\n]*" + "|" + "/\\*(.|\\R)*?\\*/";

    private static final Pattern PATTERN = Pattern.compile(
            "(?<KEYWORD>" + KEYWORD_PATTERN + ")"
            + "|(?<PAREN>" + PAREN_PATTERN + ")"
            + "|(?<BRACE>" + BRACE_PATTERN + ")"
            + "|(?<BRACKET>" + BRACKET_PATTERN + ")"
            + "|(?<SEMICOLON>" + SEMICOLON_PATTERN + ")"
            + "|(?<STRING>" + STRING_PATTERN + ")"
            + "|(?<COMMENT>" + COMMENT_PATTERN + ")"
    );

    private static final String sampleCode = String.join("\n", new String[] {
        "package com.example;",
        "",
        "import java.util.*;",
        "",
        "public class Foo extends Bar implements Baz {",
        "",
        "    /*",
        "     * multi-line comment",
        "     */",
        "    public static void main(String[] args) {",
        "        // single-line comment",
        "        for(String arg: args) {",
        "            if(arg.length() != 0)",
        "                System.out.println(arg);",
        "            else",
        "                System.err.println(\"Warning: empty string as argument\");",
        "        }",
        "    }",
        "",
        "}"
    });


    public static void main(String[] args) {
        launch(args);
    }

    @Override
    public void start(Stage primaryStage) {
        CodeArea codeArea = new CodeArea();

        // add line numbers to the left of area
        codeArea.setParagraphGraphicFactory(LineNumberFactory.get(codeArea));

        // recompute the syntax highlighting 500 ms after user stops editing area
        Subscription cleanupWhenNoLongerNeedIt = codeArea

                // plain changes = ignore style changes that are emitted when syntax highlighting is reapplied
                // multi plain changes = save computation by not rerunning the code multiple times
                //   when making multiple changes (e.g. renaming a method at multiple parts in file)
                .multiPlainChanges()

                // do not emit an event until 500 ms have passed since the last emission of previous stream
                .successionEnds(Duration.ofMillis(500))

                // run the following code block when previous stream emits an event
                .subscribe(ignore -> codeArea.setStyleSpans(0, computeHighlighting(codeArea.getText())));

        // when no longer need syntax highlighting and wish to clean up memory leaks
        // run: `cleanupWhenNoLongerNeedIt.unsubscribe();`

        codeArea.replaceText(0, 0, sampleCode);

        Scene scene = new Scene(new StackPane(new VirtualizedScrollPane<>(codeArea)), 600, 400);
        scene.getStylesheets().add(JavaKeywordsAsyncDemo.class.getResource("java-keywords.css").toExternalForm());
        primaryStage.setScene(scene);
        primaryStage.setTitle("Java Keywords Demo");
        primaryStage.show();
    }

    private static StyleSpans<Collection<String>> computeHighlighting(String text) {
        Matcher matcher = PATTERN.matcher(text);
        int lastKwEnd = 0;
        StyleSpansBuilder<Collection<String>> spansBuilder
                = new StyleSpansBuilder<>();
        while(matcher.find()) {
            String styleClass =
                    matcher.group("KEYWORD") != null ? "keyword" :
                    matcher.group("PAREN") != null ? "paren" :
                    matcher.group("BRACE") != null ? "brace" :
                    matcher.group("BRACKET") != null ? "bracket" :
                    matcher.group("SEMICOLON") != null ? "semicolon" :
                    matcher.group("STRING") != null ? "string" :
                    matcher.group("COMMENT") != null ? "comment" :
                    null; /* never happens */ assert styleClass != null;
            spansBuilder.add(Collections.emptyList(), matcher.start() - lastKwEnd);
            spansBuilder.add(Collections.singleton(styleClass), matcher.end() - matcher.start());
            lastKwEnd = matcher.end();
        }
        spansBuilder.add(Collections.emptyList(), text.length() - lastKwEnd);
        return spansBuilder.create();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.Print;
import classfile.Aron;
import java.util.stream.*;
import java.util.stream.Collectors;

public class Rotate903{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
        };

        Aron.printArray2D(arr);
        Print.fl();
        rotate90(arr);
        Aron.printArray2D(arr);
            
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    public static void rotate90(int[][] arr){
        if(arr != null){
            int len = arr.length;
            for(int k=0; k<len/2; k++){
                for(int i=k; i<len-1-k; i++){
                    int tmp = arr[k][i];
                    arr[k][i] = arr[len-1-i][k];
                    arr[len-1-i][k] = arr[len-1-k][len-1-i];
                    arr[len-1-k][len-1-i] = arr[i][len-1-k];
                    arr[i][len-1-k] = tmp;
                }
            }
        }
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class RotateMatrix90 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
        test1();
		System.out.println();
        test2();
        System.out.println();
        test3();
        System.out.println();
        test4();
	}

	//rotate matrix clockwise 90
	public static int[][] rotateMatrixClockwise90(int[][] A)
	{
		if(A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][i];
					A[k][i] = A[nRow-1-i][k];
					A[nRow-1-i][k] = A[nRow-1-k][nRow-1-i];
					A[nRow-1-k][nRow-1-i] = A[i][nRow-1-k];
					A[i][nRow-1-k] = tmp;
				}
		}
		return A;
	}

	//rotate matrix counterclockwise 90
	public static int[][] rotatecounterclockwise90(int[][] A)
	{
		if( A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
			{
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][nRow-1-i];
					A[k][nRow-1-i] = A[nRow-1-i][nRow-1-k];
					A[nRow-1-i][nRow-1-k]=A[nRow-1-k][i];
					A[nRow-1-k][i]=A[i][k];
					A[i][k]=tmp;
				}
			}
		}
		return A;
	}

    //Rotate matrix counterclosewise 90 recursively 
    public static void rotatecounterclockwise90Recursion(int[][] arr, int depth)
    {
        if(arr != null)
        {
            int len = arr.length;
            for(int i=depth; i<len-1-depth; i++)
            {
                int tmp = arr[depth][i];
                arr[depth][i] = arr[len-1-i][depth];
                arr[len-1-i][depth] = arr[len-1-depth][len-1-i];
                arr[len-1-depth][len-1-i] = arr[i][len-1-depth];
                arr[i][len-1-depth] = tmp;
            }
            if(len - 2*depth > 1)
                rotatecounterclockwise90Recursion(arr, depth+1);
        }
    }

    //Rotate matrix clockwise 90 recursively 
    public static void rotateClockWise90Recursion(int[][] arr, int depth)
    {
        if(arr != null)
        {
            int len = arr.length;
            for(int i=depth; i<len-1-depth; i++)
            {
                int tmp = arr[depth][len-1-i];
                arr[depth][len-1-i] = arr[len-1-i][len-1-depth];
                arr[len-1-i][len-1-depth] = arr[len-1-depth][i];
                arr[len-1-depth][i] = arr[i][depth];
                arr[i][depth] = tmp;
            }
            if(len - 2*depth > 1)
                rotateClockWise90Recursion(arr, depth+1);
        }
    }

    public static void test1()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

        int depth = 0;
		rotatecounterclockwise90Recursion(A, depth);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }

    public static void test2()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

        int depth = 0;
		rotateClockWise90Recursion(A, depth);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }
    public static void test3()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotatecounterclockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

    }
    public static void test4()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotateMatrixClockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import classfile.*;

public class RotatedSortedArray{
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test0_findMinIndexNew();
        test1_findMinIndexNew();
        test2_findMinIndexNew();
        test3_findMinIndexNew();
        test4_findMinIndexNew();
    }

    static void test1(){
        Aron.beg();
        int[] arr = {4, 3, 2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);

        Aron.end();
    }


    static void test2(){
        Aron.beg();
        int[] arr = {1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 1);
        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        int[] arr = {3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);
        Aron.end();
    } 

    static void test4(){
        Aron.beg();
        int[] arr = {3, 4, 5, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 2);

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        int[] arr = {3, 4, 5, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinIndexNegative(negative(arr), lo, hi);
        Test.t(index, 3); 

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);

        Aron.end();
    }

    //[ file=RotatedSortedArray.html title=""
    // assume there is not duplicated number in the array
    // find the index of maximum value in the rotated sorted array
    public static int findMaxIndex(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] < arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;
                if(arr[lo] < arr[mid])
                    return findMaxIndex(arr, mid, hi);
                else
                    return findMaxIndex(arr, lo, mid);
            }
        }
        return -1;
    }
    //]

    // negative all values in the array
    public static int[] negative(int[] arr) {
        int[] tmpArr = new int[arr.length];
        int c=0;
        for(int e: arr) {
            tmpArr[c] = -e;
            c++;
        }
        return tmpArr;
    }

    // find the mininum index from a rotated sorted array
    public static int findMinIndex(int[] arr, int lo, int hi) {
        return findMaxIndex(arr, lo, hi);
    }
    
    public static int findMinIndexNegative(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] > arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;

                if(arr[lo] < arr[mid])
                    return findMinIndexNegative(arr, mid, hi);
                else
                    return findMinIndexNegative(arr, lo, mid);
            }
        }
        return -1;
    }

    static void test0_findMinIndexNew(){
        Aron.beg();
        int[] arr = {1, 2, 3, 4}; 
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinIndexNew(arr, lo, hi);
        Test.t(findMinIndexNew(arr, lo, hi), 0);

        Aron.end();
    }
    static void test1_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 3);

        Aron.end();
    }
    static void test2_findMinIndexNew(){
        Aron.beg();
        int[] arr = {1, 2}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 0);

        Aron.end();
    }
    static void test3_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 1);

        Aron.end();
    }
    static void test4_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 3, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 2);

        Aron.end();
    }

    public static int findMinIndexNew(int[] arr, int lo, int hi){
        if(arr != null){
            if(arr[lo] < arr[hi] || lo == hi)
                return lo;
            else{
                int mid = 0;
                if((lo + hi) % 2 == 1)
                    mid = ((lo + hi)/2) + 1;
                else 
                     mid = (lo + hi)/2;

                if(arr[mid] < arr[hi])
                    return findMinIndexNew(arr, lo, mid);
                else
                    return findMinIndexNew(arr, mid, hi);
            }
        }
        return -1;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;

public class RotatedSortedArrayMaxMin{
    public static void main(String[] args) {
        test00_min();
        test0_min();
        test1_min();
        test2_min();
        test3_min();
        test4_min();
        test5_max();
        test6_max();
        test7_max();
        test8_max();
    }
    public static void test00_min(){
        Aron.beg();
        int[] arr = {1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test0_min(){
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test1_min(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test2_min(){
        Aron.beg();
        int[] arr = {3, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test3_min(){
        Aron.beg();
        int[] arr = {4, 1, 2, 3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test4_min(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 3);
        Aron.end();
    }

    // find the index of minimum element of an array
    public static int findMinimumIndex(int[] arr, int lo, int hi){
        if( arr[lo] <= arr[hi])
            return lo;
        else{
            // [2, 1]
            // [3, 1, 2]
            // =>[3, 1] => [1]
            int mid = (lo + hi)/2;
            if(arr[lo] < arr[mid])
                return findMinimumIndex(arr, mid, hi);
            else if(arr[lo] > arr[mid])
                return findMinimumIndex(arr, lo, mid);
            else 
                return hi;
        }
    }
    public static int findMaximumIndex(int[] arr, int lo, int hi){
        if(arr[lo] <= arr[hi])
            return hi;
        else{
            // [2, 1]
            int mid = (lo + hi)/2;
            if( arr[lo] < arr[mid])
                return findMaximumIndex(arr, mid, hi);
            else if(arr[lo] > arr[mid]) 
                return findMaximumIndex(arr, lo, mid);
            else
                return lo;
        }
    }
    public static void test5_max(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 2);
        Aron.end();
    }
    public static void test6_max(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test7_max(){
        Aron.beg();
        int[] arr = {1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test8_max(){
        Aron.beg();
        int[] arr = {4, 1, 2, 3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }

} 

import javafx.application.Application;
import javafx.geometry.Rectangle2D;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.stage.Screen;
import javafx.stage.Stage;

public class MyScreen extends Application {
    @Override
    public void start(Stage stage) {
        Group root = new Group();
        Scene scene = new Scene(root, 500, 200);
        stage.setScene(scene);

        Rectangle2D primaryScreenBounds = Screen.getPrimary().getVisualBounds();

        //set Stage boundaries to visible bounds of the main screen
        stage.setX(primaryScreenBounds.getMinX());
        stage.setY(primaryScreenBounds.getMinY());
        stage.setWidth(primaryScreenBounds.getWidth());
        stage.setHeight(primaryScreenBounds.getHeight());

        stage.show();
        
    }
    public static void main(String[] args) {
        launch(args);
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Search2DMatrix 
{
	public static void main(String args[])
	{
		int[][] Arr = new int[1][3];
		gen2D(Arr);
		int right=0;
		int down=Arr.length-1;
		int key=2;
		boolean found = Search2DRecur(Arr, right, down, key);

		if(found)
			System.out.println("found key=" + key);
		else 
			System.out.println("not found key="+key);
	}

	public static void gen2D(int[][] Arr)
	{
		int row, col;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;
			Arr[0][0] = 0;
			Random r = new Random();
			for(int i=0; i<row; i++)
			{
				int ran = r.nextInt(3); 
				for(int j=0; j<col; j++)
				{
					if(i-1>=0 && j-1>=0)
					Arr[i][j] = Arr[i-1][j]+ Arr[i][j-1]+ran;
					else if(j-1>=0)
						Arr[i][j] = Arr[i][j-1]+ran;
					else if(i-1>=0)
						Arr[i][j] = Arr[i-1][j]+ran;

					System.out.print(String.format("%10s", Arr[i][j]));
				}
				System.out.println();
			}
		}
	}
	public static boolean Search2D(int[][] Arr, int key)
	{
		int row, col;
		boolean found=false;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;

			int right = 0;
			int down = row-1;
			while(right < col && down >= 0 && !found)
			{
				if(key > Arr[down][right])
						right++;
				else if(key < Arr[down][right])
                        down--;
				else if(key == Arr[down][right])
				{
					found = true;
					System.out.println("found Arr["+down+"]["+right+"]="+Arr[down][right]);
				}
			}
			if(!found)
					System.out.println("not fund key=" + key);
		}
		return found;
	}

	//right = 0;
	//down = row-1; 
	
	public static boolean Search2DRecur(int[][] Arr, int right, int down, int key)
	{
		if(Arr != null && right < Arr[0].length && down >= 0)
		{
			if(key > Arr[down][right])
				return Search2DRecur(Arr, right+1, down, key);			
			else if(key < Arr[down][right])
				return Search2DRecur(Arr, right, down-1, key);			
			else 
				return true;
		}
		return false;
	}
	
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

public class SerializeBinary {
    public static void main(String[] args) {
        test_serializeLevel();
        test_deserializeBinary();
        test1_deserializeIterator();
        test2_deserializeIterator();
        test_deSerializeIndex();
        test1_deSerializeIndex();
    }
    static void test_serializeLevel(){
        Aron.beg();
       
        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        Aron.inorder(bin.root);
        Aron.line();
        try {
            BufferedWriter out1 = new BufferedWriter(new FileWriter("text/level0.txt"));

            serializeLevel(bin.root, out1);
            out1.close();

            BufferedReader levelIn = new BufferedReader(new FileReader("text/level0.txt"));

            List<List<String>> list = createMap(levelIn);
            int depth = 0;
            
            Map<String, Node> map = new HashMap<String, Node>(); 
            Node root = deserializeLevel(list, map);
            Aron.line();
            Aron.inorder(root);
        } catch(Exception e) {
        }
        Aron.end();
    }
    
    static void test1_deserializeIterator(){
        Aron.beg();
        BST bin = new BST();
        bin.insert(10);
        bin.insert(11);

        try {
            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            List<String> list = Aron.readFileOneLineSplit("text/out.txt");
            Iterator<String> ite = list.iterator();
            Node root = deserializeIterator(ite);

            Aron.inorder(root);

        } catch(Exception e) {
        }

        Aron.end();
    } 

    static void test2_deserializeIterator(){
        Aron.beg();
        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        try {
            Aron.inorder(bin.root);
            Aron.line();

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            List<String> list = Aron.readFileOneLineSplit("text/out.txt");
            Iterator<String> ite = list.iterator();
            Node root = deserializeIterator(ite);

            Aron.inorder(root);

        } catch(Exception e) {
        }

        Aron.end();
    } 
    
    static void test_deserializeBinary(){
        Aron.beg();

        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        try {
            Aron.inorder(bin.root);

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));

            int[] A = new int[1];
            A[0] = 0;
            String[] Array = readFile(in);
            Node root = deserializeBinary(Array, A);
            Aron.inorder(root);
        } catch(Exception e) {
        }

        Aron.end();
    }

    static void test_deserializeBinary3(){
        Aron.beg();

        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        System.out.println("");
        try {
            Aron.inorder(bin.root);

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));

            String[] Array = readFile(in);
            Node root = deserializeBinary3(Array);
            Aron.inorder(root);
        } catch(Exception e) {
        }

        Aron.end();
    }

    //Use Level order to write node to file
    public static void serializeLevel(Node root, BufferedWriter out1) {
        try {
            if(root != null) {
                Queue<Node> q1 = new LinkedList<Node>();
                Queue<Node> q2 = new LinkedList<Node>();
                q1.add(root);
                while(q1.peek() != null || q2.peek() != null) {
                    while(q1.peek() != null) {
                        String s = "";
                        Node node = q1.remove();
                        s += node.data + " ";
                        if(node.left != null) {
                            s += node.left.data + " ";
                            q2.add(node.left);
                        } else
                            s += "#" + " ";
                        if(node.right != null) {
                            s += node.right.data + " ";
                            q2.add(node.right);
                        } else
                            s += "#" + " ";

                        s += "\n";
                        out1.write(s);
                    }

                    while(q2.peek() != null) {
                        String s = "";
                        Node node = q2.remove();
                        s += node.data + " ";
                        if(node.left != null) {
                            s += node.left.data + " ";
                            q1.add(node.left);
                        } else
                            s += "#" + " ";
                        if(node.right != null) {
                            s += node.right.data + " ";
                            q1.add(node.right);
                        } else
                            s += "#" + " ";

                        s += "\n";
                        out1.write(s);
                    }
                }

            }
        } catch(Exception e) {
        }
    }

    public static List<List<String>> createMap(BufferedReader in) {
        List<List<String>> list = new ArrayList<List<String>>();
        try {
            String line = null;
            while((line = in.readLine()) != null) {
                line = line.trim();
                String[] array = line.split("\\s+");
                if(array != null && array.length == 3) {
                    list.add(Arrays.asList(array));
                }
            }
        } catch(Exception e) {
        }
        return list;
    }

    public static String[] readFile(BufferedReader in) {
        String[] Array = null;
        try {
            String str;
            boolean end = false;
            while( (str = in.readLine()) != null && !end) {
                System.out.println(str);
                Array = str.split("\\s");
                end = true;
            }
            in.close();

            for(int i=0; Array != null && i<Array.length; i++) {
                System.out.println("["+Array[i]+"]");
            }

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        return Array;
    }

    public static Node deserializeLevel(List<List<String>> listList, Map<String, Node> map) {
        Node root = null;
        for(List<String> list : listList){
            if(root == null){
                root = new Node(Integer.parseInt(list.get(0)));
                map.put(list.get(0), root);

                String left = list.get(1);
                if(!left.equals("#")){
                    Node node =  new Node(Integer.parseInt(left));
                    root.left = node;
                    map.put(left, node);
                }

                String right = list.get(2);
                if(!right.equals("#")){
                    Node node =  new Node(Integer.parseInt(right));
                    root.right = node;
                    map.put(right, node);
                }
            }
            else{
                Node curr = map.get(list.get(0));
                if(curr == null){
                    curr = new Node(Integer.parseInt(list.get(0)));
                    map.put(list.get(0), curr);
                }

                String left = list.get(1);
                if(!left.equals("#")){
                    Node node =  new Node(Integer.parseInt(left));
                    curr.left = node;
                    map.put(left, node);
                }

                String right = list.get(2);
                if(!right.equals("#")){
                    Node node =  new Node(Integer.parseInt(right));
                    curr.right = node;
                    map.put(right, node);
                }
            }
        }
        return root;
    }

    public static Node deserializeBinary(String[] Array, int[] A) {
        Node root = null;
        if(Array != null && A[0] < Array.length) {
            if(!Array[A[0]].equals("#")) {
                root = new Node(Integer.parseInt(Array[A[0]]));
                A[0]++;
                root.left = deserializeBinary(Array, A);
                A[0]++;
                root.right = deserializeBinary(Array, A);
            }
        } else {
            Print.pbl("root is null");
        }
        return root;
    }

    static int index = 0;
    public static Node deserializeBinary3(String[] Array) {
        Node root = null;
        if(Array != null && index < Array.length) {
            if(!Array[index].equals("#")) {
                root = new Node(Integer.parseInt(Array[index]));
                index++;
                root.left = deserializeBinary3(Array);
                index++;
                root.right = deserializeBinary3(Array);
            }
        } else {
            Print.pbl("root is null");
        }
        return root;
    }

    //[ file=serializebin.html title=""
    public static void serializeBinary(Node root, BufferedWriter out) {
        try {
            if(root != null) {
                out.write(root.data + " ");
                serializeBinary(root.left, out);
                serializeBinary(root.right, out);
            } else {
                out.write("# ");
            }
        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
    }
    public static Node deserializeIterator(Iterator<String> ite) {
        Node root = null;
        if(ite.hasNext()) {
            String token = ite.next();
            if(!token.equals("#")) {
                root = new Node(Integer.parseInt(token));
                root.left = deserializeIterator(ite);
                root.right = deserializeIterator(ite);
            }
        } 
        return root;
    }
    //]

    public static void test_deSerializeIndex() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(14);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);

        Aron.inorder(b1.root);
        Aron.line();

        try {
            FileWriter fstream = new FileWriter("text/out.txt");
            BufferedWriter out = new BufferedWriter(fstream);
            int k=0;
            serializeIndex(b1.getRoot(), out, k);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));
            Map<Integer, Integer> map = buildMapFromFile(in);

            k = 0;
            Node root = deSerializeIndex(map, k);
            Aron.inorder(root);

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        Aron.end();
    }

    public static void test1_deSerializeIndex() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(12);

        Aron.inorder(b1.root);
        Aron.line();

        try {
            FileWriter fstream = new FileWriter("text/out1.txt");
            BufferedWriter out = new BufferedWriter(fstream);
            int k=0;
            serializeIndex(b1.getRoot(), out, k);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out1.txt"));
            Map<Integer, Integer> map = buildMapFromFile(in);

            k = 0;
            Node root = deSerializeIndex(map, k);
            Aron.inorder(root);

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        Aron.end();
    }

    //Write nodes to file with inorder traversal
    public static void serializeIndex(Node root, BufferedWriter out, int k) {
        if(root != null) {
            String s = k + ":" + root.data + "\n";
            try {
                serializeIndex(root.left, out, 2*k + 1);
                out.write(s);
                serializeIndex(root.right, out, 2*k + 2);
            } catch(Exception e) {
                System.err.println("Error" + e.getMessage());
            }
        }
    }
    //Initialize k = 0 
    public static Node deSerializeIndex(Map<Integer,Integer> map, int k) {
        if(map.containsKey(k)) {
            Integer data = map.get(k);
            Node root = new Node(data);
            root.left = deSerializeIndex(map, 2*k + 1);
            root.right = deSerializeIndex(map, 2*k + 2);
            return root;
        }
        return null;
    }

    public static Map<Integer,Integer> buildMapFromFile(BufferedReader in) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        try {
            String line = null;
            while((line = in.readLine()) != null) {
                line = line.trim();
                String[] array = line.split(":");
                if(array.length == 2) {
                    map.put(Integer.parseInt(array[0]), Integer.parseInt(array[1]));
                } else
                    System.err.println("Error: invalid file format");
            }
        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        return map;
    }
}
//Traveral binary tree in level order store it in HashMap
//Reconstruct the binary tree from HashMap
//
//      [p]
//[2*p+1] [2*p+2]
//

import java.util.*;
import classfile.*;

public class SerializeBinaryLevelOrder {
    public static void main(String[] args) {
        test0();        
        test1();        
        test2();        
        test3();        
        test4();        
        test5();        
    }
    static void test0(){
        Aron.beg();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        Aron.preorder(bt.root);
        levelOrder(bt.root);
        map = levelOrder(bt.root);

        BST newbt = new BST();
        int key = 0;
        newbt.root = buildBinaryTree(map, key);
        Aron.inorder(newbt.root);

        Aron.end();
    }
    static void test1(){
        Aron.beg();

        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        Aron.inorder(bt.root);
        levelOrder2(bt.root);

        Aron.end();
    }

    static void test2(){
        Aron.beg();
        //System.out.println(String.format("[%-20s]=[%s]" , "label", "content" ));
        System.out.println(String.format("[%-20s]=[%s]" , 9, "content" ));
        for(int i=0; i<5; i++){
            System.out.println(String.format("[%1$05d]" , i));
        } 
        Aron.end();
    } 
    
    static void test3(){
        Aron.beg();
        padding();
        Aron.end();
    }

    static void test4(){
        Aron.beg();

        for(int i=0; i< 5; i++){
            String str = "%1$-" + (i + 1) + "s";
            String value = String.format(str, i);
            System.out.println("["+ value + "]");
        } 
        Aron.end();
    }
    static void test5(){
        Aron.beg();

        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        int level = level(bt.root);
        System.out.println("level[" + level + "]");
        for(int i=1; i<=level; i++){
            prettyPrint(bt.root, i);
            System.out.println();
        } 
        Aron.end();
    }
    static int level(Node root){
        if(root != null){
            return Math.max(level(root.left), level(root.right)) + 1;
        }
        return 0;
    }

    static void prettyPrint(Node r, int level){
        if(r != null){
                //String format = "%1$-" + level + "s";
                String format = "%1$" + (level + 10) + "s";
                String str = "[" + r.data + "]";
                System.out.print(String.format(format, str));

            prettyPrint(r.left, level - 1);
            prettyPrint(r.right, level - 1);
        }
    }

    static void padding(){
        String[] left  = {"Technology", "Technic", "Technologies", "Technisian"};
        String[] right = {"Continuous", "Continua", "Continuously", "Continuation"};
        for(int i=0; i< left.length; i++){
            String str = "%1$-" + (i + 4) + "s";
            //System.out.println("str[" + str + "]");
            //String value = String.format("%1$-15s %2$15s", left[i], right[i]);
            String value = String.format(str + " %2$15s", left[i], right[i]);
            System.out.println("[" + value + "]");
        } 
    }

    public static Node buildBinaryTree(Map<Integer, Integer> map, int key) {
        Node root = null;
        if(map.containsKey(key)) {
            root = new Node((Integer)map.get(key));
            map.remove(key);
            root.left   = buildBinaryTree(map, 2*key+1);
            root.right  = buildBinaryTree(map, 2*key+2);
        }
        return root;
    }

    public static void levelOrderRecursion(Queue<Node> q, Map<Integer, Integer> map, int k) {
        Queue<Node> tmpQueue = new LinkedList<Node>();
        while(q.peek() != null) {
            Node node = q.remove();
            map.put(k, node.data);
            if(node.left != null)
                tmpQueue.add(node.left);
            if(node.right != null)
                tmpQueue.add(node.right);
        }
        if(tmpQueue.peek() != null)
            levelOrderRecursion(tmpQueue, map, k);
    }

    
    public static void levelOrder2(Node curr) {
        if(curr != null){
            Queue<Node> q1 = new LinkedList<Node>();
            Queue<Node> q2 = new LinkedList<Node>();
            q1.add(curr);
            while(!q1.isEmpty() || !q2.isEmpty()){

                while(!q1.isEmpty()){
                    Node node = q1.remove();
                    System.out.println("[" + node.data + "]");
                    if(node.left != null)
                        q2.add(node.left);
                    if(node.right != null)
                        q2.add(node.right);
                }

                while(!q2.isEmpty()){
                    Node node = q2.remove();
                    System.out.println("[" + node.data + "]");

                    if(node.left != null)
                        q1.add(node.left);
                    if(node.right != null)
                        q2.add(node.right);
                }
            }
        }
    }
    public static Map<Integer, Integer> levelOrder(Node root) {
        Queue<Node> queue1 = new LinkedList<Node>();
        Queue<Node> queue2 = new LinkedList<Node>();
        Queue<Integer> numq1 = new LinkedList<Integer>();
        Queue<Integer> numq2 = new LinkedList<Integer>();
        Map<Integer, Integer> orderedMap = new LinkedHashMap<Integer, Integer>();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();

        int parentIndex = -1;
        int[] Array = new int[20];
        if(root != null) {
            parentIndex= 0;
            System.out.println("here");
            queue1.add(root);
            numq1.add(parentIndex);
        }
        while(queue1.peek() != null || queue2.peek() != null) {
            while(queue1.peek() != null) {
                Node no = queue1.remove();
                parentIndex = numq1.remove();
                map.put(parentIndex, no.data);
                orderedMap.put(parentIndex, no.data);

                System.out.print("["+no.data+"]");
                System.out.print(" parentIndex="+parentIndex);
                if(no.left != null) {
                    queue2.add(no.left);
                    numq2.add(2*parentIndex+1);
                }
                if(no.right != null) {
                    queue2.add(no.right);
                    numq2.add(2*parentIndex+2);
                }
            }
            System.out.println("");
            while(queue2.peek() != null) {
                Node no = queue2.remove();
                parentIndex = numq2.remove();
                map.put(parentIndex, no.data);
                orderedMap.put(parentIndex, no.data);

                System.out.print("["+no.data+"]");
                System.out.print(" parentIndex="+parentIndex);
                if(no.left != null) {
                    queue1.add(no.left);
                    numq1.add(2*parentIndex+1);
                }
                if(no.right != null) {
                    queue1.add(no.right);
                    numq1.add(2*parentIndex+2);
                }
            }
            System.out.println("");
        }
        return map;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import classfile.BST;
import classfile.Node;
import java.util.stream.*;
import java.util.stream.Collectors;

//class Node{
//    String data;
//    Node left;
//    Node right;
//    public Node(String data){
//        this.data = data;
//    }
//}

public class SerializeBinaryTreeWithBinaryHeap{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        BST bst = new BST(); 

        bst.insert(5);
        bst.insert(2);
        bst.insert(8);
        bst.insert(4);
        Aron.inorder(bst.root);
        Integer k = 0;
        String fname =  "/tmp/bst.txt";
        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter(fname));
            write(bst.root, k, bw);
            bw.close();

            Map<Integer, Integer> map = readFile(fname);
            Node r = buildTree(map, k);

            List<Integer> list = new ArrayList<Integer>(); 
            Aron.inorderToList(r, list);

            // immutable list
            List<Integer> ls = Arrays.asList(2, 4, 5, 8);
            Test.t(ls, list);

        }catch(IOException io){
            Print.p("Ex" + io.getMessage());
        }

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    public static Map<Integer, Integer> readFile(String fname){
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        try{
            BufferedReader bf = new BufferedReader(new FileReader(fname));
            String s;
            while((s = bf.readLine()) != null){
                String[] arr = s.split(":");
                map.put(Integer.parseInt(arr[0].trim()), Integer.parseInt(arr[1].trim()));
            }
            bf.close();
        }catch(IOException e){

        }
        return map;
    }
    public static Node buildTree(Map<Integer, Integer> map, Integer k){
                    if(map.get(k) != null){
                        Node r = new Node(map.get(k));
                        r.left = buildTree(map, 2*k+1);
                        r.right = buildTree(map, 2*k+2);
                        return r;
                    }
                    return null;

    }
    public static void write(Node r, Integer k, BufferedWriter bw){
        try{
            if(r != null){
                bw.write(k + ":" + r.data + "\n");
                write(r.left, 2*k + 1, bw); 
                write(r.right, 2*k + 2, bw);
            }
        }catch(IOException io){
        }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class SerializeGeneralTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "./text/try.txt";
        
        try{
            Node r = Aron.createGeneralTree();
            Aron.inorderGeneralTree(r);
            Ut.l();
            BufferedWriter bw = new BufferedWriter(new FileWriter(file));
            serializeGeneralTree(r, bw);
            bw.close();
            
            List<String> list = Aron.readFileOneLineSplit(file);
            Aron.printlnList(list);

            Ut.l();
            Node dr = deserializeGeneralTree(list);
            Aron.inorderGeneralTree(dr);
        }catch(IOException e){
        }
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void serializeGeneralTree(Node r, BufferedWriter bw){
        if(r != null){
            try{
            bw.write(r.data + " ");
            for(Node n : r.list)
                serializeGeneralTree(n, bw);

            bw.write(" # ");
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }

    // use one stack to deserialize general tree
    public static Node deserializeGeneralTree(List<String> list){ 
        Stack<Node> stack = new Stack<>();
        for(String s : list){
            if(!s.equals("#")){
                Node n = new Node(s);
                stack.push(n);
            }else{
                if(stack.size() > 1){
                    Node top = stack.pop();
                    stack.peek().list.add(top);
                }
            }
        }
        return stack.peek();
    }
} 

import java.util.*;
import java.io.*;
import java.util.stream.*;
import classfile.*;

//class NNode<T>{
//    public T data;
//    public List<NNode> list = new ArrayList<>();
//    public NNode(T data){
//        this.data = data;
//    }
//}

public class SerializeNaryTree{
    public static void main(String[] args) {
        //test0();
        test00();
        //test1();
//        test2();
//
//        test0_deserialize_debug();
//        test1_deserialize_debug();
//        test2_deserialize_debug();
//        test00_writeFile();
          //test01_readFile();
//        test10_deserialize();
//        test11_deserializeStack();
//        test12_deserializeStack();
//        test13_deserializeStack();
//        test02_buildTreeFromLevelOrder();
    }
    static void test0(){
        Aron.beg();
        Node root = new Node("1");
        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        int level = 0;
        Aron.prettyPrintGeneral(node, level);

        Aron.end();
    }
    static void test00(){
        Aron.beg();

        String fName = "file4.txt";
        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();
        Node root = deserialize(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        Aron.end();
    }

    static void test0_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");
        root.list.add(new Node("2"));
        root.list.add(new Node("3"));
        root.list.add(new Node("4"));
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test2_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");

        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");

        Node n35 = new Node("5");
        Node n36 = new Node("6");
        n3.list.add(n35);
        n3.list.add(n36);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test1_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");
        Node n1 = new Node("2");
        Node n2 = new Node("3");
        Node n3 = new Node("4");

        Node n4 = new Node("5");
        Node n5 = new Node("6");

        n3.list.add(n4);
        n3.list.add(n5);
        root.list.add(n1);
        root.list.add(n2);
        root.list.add(n3);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Node root = new Node("1");
        root.list.add(new Node("2"));
        root.list.add(new Node("3"));
        root.list.add(new Node("4"));

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        printNary(node);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        Node n4 = new Node("4");
        Node n5 = new Node("5");

        root.list.add(n2);
        root.list.add(n3);

        n3.list.add(n4);
        n3.list.add(n5);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        printNary(node);

        Aron.end();
    }
    static void test10_deserialize(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        Node n4 = new Node("4");
        Node n5 = new Node("5");

        root.list.add(n2);
        root.list.add(n3);

        n3.list.add(n4);
        n3.list.add(n5);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }

    static void test11_deserializeStack(){
        Aron.beg();

        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        root.list.add(n2);
        root.list.add(n3);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);
 

        Aron.end();
    }

    static void test12_deserializeStack(){
        Aron.beg();
        Node root = new Node("1");
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }
    static void test13_deserializeStack(){
        Aron.beg();

        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }
    public static void printNary(Node curr){
        if(curr != null){
            Print.pbl(curr.data);
            for(int i=0; i<curr.list.size(); i++){
                printNary((Node)curr.list.get(i));
            } 
        }
    }

    public static void write(Node curr, String fname){
        if(fname != null){
            try(BufferedWriter bw = new BufferedWriter(new FileWriter(fname))){
                serialize(curr, bw);
            }catch(IOException e){
                System.out.println(e.getMessage());
            }
        }
    }
    public static List<String> read(String fname){
        List<String> list = null; 
        if(fname != null){
            try(BufferedReader br = new BufferedReader(new FileReader(fname))){
                String line; 
                while((line = br.readLine()) != null){
                    break;
                }
                list = Arrays.asList(line.trim().split("\\s+"));

                Aron.printList(list);
            }catch(IOException e){
                System.out.println(e.getMessage());
            }
        }
        return list;
    }
    //[ file=serializetree.html title=""
    // serialize n-ary tree from preorder to post order 
    public static void serialize(Node curr, BufferedWriter bw){
        if(curr != null){
            try{
                bw.write(curr.data + " ");
                for(Node node : curr.list){
                    serialize(node, bw);
                }
                bw.write("#" + " ");
            }catch(IOException e){
            }
        }
    }

    public static Node deserialize(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String token = ite.next();
            //Print.pbl("[" + token);
            if(!token.equals("#")){
                root = new Node(token);
                Node child = deserialize(ite);
                if(child != null)
                    root.list.add(child);
            }else{
                root = deserialize(ite);
            }
            //Print.pbl("]");
        }
        return root;
    }

    public static Node deserialize_debug(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String token = ite.next();
            if(!token.equals("#")){
                Print.p("[" + token);
                root = new Node(token);
                Node child = deserialize_debug(ite);
                if(child != null){
                    root.list.add(child);
                    Print.pbl(root.data + "->(" + child.data + ")");
                }
                Print.p("]");
            }else{
                Print.p("[" + token);
                root = deserialize_debug(ite);
                Print.p("]");
            }
        }
        return root;
    }
    //]

    //[ file=deserializetree.html title=""
    // deserialize with stack
    public static Node deserializeStack(Iterator<String> ite){
        Stack<Node> stack = new Stack<>(); 
        while(ite.hasNext()){
            String token = ite.next();
            if(!token.equals("#")){
                stack.push(new Node(token));
            }else{
                if(stack.size() > 1){
                    Node top = stack.pop();
                    Node peek = stack.peek();
                    peek.list.add(top);
                }
            }
        }
        return stack.peek();
    }
    //]

    public static void writeFile(Node r, String fName){
        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter(fName));
            levelOrder(r, bw);
            bw.close();
        }catch(IOException ie){
            ie.printStackTrace();
        }
    }
    public static void levelOrder(Node r, BufferedWriter bw){
        if(r != null){
            try{
                Queue<Node> queue = new LinkedList<Node>(); 
                if(r != null){
                    queue.add(r);
                    while(!queue.isEmpty()){
                        Node node = queue.remove();
                        bw.write(node.data + ":");
                        for(Node n : node.list){
                            bw.write(n.data + ":");
                            queue.add(n);
                        }
                        bw.write("\n");
                    }
                }
            }catch(IOException ie){
                ie.printStackTrace();
            }
        }
    }
    public static Map<Integer, List<Integer>> readFile(String fName){
       Map<Integer, List<Integer>> map = new HashMap<>(); 
       if(fName != null){
           try{
               BufferedReader br = new BufferedReader(new FileReader(fName));
               String line = null;
               while((line = br.readLine()) != null){
                   List<String> strList = Arrays.asList(line.split(":"));
                   // Java 8 lambda expr
                   List<Integer> list = strList.stream().map(Integer::parseInt).collect(Collectors.toList());
                   if(list.size() > 0) 
                       map.put(list.get(0), list.size() > 1? list.subList(1, list.size()) : new ArrayList<Integer>());
               }
           }catch(IOException ie){
               ie.printStackTrace();
           }
       }
       return map;
    }
    
    static void test00_writeFile(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
        Aron.end();
    }
    static void test01_readFile(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
//        Map<Integer, List<Integer>> map = readFile(fName); 
//        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
//            Print.pp(entry.getKey());
//            Aron.printList(entry.getValue());
//        } 
        Aron.end();
    }
    static void test02_buildTreeFromLevelOrder(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
        Map<Integer, List<Integer>> map = readFile(fName); 
        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
            Print.pp(entry.getKey());
            Aron.printList(entry.getValue());
        } 
        Node r = buildTreeFromLevelOrder(map, 1);  
        printNary(r);

        Aron.end();
    }
    public static Node buildTreeFromLevelOrder(Map<Integer, List<Integer>> map, Integer r){
        Node parent = null;
        if(map.size() > 0){
            parent = new Node(r + "");
            List<Integer> list = map.get(r);
            for(Integer n : list){
                parent.list.add(buildTreeFromLevelOrder(map, n));
            }
        }
        return parent;
    }
} 
import java.util.ArrayList;
public class SetMatrixZero 
{
    public static void main(String[] args)
    {
        System.out.println("SetMatrixZero");
        int[][] Matrix = {
            {0, 3, 5, 6},
            {1, 3, 5, 0},
            {4, 0, 5, 6},
            {7, 3, 5, 6}
        };
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        int len = Matrix.length; 
        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                if(Matrix[i][j] == 0)
                {
                    arrayList.add(i*len + j);
                }
            }
        }

        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                System.out.print(Matrix[i][j] + " ");
            }
            System.out.println();
        }

        System.out.println();
        for(int k=0; k<arrayList.size(); k++)
        {
            int row = arrayList.get(k)/len;
            int col = arrayList.get(k)%len;
            for(int i=0; i<len; i++)
            {
               for(int j=0; j<len; j++)
               {
                   if(i==row || j==col)
                   {
                       Matrix[i][j] = 0;
                   }
               } 
            }
        }

        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                System.out.print(Matrix[i][j] + " ");
            }
            System.out.println();
        }

    }
}
import java.util.*;
import java.io.*;
import classfile.*;

class URLShortener{
    final int base = 52;
    Map<Integer, Character> map = new HashMap<Integer, Character>(); 
    Map<Character, Integer> revmap = new HashMap<Character, Integer>(); 
    public URLShortener(){
        createMap();
    }
    //[ file=shortener.html title=""
    public StringBuilder encodeTo52(int n){
        final int base = 52; 
        StringBuilder sb = new StringBuilder();
        if(n == 0)
           sb.append("0");
        else{
            while(n > 0){
                sb.append(map.get(n % base));
                n /= base;
            }
        }
        return sb.reverse();
    }
    public int decode(StringBuilder sb){
        int sum = 0;
        for(int i=sb.length()-1; i>=0; i--){
            sum += (int)Math.pow(base, revmap.get(new Character(sb.charAt(i))));     
        }
        return sum;
    }
    public void createMap(){
        int count = 0;
        for(int i=0; i<10; i++){
            map.put(count, new Character((char)((int)'0' + i))); 
            revmap.put(new Character((char)((int)'0' + i)), count);
            count++;
        }

        for(int i=0; i<26; i++){
            map.put(count, new Character((char)((int)'a' + i))); 
            revmap.put(new Character((char)((int)'a' + i)), count);
            count++;
        }

        for(int i=0; i<26; i++){
            map.put(count, new Character((char)((int)'A' + i))); 
            revmap.put(new Character((char)((int)'A' + i)), count);
            count++;
        }

        
    }
    //]
    public void printMap(){
        for(Map.Entry<Integer, Character> entry: map.entrySet()){
            System.out.println("[" + entry.getKey() + "] [" + entry.getValue() + "]"); 
        }
    }
}


public class Shortener{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    public int encode(int n){
        return 1;
    }

    static void test0(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(100); 
        System.out.println("100[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(0); 
        System.out.println("0[" + sb.toString() + "]"); 
        Aron.end();
    }

    static void test2(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(9); 
        System.out.println("9[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test3(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(10); 
        System.out.println("10[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test4(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(11); 
        System.out.println("11[" + sb.toString() + "]"); 
        Aron.end();
    }

    static void test5(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(1000000); 
        System.out.println("1000000[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(100000000); 
        System.out.println("100000000[" + sb.toString() + "]"); 
        Aron.end();
    }
} 
import classfile.*;

// update: Wed Sep 28 03:22:10 PDT 2016
//
public class ShortestPathKthEdge {
    static final int INT = 100;
    public static void main(String[] args) {
        Print.p("Hello World!");
        int[][] graph= { 
            {0, 10, 3, 2},
            {INT, 0, INT, 7},
            {INT, INT, 0, 6},
            {INT, INT, INT, 0}
        };
        int u = 0;
        int v = 3;
        int k = 2;
        int numVertex = 4;
        int min = minPath(graph, numVertex, k, u, v);
        Print.p("u=["+u+"]");
        Print.p("v=["+v+"]");
        Print.p("k=["+k+"]");
        Print.p("finalmin=["+min+"]");
        int numEdge = 0;

        //GraphTraveral(graph, numVertex, numEdge);
        Ut.l();
        PreorderGraphTraveral(graph, numVertex, numEdge);
        Ut.l();
        PostGraphTraveral(graph, numVertex, numEdge);
        /*
        int min2 = minPathDP(graph, numVertex, numEdge, u, v);
        Print.p("min2=["+min2+"]");
        */
    }

    //Use Depth First Search to find the shortest path from vertex u to v with k edges
    public static int minPath(int[][] graph, int numVertex, int k, int u, int v) {
        //when u == v, assume the cycle in the same node
        if(k <= 0 && u == v)
            return 0;
        else if( k <= 0)
            return INT;
        /*
        else if( k == 1 && graph[u][v] != INT)
            return graph[u][v];
        */
        else {
            int min = INT;
            for(int i=0; i<numVertex; i++) {
                if(graph[u][i] != INT && u != i && v != i) {
                    Print.p("inorder["+u+"]["+i+"]=["+graph[u][i]+"]");
                    Print.p("k=["+k+"]");
                    int subm = minPath(graph, numVertex, k-1, i, v);
                    if(subm != INT) {
                        min = Math.min(min, subm) + graph[u][i];
                        Print.p("min=["+min+"] subm["+subm+"]   ["+u+"]["+i+"]");
                    }
                }
            }
            return min;
        }
    }

    //Traveral from node(depth) to other nodes
    public static void PostGraphTraveral(int[][] w, int numVertex, int depth) {
        for(int i=0; i<numVertex; i++) {
            if( i !=depth && w[depth][i] != 0 && w[depth][i] != INT) {
                PostGraphTraveral(w, numVertex, i);
                //Print.p(depth+"->"+i+"["+w[depth][i]+"]");
                Print.p(i+"->"+depth+"["+w[depth][i]+"]");
            }
        }
    }

    //Preorder Traveral
    public static void PreorderGraphTraveral(int[][] w, int numVertex, int depth) {
        for(int i=0; i<numVertex; i++) {
            if( i !=depth && w[depth][i] != INT) {
                Print.p(depth+"->"+i+"["+w[depth][i]+"]");
                PreorderGraphTraveral(w, numVertex, i);
            }
        }
    }


    //Use dynamic programming to find the shortest path from vertex u to v with numEdge
    //edge
    public static int minPathDP(int[][] graph, int numVertex, int numEdge, int u, int v) {
        int[][][] cube = new int[numVertex][numVertex][numEdge+1];

        for(int e=0; e<numEdge+1; e++) {
            for(int i=0; i<numVertex; i++) {
                for(int j=0; j<numVertex; j++) {
                    cube[i][j][e] = INT;

                    //base case
                    if( e == 0 && i == j)
                        cube[i][j][e] = 0;
                    else if ( e == 1 && graph[i][j] != INT)
                        cube[i][j][e] = graph[i][j];
                    else if( e > 1) {
                        for(int a=0; a < numVertex; a++) {
                            if(i != j && a != i && a != j && graph[i][a] != INT &&
                                    cube[i][j][e-1] != INT)
                                cube[i][j][e] = Math.min(graph[i][a] + cube[a][j][e-1],
                                                         cube[i][j][e]);
                        }
                    }
                }
            }

            for(int i=0; i<numVertex; i++) {
                for(int j=0; j<numVertex; j++) {
                    if(cube[i][j][e] < 100)
                        Print.p("["+cube[i][j][e]+"]");
                    else
                        Print.p("["+0+"]");
                }
            }
        }
        return cube[u][v][numEdge];
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Shuffle 
{
	public static void main(String args[])
	{
		int[] B = new int[10];
		for(int i=0; i<10; i++)
			B[i] = i;  

		for(int i=0; i<B.length; i++)
			System.out.print(B[i]+" ");

		System.out.println();

		int[] A = Shuffle(B);
		for(int i=0; i<B.length; i++)
			System.out.print(A[i]+" ");
		System.out.println();
        
        test1();
        test2();

	}
	public static int[] Shuffle(int[] A)
	{
		Random ran = new Random();
		if( A != null) {
			int len=A.length;
			if(len > 1)
			for(int i=0; i<len; i++) {
				int r = ran.nextInt(len) % (len-i);
				int tmp = A[r]; A[r] = A[len-1-i]; A[len-1-i] = tmp;
			}
		}
		return A;
	}

    // given string s and t of the same length
    public static String PerfectShuffle(String s, String t)
    {
        int n = s.length();    
        if(n <= 1) return s + t;
        
        String a = PerfectShuffle(s.substring(0, n/2), t.substring(0, n/2));
        String b = PerfectShuffle(s.substring(n/2, n), t.substring(n/2, n));
        return a + b;
    }
    public static void test1()
    {
        String s = "abc";
        String t = "efg";
        System.out.print("\n test1() \n");
        System.out.print("\n s=" + s + "\n");
        System.out.print("\n t=" + t + "\n");
        System.out.print("\n PerfectShuffle()=" + PerfectShuffle(s, t) + "\n");
    }
    public static void test2()
    {
        String s = "a";
        String t = "e";
        System.out.print("\n test2() \n");
        System.out.print("\n s=" + s + "\n");
        System.out.print("\n t=" + t + "\n");
        System.out.print("\n PerfectShuffle()=" + PerfectShuffle(s, t) + "\n");
    }
}
public class SieveEratosthenes 
{
    public static void main(String[] args)
    {
        long startTime = System.currentTimeMillis();
        Prime(1000000);
        long endTime = System.currentTimeMillis();
        long diff = endTime - startTime;
        System.out.println("diff=" + diff);
    }

    //Find all the primes from 2 to n
    //Sieve of Eratosthenes Algorithm
    public static void Prime(int n)
    {
        boolean[] prime = new boolean[n+1];
        for(int i=0; i<n; i++)
            prime[i] = true;

        for(int i=2; i<Math.sqrt(n); i++)
        {
            int k=0;
            int index = i*i + k*i;
            if(prime[i])
            {
                while(index <= n)
                {
                    if(prime[index])
                        prime[index] = false;
                    index = i*i + k*i;
                    k++;
                }
            }
        }
        for(int i=2; i<n; i++)
        {
            System.out.println("[" + i + "]=" + prime[i]);
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

// 4:22, 5:41, 6:19
// Least Recent Used Cache
//

//[ file=simpleLRU.html title=""
// Least Recent Used Cache, LRU
class LNode {
    String key;
    Object data;
    public LNode(String key, Object data) {
        this.data = data;
        this.key = key;
    }
}

class LRU {
    final int max;
    int count;
    LinkedList<LNode> list = new LinkedList<LNode>();
    Map<String, LNode> map = new HashMap<String, LNode>();

    public LRU(int max) {
        this.max = max;
        this.count = 0;
    }
    public void insert(String key, LNode node) {
        LNode value = map.get(key);
        if(value != null) {
            list.remove(value);
            list.addLast(node);
            map.put(key, node);
        } else {
            if(count < max) {
                map.put(key, node);
                list.addLast(node);
                count++;
            }else{
                LNode reNode = list.removeFirst();
                list.addLast(node);
                map.remove(reNode.key);
                map.put(key, node);
            }
        }
    }
    public void remove(String key) {
        if(count > 0 && map.containsKey(key)){
            LNode node = map.get(key);
            if(node != null){
                list.remove(node);
                map.remove(key);
                count--;
            }
        }
    }

    public void print(){
        for(Map.Entry<String, LNode> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue().data + "]");
        } 
        Aron.line();

        for(LNode node : list){
            System.out.println("["+ node.data + "]");
        }
    }
}
//]

public class SimpleLRU{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0() {
        Aron.beg();
        LRU lru = new LRU(3);
        String k1 = "dog";
        String k2 = "cat";
        String k3 = "cow";
        LNode node1 = new LNode(k1, "Excuse, Technical, Technician, Torch");
        LNode node2 = new LNode(k2, "This is typical excuse for being late");
        LNode node3 = new LNode(k3, "Please elaborate your question, please clarify your intention, The wound will heal up");

        lru.insert(k1, node1);
        lru.insert(k2, node2);
        lru.insert(k3, node3);

        lru.print();

        Aron.end();
    }
    static void test1() {
        Aron.beg();
        LRU lru = new LRU(3);
        String k1 = "dog";
        String k2 = "cat";
        String k3 = "cow";
        String k4 = "pig";

        LNode node1 = new LNode(k1, "First, Excuse, Technical, Technician, Torch");
        LNode node2 = new LNode(k2, "Second, This is typical excuse for being late");
        LNode node3 = new LNode(k3, "Third, Please elaborate your question, please clarify your intention, The wound will heal up");
        LNode node4 = new LNode(k4, "Fourth, Injuring 100 people and wounding 20 people in the bombing near the market in Thailand");

        lru.insert(k1, node1);
        lru.insert(k2, node2);
        lru.insert(k3, node3);
        lru.insert(k4, node4);

        lru.print();

        Aron.end();
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class SingleLinkedList_test{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test0(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        sll.append(n1);
        sll.print();

        Aron.end();
    }

    public static void test1(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        sll.append(n1);
        sll.remove(n1);

        sll.print();

        Aron.end();
    }

    public static void test2(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

//        sll.remove(n1);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 2);
        Test.t(list.get(2).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test3(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 2);
        Test.t(list.get(1).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test4(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n2);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 3);

        sll.print();

        Aron.end();
    }

    public static void test5(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n3);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 2);

        sll.print();

        Aron.end();
    }

    public static void test6(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        sll.remove(n2);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test7(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        sll.remove(n2);
        sll.remove(n3);
        List<Node> list = sll.toList();
        Test.t(list.size() == 0);

        sll.print();

        Aron.end();
    }
} 

import classfile.*;

class RunnableThread implements Runnable {
    String name;
    public void run() {
        Foo f = Foo.getInstance();
        Print.pb(f.getNum());
    }
}

final class Foo{
    private static volatile Foo single;
    private static int num = 0;
    private Foo(){
    }

    public synchronized static Foo getInstance(){
        if(single == null){
            single = new Foo();
            Print.pb("an Object is created first time");
        }
        else{
            Print.p("an Object has been created");
        }
        return single;
    }
    public int getNum(){
        return num;
    }
}
   
public class Singleton{
    public static void main(String[] args){
        test1();
    }
    
    static void test1(){
        Aron.beg();
        for(int i=0; i<10; i++) {
            Thread t1 = new Thread(new RunnableThread());
            t1.start();
        }
        Aron.end();
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

class Interval implements Comparable<Interval> {
    public int begin;
    public int end;
    public Interval(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter) {
        if(this.begin > inter.begin)
            return 1;
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString() {
        return "[" + begin + " " + end + "]";
    }
}

public class Hello {
    public static void main(String[] args) {
        test0();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test00();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    static void test00() {
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};

        for(int i=0; i<arr1.length; i++) {
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0) {
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()) {
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else {
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()) {
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }

        Aron.end();
    }

    static void test0() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(5);
        sll.append(4);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = cloneLinkedList(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test2() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test3() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test4() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test5() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test6() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test7() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseLinkedList(sll.head);
        Aron.printSLL(nhead);

        Aron.end();
    }

    static void test8() {
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseIte(sll.head);
        Aron.printSLL(nhead);
        Aron.end();
    }

    static void test9() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        SingleLinkedList sll2 = new SingleLinkedList();
        sll2.append(1);
        sll2.append(2);
        sll2.append(3);


        Node curr = sll.head;
        Node head = sll.head;

        while(curr != null && curr.next != null) {
            curr = curr.next;
        }
        curr.next = head;

        boolean circular = isCircular(sll.head);
        System.out.println("isCircular[" + circular + "]");

        boolean circular2 = isCircular(sll2.head);
        System.out.println("isCircular2[" + circular2 + "]");

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str = "";
        System.out.println("empty str " + str + "[" + isBalance(str) + "]");

        str = "()";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "([)]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "()([])";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        Aron.end();
    }
    
    static void test11(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        h = insertNodeToSortedList(ssl.head, 5);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test13(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node newHead = insertNodeToSortedList(ssl.head, 15);
        Aron.printSLL(newHead);
        Aron.end();
    }

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=nextnext.html title=""
    public static Node reverseIte(Node curr) {
        Node prev = null;
        Node next = null;
        while(curr != null) {
            next = curr.next;
            curr.next = prev;

            prev = curr;
            curr = next;
        }
        return prev;
    }

    public static Node reverseLinkedList(Node curr) {
        if(curr == null || curr.next == null)
            return curr;

        Node head = reverseLinkedList(curr.next);
        curr.next.next = curr;
        curr.next = null;

        return head;
    }

    public static Node reversePair(Node head) {
        Node curr = head;
        while(curr != null && curr.next != null) {
            int tmp = curr.data;
            curr.data = curr.next.data;
            curr.next.data = tmp;

            curr = curr.next.next;
        }
        return head;
    }

    public static boolean isCircular(Node curr) {
        if(curr == null)
            return false;
        else {
            Node next = curr.next;
            if(curr == next)
                return true;

            while(next != null) {
                if(curr == next)
                    return true;

                curr = curr.next;

                next = next.next;
                if(next != null)
                    next = next.next;
            }
        }
        return false;
    }
    //]


    static Node cloneLinkedList(Node head) {
        Node newHead = null;
        Node newCurr = null;
        Node curr = head;

        if(curr != null) {
            newCurr = newHead = new Node(head.data);

            while(curr.next != null) {
                newCurr.next = new Node(curr.next.data);
                newCurr = newCurr.next;
                curr = curr.next;
            }
        }
        return newHead;
    }

//    static boolean isBal(String str, int index){
//        if(str != null && index < str.length()){
//            if(!isBal(str, index + 1))
//                return false;
//
//            if(str.charAt(index) == '(' || str.charAt(index) == '[')
//                return isBal(str, index + 1);
//            else
//                return false;
//
//            else if(str.charAt(index) == ')'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '(') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }else if(str.charAt(index) == ']'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '[') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }
//        }
//        return true;
//    }

    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }

    static Node insertNodeToSortedList(Node head, int num){
       Node curr = head; 
       Node prev = null;

       while(curr != null){
           if(curr.data < num){
               prev = curr;
               if(curr.next == null){
                   prev.next = new Node(num);
                   return head;
               }
           }else{
               if(prev != null){
                   prev.next = new Node(num);
                   prev.next.next = curr;
                   return head;
               }else{
                   // first node
                   Node node = new Node(num);
                   node.next = curr;
                   head = node;
                   return head;
               }
           }
           curr = curr.next;
       }
       return head;

    }

    static boolean isBalance(String str) {
        Stack<String> stack = new Stack<String>();
        if(str != null) {
            for(int i=0; i<str.length(); i++) {
                String s = str.charAt(i) + "";
                if(s.equals("(") || s.equals("[")) {
                    stack.push(s);
                } else {
                    if(s.equals(")")) {
                    if(!stack.empty() && stack.peek().equals("(")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else if(s.equals("]")) {
                    if(!stack.empty() && stack.peek().equals("[")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else {
                        System.out.println("Error");
                        return false;
                    }

                }
            }
        }
        return stack.empty();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class SortArray{
    public static void main(String[] args) {
        String[] arr = {"techie", "dangling", "cat", "scene", "ancestor", "scene", "descend", "descended", "sibling", "dangling"}; 
        List<String> list = sortArray(arr);
        Aron.printList(list);
    }
    public static List<String> sortArray(String[] arr){
        Arrays.sort(arr);
        return Arrays.asList(arr);
    }

    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.List;
import java.util.ArrayList;
import classfile.*;

// sorted linkedlist, sorted linked list

class SingleLinkedList {
    Node head;
    public SingleLinkedList() {
        head = null;
    }
    public void append(Node no) {
        Node cur = head;
        if(head == null)
            head = no;
        else {
            while(cur.next != null) {
                cur = cur.next;
            }
            cur.next = no;
        }
    }
    public void append(int n) {
        Node cur = head;
        if(head == null)
            head = new Node(n);
        else {
            while(cur.next != null) {
                cur = cur.next;
            }
            cur.next = new Node(n);
        }
    }

    //recursive
    static Node next=null;
    public void Reverse(Node cur) {
        if(cur != null) {
            Reverse(cur.next);
            if(next != null)
                next.next = cur;
            else
                head = cur;
            next = cur;
            cur.next = null;
        }
    }
    //iteration
    public void Reverse1(Node cur) {
        if(head != null) {
            Node prev = null;
            Node next = cur.next;

            while(cur != null) {
                cur.next = prev;
                prev = cur;
                cur = next;
                if(next != null)
                    next = next.next;
            }
            head = prev;

        }
    }
    public Node getHead() {
        return head;
    }
    public void Remove(Node no) {
        if(no != null && head != null) {
            Node cur = head;
            Node prev = null;
            while(cur != no) {
                prev = cur;
                cur = cur.next;
            }
            if(prev != null && no.next != null) {
                prev.next = no.next;
                no.next = null;
            } else if(prev == null && no.next != null) {
                head = no.next;
                no.next = null;
            } else if(prev != null && no.next == null) {
                prev.next = null;
            } else {
                no = null;
                head = null;
            }
        }
    }
}


//simple sort linked list algorithm
public class SortLinkedList {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(4);
        sll.append(3);
        sll.append(2);
        sll.append(9);
        sll.append(6);
        sll.append(8);
        sll.append(1);
        sll.append(7);


        Aron.line();
        sort(sll.getHead());
        Aron.printSLL(sll.head);

    }

    // [2, 4, 5, 7]
    // [2, 4, 5]
    // [2, 4]
    public static void sort(Node head) {
        if(head != null && head.next != null) {
            Node curr = head;
            Node last = null;
            while(head != last) {
                Node next = curr.next;

                while(next != last) {
                    Print.pbl(curr.data + " " + next.data);
                    if(curr.data > next.data) {
                        int tmp = curr.data;
                        curr.data = next.data;
                        next.data = tmp;
                    }
                    curr = next;
                    next = next.next;
                }
                Aron.line();

                last = curr;
                curr = head;
            }
        }
    }
}
package JavaLib.classfile; 

import classfile.*;

public class SortedLinkedList{
    public Node insert(Node node, int n){
        Node head = node;
        Node curr = node; 
        Node prev = null; 
        while(curr != null && n > curr.data){
            prev = curr;
            curr = curr.next;
        }

        if(curr != null){
            if(prev != null){
                // 3, [2]<-[4]  >  [2]<-{3}<-[4]
                prev.next = new Node(n);
                prev.next.next = curr;
            }else{
                // {1} [2] > {1}<-[2]
                head = new Node(n);
                head.next = curr;
            }
        }else{
            // [2] {3}  > [2]<-{3}
            if(prev != null){
                prev.next = new Node(n);
            }else{
                // {3}
                head = new Node(n);
            }
        }
        return head;
    }
} 
import java.util.*;
import java.io.*;
import classfile.*;

import java.io.IOException;

// spawn new process, spawn process, create process, create new process
public class SpawnProcess{
    public static void main(String[] args) {
        String cmd = "/opt/local/bin/mvim";
        Aron.spawnProcess(cmd);
    }
}
import java.io.*;
class Split 
{
	public static void main(String args[])
	{
		String str= "20.123.111.33";
		String[] Arr = str.split("\\.");
		for(int i = 0; i < Arr.length; i++)
		{
			System.out.println(Arr[i]);
		}
	}
	
}
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Stack;

public class SplitExpression{

    public static void main(String[] args) {
        test0();
    }

    //[ file=splitexp.html title=""
    public static List<String> splitExpr(String exp){
        List<String> list = new ArrayList<String>();

        StringTokenizer stoken = new StringTokenizer(exp, "+-/* ", true);
        while(stoken.hasMoreTokens()){
            String token = stoken.nextToken();
            list.add(token);
        }
        return list;
    }
    //]
    
    public static int evaluate(List<String> list){
        Stack<Integer> stack = new Stack<Integer>(); 
        for(String token : list){
            if(token == "+" || token == "/" || token == "-" || token == "*"){
                int value = 0;
                int first = Integer.parseInt(stack.top());
                stack.pop();
                int second = Integer.parseInt(stack.top());
                stack.pop();
                if( token == "+")
                    value = first + second; 
                else if ( token == "-")
                    value = second - first;
                else if ( token == "*")
                    value = first * second;
                else if( token == "/")
                    value = second / first;
                stack.push(value + "");
            }else{
                stack.push(token);
            }
        }
    } 

    static void test0(){
        System.out.println("---------------------------------\n");
        String exp = "512 + 4 × + 3 −";
        List<String> list = splitExpr(exp);
        Aron.printList(list);
        System.out.println("---------------------------------\n");
    }
}
import java.util.*;
import java.io.*;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

import classfile.*;

// Notice, do not import com.mysql.jdbc.*
// or you will have problems!

public class SqlConnection{
    public static void main(String[] args) {
        Connection connect = null;
        Statement statement = null;
        PreparedStatement preparedStatement = null;
        ResultSet resultSet = null;

        try {

            // -----------------------------------------------------
            // database: testdb
            // table: item
            // user: root
            // password: {empty}
            // no ssh: autoReconnect=true&useSSL=false 
            //-------------------------------------------------------------------------------- 
            Class.forName("com.mysql.jdbc.Driver").newInstance();
            connect = DriverManager
                      .getConnection("jdbc:mysql://localhost/testdb?autoReconnect=true&useSSL=false&"
                                     + "user=root&password=");

            // Statements allow to issue SQL queries to the database
            statement = connect.createStatement();
            // Result set get the result of the SQL query
            resultSet = statement
                        .executeQuery("select * from testdb.item");
            if(resultSet.next()){
                // get the second column
               String name = resultSet.getString(2);
                Print.pbl(name);
            }
        }catch (Exception ex) {
            // handle the error
            Print.pbl(ex.getMessage());
        }
    }
}
import java.io.*;
class Square 
{
	public static void main(String args[])
	{
        double n = 0.9;
		sqrt(n);
        double value = sqrt2(n, 0.00001);
        System.out.println("real sqrt(value)=" + Math.sqrt(n));
        System.out.println("value=" + value);
	}
	public static double sqrt(double n)
	{
		double a = 1.0;
		double b = n/2;

		for(int i = 0; i < 10; i++)
		{
			if( ((a + b)/2)*((a + b)/2) > n)
			{
				b = (a + b)/2;
			}
			else if( ((a + b)/2)*((a + b)/2) < n)
			{
				a = (a + b)/2;
			}
			else if( ((a + b)/2)*((a + b)/2) == n)
			{

			}
			System.out.println("a=" + a + " b=" + b);
		}
		return a;	
	}
    //Precondition: n is integer and greater than or equal zero 
    public static double sqrt2(double n, double error)
    {
        double left = 0;
        double right = n; 
        double value = 0;
        double diff = 2*error;
        while(Math.abs(diff) > error)
        {
            value = (left + right)/2;
            diff = value*value - n;
            if(diff > 0)
            {
                right = value;
            }
            else if(diff < 0)
            {
                left = value;
            }
            else
                break;
        }
        return value;
    }
}
import java.util.*;

//unique solution
//{3,0,0,2,0,0,0,0,0},
//{0,0,0,1,0,7,0,0,0},
//{7,0,6,0,3,0,5,0,0},
//{0,7,0,0,0,9,0,8,0},
//{9,0,0,0,2,0,0,0,4},
//{0,1,0,8,0,0,0,5,0},
//{0,0,9,0,4,0,3,0,1},
//{0,0,0,7,0,2,0,0,0},
//{0,0,0,0,0,8,0,0,6}

class Sudoku {
    final int gridSize = 9;
    int[][] array;
    int[][] board = {
                    //{0,0,0,0},
                    //{0,0,0,0},
                    //{0,0,0,0},
                    //{0,0,0,0}
        
                    {0,0,0,2,0,0,0,0,0},
                    {0,0,0,1,0,7,0,0,0},
                    {0,0,6,0,3,0,5,0,0},
                    {0,0,0,0,0,9,0,8,0},
                    {0,0,0,0,2,0,0,0,4},
                    {0,0,0,8,0,0,0,5,0},
                    {0,0,9,0,4,0,3,0,1},
                    {0,0,0,7,0,2,0,0,0},
                    {0,0,0,0,0,8,0,0,6}
            };

    /*
    int[][] board = {
                    {3,0,0,2,0,0,0,0,0},
                    {0,0,0,1,0,7,0,0,0},
                    {7,0,6,0,3,0,5,0,0},
                    {0,7,0,0,0,9,0,8,0},
                    {9,0,0,0,2,0,0,0,4},
                    {0,1,0,8,0,0,0,5,0},
                    {0,0,9,0,4,0,3,0,1},
                    {0,0,0,7,0,2,0,0,0},
                    {0,0,0,0,0,8,0,0,6}
        
                    //{0,0,0,2,0,0,0,0,0},
                    //{0,0,0,1,0,7,0,0,0},
                    //{0,0,6,0,3,0,5,0,0},
                    //{0,0,0,0,0,9,0,8,0},
                    //{0,0,0,0,2,0,0,0,4},
                    //{0,0,0,8,0,0,0,5,0},
                    //{0,0,9,0,4,0,3,0,1},
                    //{0,0,0,7,0,2,0,0,0},
                    //{0,0,0,0,0,8,0,0,6}
            };
            */

    int numEmpty;
    public Sudoku() {
        array = new int[gridSize*gridSize][2];
        numEmpty = findEmptyNumber();
    }
    public void printBoard() {
        System.out.println();
        for(int c=0; c<gridSize; c++) {
            for(int r=0; r<gridSize; r++) {
                System.out.print("["+board[c][r]+"]");
            }
            System.out.println();
        }
        System.out.println();
    }

    public void solver(int k) {
        if(k == numEmpty) {
            printBoard();
        }
        else {
            int c = array[k][0];
            int r = array[k][1];
            for(int i=1; i<=gridSize; i++) {
                if(checkColRow(c, r, i) && checkSquare(c, r, i)) {
                    board[c][r] = i;
                    solver(k+1);
                    board[c][r] = 0;
                }
            }
        }
    }

    public void solver_Graph(int k, int[] arr) {
        if(k == numEmpty) {
            //printBoard();
            int hc = arr[0]/4;
            int hr = arr[0]%4;
            String childStr = "\"[" + hc + "," + hr + "]\"";
            String childLabel = childStr + "[style=filled, fillcolor=green];";
            System.out.println(childLabel);
        }
        else {
            int c = array[k][0];
            int r = array[k][1];
            int ec = arr[0]/4;
            int er = arr[0]%4;
            String parentStr = "\"[" + ec + "," + er + "]\"";
            int parent = arr[0];
            for(int i=1; i<=gridSize; i++) {
                arr[0] += 1;
                int child = arr[0];
                int hc = arr[0]/4;
                int hr = arr[0]%4;
                String childStr = "\"[" + hc + "," + hr + "]\"";
                System.out.println(parentStr +"->"+ childStr); 
                if(checkColRow(c, r, i) && checkSquare(c, r, i)) {
                    board[c][r] = i;
                    solver_Graph(k+1, arr);
                    board[c][r] = 0;
                }
            }
        }
    }

    public int findEmptyNumber() {
        int count = 0;
        for(int c=0; c<gridSize; c++) {
            for(int r=0; r<gridSize; r++)
                if(board[c][r] == 0) {
                    array[count][0]=c;
                    array[count][1]=r;
                    count++;
                }
        }
        return count;
    }

    public boolean checkColRow(int c, int r, int num) {
        for(int i=0; i<gridSize; i++) {
            if(board[c][i] == num || board[i][r] == num)
                return false;    
        }
        return true;
    }
    
    public boolean checkSquare(int col, int row, int num) {
        int blockSize = (int)Math.sqrt(gridSize);
        int qcol = col/blockSize;
        int qrow = row/blockSize;
        for(int c = 0; c<blockSize; c++) {
            for(int r = 0; r<blockSize; r++) {
                if(board[qcol*blockSize+c][qrow*blockSize+r] == num)
                    return false;
            }
        }
        return true;
    }
}

public class SudokuSolver {
    public static void main(String[] args) {
        Sudoku s = new Sudoku();
        int k=0;
        //s.solver(k);
        int[] arr = {0};
        System.out.println("digraph G {\n");
        //s.solver_Graph(k, arr);
        s.solver(k);

        System.out.println("}\n");
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class SudokuSolverNew{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
                        {0,0,0,2,0,0,0,0,0},
                        {0,0,0,1,0,7,0,0,0},
                        {0,0,6,0,3,0,5,0,0},
                        {0,0,0,0,0,9,0,8,0},
                        {0,0,0,0,2,0,0,0,4},
                        {0,0,0,8,0,0,0,5,0},
                        {0,0,9,0,4,0,3,0,1},
                        {0,0,0,7,0,2,0,0,0},
                        {0,0,0,0,0,8,0,0,6}
                };
        int index = 0;
        int size = 0; 

        for(int i=0; i<9; i++){
            for(int j=0; j<9; j++){
                if(arr2d[i][j] == 0)
                    size++;
            }
        } 

        sudokuSolver(arr2d, index);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    // given 2d array and find a solution for the sudoku
    // 9x9 grid contains the number from 1 to 9
    // -------------------------------------------------------------------------------- 
    // each 3x3 grid contains the number from 1 to 9   
    // each row or column contains the number from 1 to 9
    // -------------------------------------------------------------------------------- 
    public static void sudokuSolver(int[][] arr2d, int index){ 
        int c = index / 9;
        int r = index % 9;
        if(index == 81){
            Aron.printArray2D(arr2d);
        }else{
            if(arr2d[c][r] == 0){
                for(int i=1; i<=9; i++){
                    if(checkSquare(arr2d, c, r, i) && checkColRow(arr2d, c, r, i)){
                        arr2d[c][r] = i; 
                        sudokuSolver(arr2d, index+1);
                        arr2d[c][r] = 0;
                    }
                }
            }else
                sudokuSolver(arr2d, index+1);
         }
    }

    public static boolean checkSquare(int[][] arr2d, int col, int row, int testNum){
        int ic = col/3;
        int ir = row/3;
        for(int c=0; c<3; c++){
            for(int r=0; r<3; r++){
                if(arr2d[c + ic*3][r + ir*3] == testNum) 
                    return false;
            }
        } 
        return true;
    }
    public static boolean checkColRow(int[][] arr2d, int c, int r, int testNum){
        for(int i=0; i<9; i++){
            if(arr2d[c][i] == testNum || arr2d[i][r] == testNum)
                return false;
        }
        return true;
    }
    
} 

import java.util.*;

class Node
{
    Map<Character, Node> map = new HashMap<Character, Node>();
    boolean isWord = false;
    public Node(){}
}

class Tries
{
    Node root;
    public Tries()
    {
        root = new Node();
    }
    public void print(Node curr, List<Character> list)
    {
        if(curr != null)
        {   
            if(curr.isWord)
            {
                for(Character chara:list)
                {
                    System.out.print("["+chara+"]");
                }
                System.out.println();
            }
            for(Character ch: curr.map.keySet())
            {
                list.add(ch);
                print(curr.map.get(ch), list);
                list.remove(ch);
            }
        }
    }
}

public class SuffixTree 
{
    public static void main(String[] args)
    {
        test1();
        test2();
    }
    public static void test1()
    {
        System.out.println("test1()");
        Tries tri = new Tries();
        int depth = 0;
        List<Character> list = new LinkedList<Character>();
        Node myroot = tri.root;
        insert(tri.root, "dog", depth);
        insert(tri.root, "cat", depth);
        insert(tri.root, "human", depth);
        insert(tri.root, "animal", depth);
        insert(tri.root, "mono", depth);
        insert(tri.root, "momo", depth);
        insert(tri.root, "mo", depth);
        insert(tri.root, "mom", depth);
        tri.print(myroot, list);
        String pattern = "m";
        boolean ret = search(myroot, pattern);
        System.out.println("Find pattern=["+pattern+"]=["+ret+"]");
    }
    public static void test2()
    {
        System.out.println("test2()");
        Tries tri = new Tries();
        int depth = 0;
        List<Character> list = new LinkedList<Character>();
        Node myroot = tri.root;
        insert(tri.root, "dog", depth);
        insert(tri.root, "cat", depth);
        insert(tri.root, "human", depth);
        insert(tri.root, "animal", depth);
        insert(tri.root, "mono", depth);
        insert(tri.root, "momo", depth);
        insert(tri.root, "mo", depth);
        insert(tri.root, "mom", depth);
        tri.print(myroot, list);
        String pattern = "mom";
        boolean ret = search(myroot, pattern);
        System.out.println("Find pattern=["+pattern+"]=["+ret+"]");
    }
    public static void insert(Node root, String s, int depth)
    {
        if(depth == s.length())
        {
            if(root != null)
                root.isWord = true;
        } 
        else if(depth < s.length()) 
        {
            if(root == null)
            {
                root = new Node();
                Node subNode = new Node();
                root.map.put(s.charAt(depth), subNode); 
                insert(subNode, s, depth+1);
            }
            else
            {
                Character key = new Character(s.charAt(depth));
                Node child= root.map.get(key);
                if(child == null)
                    child = new Node();
                root.map.put(key, child);
                insert(child, s, depth+1);
            }
        }
    }
    public static boolean search(Node root, String pattern)
    {
        boolean ret = true;
        Node curr = root;
        if(curr != null && pattern != null)
        {
            for(int i=0; i<pattern.length() && ret; i++)
            {
                Character key = new Character(pattern.charAt(i));
                Node child = curr.map.get(key);        
                if(child != null)
                    curr = child;    
                else
                    ret = false;        
            }
            if(!curr.isWord)
               ret = false; 
        }
        return ret;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class SumIntegerPath 
{

	public static void main(String args[])
	{
        Test1();
	}
    public static void Test1()
    {
        BST b1 = new BST();
		b1.Insert(6);
        
		b1.Insert(3);
		b1.Insert(1);
        
		b1.Insert(7);
		b1.Insert(5);
		b1.Insert(2);
        
        int[] A = new int[10];
        int depth = 0;
        int sum = PathInteger(b1.getRoot(), depth, A);
        System.out.println("sum=["+sum+"]");
    }

    //Find the sum of all paths which form all the integer
    public static int PathInteger(Node curr, int depth, int[] A)
    {
        int sum = 0;
        if(curr != null)
        {
            A[depth]= curr.data;
            int lsub = PathInteger(curr.left, depth+1, A);
            int rsub = PathInteger(curr.right, depth+1, A);
            int s = 0;
            if(curr.left == null && curr.right == null)
            {
                for(int i=0; i<=depth; i++)
                {
                   s += A[i]*Math.pow(10, depth-i); 
                }
            }
            sum += lsub + rsub + s;
        }
        return sum;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class SwapBSTNode {
    public static void main(String args[]) {
//        test0();
//        test00();
        test000();
    }
    static void test0(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Ut.l();

        Aron.inorder(b1.root);
        Aron.binImage(b1.root);
        Ut.l();

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        swap(199, 16, b1.root, first, second);
        Aron.binImage(b1.root);
        Aron.inorder(b1.root);
        Aron.end();
    }
    static void test00(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Ut.l();

        Aron.inorder(b1.root);
        Aron.binImage(b1.root);
        Ut.l();

        Node tmp = null;
        swap2(b1.root, 199, 16, tmp);
        Aron.binImage(b1.root);
        Aron.inorder(b1.root);
        Aron.end();
    }
    static void test000(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);

        b1.insert(17);
        b1.insert(199);
        b1.insert(16);

        Ut.l();

        Aron.inorder(b1.root);
        Aron.binImage(b1.root);
        Ut.l();

        Node tmp = null;
        swap2(b1.root, 10, 16, tmp);
        Aron.binImage(b1.root);
        Aron.inorder(b1.root);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 

    // old way to swap two nodes
    public static void swap(int m, int n, Node root, Node[] first, Node[] second) {
        if(root != null) {
            swap(m, n, root.left, first, second);
            if(root.data == m) {
                first[0] = root;
            } else if(root.data == n) {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null) {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    // better swap than the first one, don't need array any more
    public static Node swap2(Node r, int m, int n, Node tmp) {
        if(r != null){
            Node left = swap2(r.left, m, n, tmp);
            if(left == null){
                if(r.data == m){
                    if(tmp == null)
                        tmp = r;
                    else{
                        r.data = n;
                        tmp.data = m;
                        return r;
                    }
                }else if(r.data == n){
                    if(tmp == null)
                        tmp = r;
                    else{
                        tmp.data = n;
                        r.data = m;
                        return r;
                    }
                }
            }else{
                return left;
            }
            Node right = swap2(r.right, m, n, tmp);
            return right;
        }
        return null;
    }

    
    // new way to swap two nodes
    public static Node swapTwoNodes(Node r, int n1, int n2){
        Node node1 = getNode(r, n1);
        Node node2 = getNode(r, n2); 
        if(node1 != null && node2 != null){
            int tmp = node1.data;
            node1.data = node2.data;
            node2.data = tmp;
        }
        return r;
    } 
    public static Node getNode(Node r, int n1){
        if(r != null){
            if( r.data == n1)
                return r;
            Node p1 = getNode(r.left, n1);
            if(p1 != null)
                return p1;
            Node p2 = getNode(r.right, n1);
            if(p2 != null)
                return p2;
                
        }
        return null;
    } 
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// swap nodes in single linkedlist, swap nodes, switch nodes
// add two dumpy nodes to two ends
public class SwapLinkedListNode{
    public static void main(String[] args) {
//        test0();
//        test1();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }
    public static void test0(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(4);
        sll.append(8);
        sll.print();

        Ut.l();
        sll.addFirst(new Node(0));
        sll.append(9);
        sll.print();

        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(4);
        sll.append(8);
        sll.addFirst(0);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int n = sll.count();
        Print.pbl("c=" + n);
        Ut.l();
        sll.print();

        Aron.end();
    }
    static void test3(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(0);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->3");
        swapTwoNodes(sll.head, c1, c3);
        sll.print();

        Aron.end();
    } 
    static void test4(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(0);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->2");
        swapTwoNodes(sll.head, c1, c2);
        sll.print();

        Aron.end();
    } 
    static void test5(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->2");
        swapTwoNodes(sll.head, c1, c2);
        sll.print();

        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        sll.append(c1);
        sll.append(c2);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->1");
        swapTwoNodes(sll.head, c1, c1);
        sll.print();

        Aron.end();
    } 
    static void test7(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        Node c2 = new Node(2);
        Node c3 = new Node(3);
        sll.append(c1);
        sll.append(c2);
        sll.append(c3);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->1");
        swapTwoNodes(sll.head, c1, c1);
        sll.print();

        Aron.end();
    } 
    static void test8(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node c1 = new Node(1);
        sll.append(c1);
        sll.addFirst(new Node(null));
        sll.append(new Node(null));
        sll.print();
        int num = sll.count();
        Print.pbl("c=" + num);
        sll.print();
        Ut.l();
        Print.pbl("1<->1");
        swapTwoNodes(sll.head, c1, c1);
        sll.print();

        Aron.end();
    } 
    public static void swapTwoNodes(Node head, Node n1, Node n2){
        Node p = null;
        Node n = null;
        Node pp = null;
        Node nn = null;
        Node n1_ = null;
        Node n2_ = null;
        Node prev = null;
        Node curr = head;
        while(curr != null){
            if(curr == n1 || curr == n2){
                    if(n1_ == null){
                        p = prev;
                        n1_ = curr;
                        n = curr.next; 
                    }else if(n2_ == null){
                        pp = prev;
                        n2_ = curr;
                        nn = curr.next;
                    }

                    if(n1_ != null && n2_ != null) {
                        // adjacent nodes
                        if(n == n2_){
                            p.next = n2_;
                            n2_.next = n1_;
                            n1_.next = nn;
                        }else{
                            // non adjacent nodes
                            p.next = n2_;    
                            n2_.next = n;
                            pp.next = n1_;
                            n1_.next = nn;
                        }
                        break;
                    }
            }
            prev = curr;
            curr = curr.next;
        }
    }
} 

public class ThreeBrothers 
{
    public static void main(String[] args)
    {
        //test1();
        Integer[] arr = {1, 2, 2};
        int d=0;
        printTriangle(arr, d);
        Character[] myarr = new Character[10];
        Aron.swap(myarr, 1, 3);
    }
    
    // min(a, MAX) = a
    // mul(a, 1)   = a
    public static void combination(int[] arr, int d, int[] w)
    {
        int min = Integer.MAX_VALUE;
        if(d < 3)
        {
            for(int i=d; i<arr.length; i++)
            {
                w[d] = arr[i];
                combination(arr, d+1, w);
                if(d == 2)
                    System.out.println("["+w[0]+"]["+w[1]+"]["+w[2]+"]");
                /*
                if(d == 2)
                {
                    int mindiff = 2*(Math.max(Math.max(w[0], w[1]), w[2]) - Math.min(Math.min(w[0], w[1]), w[2]));
                    if(mindiff < min)
                    {
                        min = mindiff;
                        System.out.println("["+w[0]+"]["+w[1]+"]["+w[2]+"]");
                        System.out.println();
                    }
                }
                */
            }
        }
    }
    
    
    public static void printTriangle(Integer[] arr, int d)
    {
        if(d == arr.length)
        {
            for(Integer n:arr)
                System.out.print("["+n+"]");
            System.out.println();
        }
        else
        {
            for(int i=d; i<arr.length; i++)
            {
                Aron.swap(arr, i, d);
                printTriangle(arr, d+1);
                Aron.swap(arr, i, d);
            }
        }
    }
    
    public static void test1()
    {
        int[] arr = {1, 2, 4, 5, 6, 8, 9, 11, 14};
        int[] w = new int[3];
        int d = 0;
        combination(arr, d, w);
    }
}
import classfile.Aron;
import classfile.Test;
import java.util.ArrayList;
import java.util.List;


public class TokenizeStr{
    public static void main(String[] args) {
//        test00_tokenize();
//        test0_tokenize();
//
//        test1_tokenize();
//
//        test11_tokenize();
//        test2_tokenize();
//        test22_tokenize();
//        test3_tokenize();
//        test4_tokenize();

        test0_tokenize2();
        test1_tokenize2();
        test2_tokenize2();
        test3_tokenize2();
        test4_tokenize2();
    }
    static void test00_tokenize(){
        Aron.beg();
        String str = "<a>b";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test0_tokenize(){
        Aron.beg();
        String str = "<a>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test11_tokenize(){
        Aron.beg();
        String str = "<b>c</b>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test1_tokenize(){
        Aron.beg();
        String str = "<a>b</a>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test2_tokenize(){
        Aron.beg();
        String str = "<na>da</na>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test22_tokenize(){
        Aron.beg();
        String str = "<name>a</name>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test3_tokenize(){
        Aron.beg();
        String str = "<name>david</name><addr>abc</addr>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test4_tokenize(){
        Aron.beg();
        String str = "<name>david</name>" 
                    +"<addr>abc"
                    +"<phone>cc</phone>"
                    +"<dog>dog</dog>"
                    +"</addr>";
        List<String> list = tokenize(str);
        Aron.printList(list);

        Aron.end();
    }
    public static char lookAhead(String str, int index){
        int i = 1;
        while(str.charAt(index + i) == ' ')
            i++;

        return str.charAt(index + i);
    }

    //[ file=tokenizestr.html title=""
    /**
     * tokenize xml file like format.
     * read character one by one and feed it to state machine.
     * if token is found, add to a list. Otherwise terminate
     * the process and return null.
     * for example, <name>david</name> => [<name>, david, </name>]
     *
     * @param strChar xxx
     *
     * @return list of tokens if all tokens are valid, otherwise return null
     */
    public static List<String> tokenize(String strChar){
        List<String> list = new ArrayList<String>();
        int state = 0;
        int curr = state;
        String str = "";
        boolean isValid = true;
        for(int i=0; i<strChar.length() && isValid; i++){
            if(curr == 0){
                if(str.length() > 0){
                    list.add(str);
                    str = "";
                }

                if(strChar.charAt(i) == '<'){
                    str += strChar.charAt(i);
                    curr = 1;
                }else if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 2;
                    if(i + 1 < strChar.length() && lookAhead(strChar, i) == '<'){
                        curr = 0;
                    }
                }else{
                    isValid = false;
                }
            }else if(curr == 2){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 2;
                    if(i + 1 < strChar.length() && lookAhead(strChar, i) == '<'){
                        curr = 0;
                    }
                }else{
                    isValid = false;
                }
            }else if(curr == 1){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 3;
                }
                else if(strChar.charAt(i) == '/'){
                    str += strChar.charAt(i);
                    curr = 4;
                }else{
                    isValid = false;
                }
            }else if(curr == 3){
                if(strChar.charAt(i) == '>'){
                    str += strChar.charAt(i);
                    curr = 5; // final
                    curr = 0;
                }else if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 3;
                }else{
                    isValid = false;
                }
            }else if(curr == 4){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                    curr = 7;
                }else{
                    isValid = false;
                }

            }else if(curr == 7){
                if('a' <= strChar.charAt(i) && strChar.charAt(i) <= 'z'){
                    str += strChar.charAt(i);
                }else if(strChar.charAt(i) == '>'){
                    str += strChar.charAt(i);
                    curr = 8; // final
                    list.add(str);
                    str = "";
                    curr = 0;
                }else{
                    isValid = false;
                }
            }
        }

        if(curr == 2){
            if(str.length() > 0){
                list.add(str);
                str = "";
            }
        }

        return isValid ? list : null;
    }
    //]

    // gx /Users/cat/myfile/github/math/StateMachine2.png
    public static List<String> tokenize2(String strChar){
        List<String> list = new ArrayList<String>();
        int state = 0;
        int curr = state;
        String str = "";
        boolean isValid = true;
        int len = strChar.length();
        for(int i=0; i<len && isValid; i++){
            char currChar = strChar.charAt(i);
            if(currChar != ' '){
                if(curr == 0){
                    if(currChar == '['){
                        list.add(currChar + "");
                        curr = 1;
                    }
                }else if(curr == 1){
                    if(currChar == '['){
                        list.add(currChar + "");
                    }else if(currChar == ']'){
                        curr = 3;
                        list.add(currChar + "");
                    }else if(Character.isLetterOrDigit(currChar)){
                        curr = 2;
                        str += currChar + "";
                        if(i < len - 1){
                            if(lookAhead(strChar, i) == ']' || lookAhead(strChar, i) == '['){
                                list.add(str);
                                str = "";
                            }
                        }
                    }
                }else if(curr == 2){
                    if(Character.isLetterOrDigit(currChar)){
                        str += currChar + "";
                        if(i < len - 1){
                            if(lookAhead(strChar, i) == ']' || lookAhead(strChar, i) == '['){
                                list.add(str);
                                str = "";
                            }
                        }
                    }else if(currChar == ']'){
                       curr = 3;
                       list.add(currChar + ""); 
                    }else if(currChar == '['){
                        curr = 1;
                        list.add(currChar + "");
                    }
                }else if(curr == 3){
                    if(currChar == ']')
                        list.add(currChar + "");
                    else if(currChar == '['){
                        curr = 1;
                        list.add(currChar + "");
                    }
                }
            }
        }
        return list;
    }
    static void test0_tokenize2(){
        Aron.beg();
        String str = "[ 1 ]";
        List<String> list = tokenize2(str);
        Aron.printList(list, "(" );

        Aron.end();
    }
    static void test1_tokenize2(){
        Aron.beg();
        String str = "[ 1 "
                    +" [ 2 ]"
                    +" [ 3 ]"
                    +" ]";
        List<String> list = tokenize2(str);
        Aron.printList(list, " " );
        Aron.end();
    }
    static void test2_tokenize2(){
        Aron.beg();
        String str = "[ 1 "
                    +" [ 2 ]"
                    +" [ 3 "
                    +"  [ 4 ]"
                    +"  [ 5 ]"
                    +" ]"
                    +"]";
        List<String> list = tokenize2(str);
        Aron.printList(list, "<" );
    }
    static void test3_tokenize2(){
        Aron.beg();
        String str = "[ abc "
                    +" [ 123 ]"
                    +" [ 3 "
                    +"  [ 4 ]"
                    +"  [ 5 ]"
                    +" ]"
                    +" [ 6 ]"
                    +" ]";
        List<String> list = tokenize2(str);
        Aron.printList(list, " " );

        Aron.end();
    }
    static void test4_tokenize2(){
        Aron.beg();
        String str = "[abc"
                    +"[123]"
                    +"[3"
                    +"[4]"
                    +"[5]"
                    +"]"
                    +"[6]"
                    +"]";
        List<String> list = tokenize2(str);
        Aron.printList(list, " " );

        Aron.end();
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TownerHanoi{
    public static void main(String[] args) {
        test1();
    }

    // gf http://www.mathcs.emory.edu/~cheung/Courses/170/Syllabus/13/hanoi.html
    public static String hanoi(int n, int fromPeg, int toPeg) {
        if(n == 1){
            return (fromPeg + "->" + toPeg + "\n");
        }else{
            int helperPeg = 6 - fromPeg - toPeg; 
            String s1 = hanoi(n-1, fromPeg, helperPeg);
            String myStep = fromPeg + "->" + toPeg + "\n";
            String s2 = hanoi(n-1, helperPeg, toPeg);
            return s1 + myStep + s2; 
        }
    }

    static void test1(){
        Aron.beg();
        int n = 3;
        int fromPeg   = 1;
        int helperPeg = 2; 
        int toPeg     = 3;
        String ss        = hanoi(n, fromPeg, toPeg);
        Print.p(ss);

        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

//[ file=inorderiterator.html title=""     
class InorderIterator {
    Node curr;
    Stack<Node> stack = new Stack<Node>();
    public InorderIterator(Node r) {
        this.curr = r;
    }
    public boolean hasNext() {
        if(curr != null || stack.size() > 0)
            return true;
        else
            return false;
    }
    public int next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node.data;
            }
        }
        return -1;
    }
}
//]

class TraversalIteration{

    public static Node prev = null;
    public static void main(String args[]) {
        BST b1 = new BST();
        b1.insert(14);
        b1.insert(15);
        b1.insert(12);
        b1.insert(17);
        b1.insert(19);

        b1.insert(130);
        b1.insert(16);
        b1.insert(10);

        PostOrder(b1.getRoot());
        System.out.println();
        Node cloneRoot = CloneTree(b1.getRoot());

        PostorderDFS(cloneRoot);
        PostorderTwoStacks(cloneRoot);
    }
    //in order traversal using iteration
    public static void InorderIteration(Node r) {
        Stack<Node> st = new Stack<Node>();
        Node curr = r;
        if( curr != null) {
            while(!st.empty() || curr != null) {
                if(curr != null) {
                    st.push(curr);
                    curr = curr.left;
                } else {
                    Node no = st.pop();
                    System.out.println("[" + no.data + "]");
                    curr = no.right;
                }
            }
        }
    }

    
    //[file=postorder1.html title=""
    //postorder recursion
    public static void PostOrder(Node r) {
        if( r != null) {
            PostOrder(r.left);
            PostOrder(r.right);
            System.out.println("[" + r.data + "]");
        }
    }
    //]

    //[ file=postorderite.html title=""
    // postorder with iteration
    public static void postIteration(Node root) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = root;
        while(curr != null || stack.isEmpty() == false) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.peek();
                if(node.isVisited) {
                    System.out.println("[" + node.data + "]");
                    stack.pop();
                } else {
                    node.isVisited = true;
                    curr = node.right;
                }
            }
        }
    }
    //]

    //[ file=twostackite.html title="" 
    //Postorder with two stacks
    public static void PostorderTwoStacks(Node curr) {
        Stack<Node> st1 = new Stack<Node>();
        Stack<Node> st2 = new Stack<Node>();
        if(curr != null) {
            st1.push(curr);
            while(!st1.empty()) {
                Node node = st1.pop();
                st2.push(node);
                if(node.left != null)
                    st1.push(node.left);
                if(node.right != null)
                    st1.push(node.right);
            }
            while(!st2.empty()) {
                Node node = st2.pop();
                System.out.println("[" + node.data + "]");
            }
        }
    }
    //]

    // clone a binary tree
    // Use postorder traversal
    public static Node CloneTree(Node root) {
        if(root != null) {
            Node left = CloneTree(root.left);
            Node right = CloneTree(root.right);
            Node parent = new Node(root.data);
            parent.left = left;
            parent.right = right;
            return parent;
        }
        return null;
    }

    public static void PostorderDFS(Node r) {
        if( r != null) {
            Stack<Node> st= new Stack<Node>();
            Map<Node, List<Node>> map = new HashMap<Node, List<Node>>();
            st.push(r);
            while(!st.empty()) {
                Node top = st.peek();
                if((top.left == null && top.right == null) || top.isVisited) {
                    Node node = st.pop();
                    System.out.println("[" + node.data + "]");

                } else if((top.left != null || top.right != null) && !top.isVisited) {
                    List<Node> list = new LinkedList<Node>();
                    if(!map.containsKey(top)) {
                        if(top.left != null)
                            list.add(top.left);
                        if(top.right != null)
                            list.add(top.right);
                        map.put(top, list);
                    } else {
                        list = map.get(top);
                    }
                    if(list.size() > 0) {
                        Node node = list.get(0);
                        st.push(node);
                        list.remove(0);
                        if(list.size() == 0) {
                            top.isVisited = true;
                            map.remove(top);
                        }
                    }
                }
            }
        }
    }
    //[ file=preinorder.html title=""
    public static void preorder(Node root) {
        if(root != null) {
            System.out.println("[" + root.data + "]");
            inorder(root.left);
            inorder(root.right);
        }
    }
    public static void inorder(Node root) {
        if(root != null) {
            inorder(root.left);
            System.out.println("[" + root.data + "]");
            inorder(root.right);
        }
    }

    public static void preorderIteration(Node r) {
        Stack<Node> st = new Stack<Node>();
        Node curr = r;
        if( curr != null) {
            while(curr != null || !st.empty()) {
                if(curr != null) {
                    System.out.println("["+curr.data+"]");
                    st.push(curr);
                    curr = curr.left;
                } else {
                    Node node = st.pop();
                    curr = node.right;
                }
            }
        }
        curr = r;
    }

    public static void inorderIteration(Node r) {
        Stack<Node> st = new Stack<Node>();
        Node curr = r;
        if( curr != null) {
            while(curr != null || !st.empty()) {
                if(curr != null) {
                    st.push(curr);
                    curr = curr.left;
                } else {
                    Node node = st.pop();
                    System.out.println("["+curr.data+"]");
                    curr = node.right;
                }
            }
        }
        curr = r;
    }
    //]

}
package classfile;
import java.io.*;
import java.lang.String;
import java.util.*;

class TNode {
    boolean isWord;
    TNode[] array = new TNode[26];
}

public class Tries {
    public TNode root;
    public Tries() {
        root = new TNode();
        root.isWord = true;
    }
    public  int map(char ch) {
        return (int)ch - 'a';
    }
    public  void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();
            if(k == arr.length-1)
                r.isWord = true;
            add(r.array[arr[k]], arr, k+1);
        }
    }

    public  boolean contains(TNode r, int[] arr, int h) {
        if(h < arr.length && r.array[arr[h]] != null) {
            if(h + 1 == arr.length && r.isWord)
                return true;
            else
                return contains(r.array[arr[h]], arr, h+1);
        }
        return false;
    }
    public  void addWord(TNode r,  String word, int k) {
        if( k < word.length()) {
            if(r.array[map(word.charAt(k))] == null)
                r.array[map(word.charAt(k))] = new TNode();
            if(k == word.length()-1)
                r.isWord = true;
            addWord(r.array[map(word.charAt(k))], word, k+1);
        }
    }
    public  boolean containsWord(TNode r, String word, int k) {
        if(word.length() == 0)
            return r.isWord;
        if(k < word.length() && r.array[map(word.charAt(k))] != null) {
            if(k + 1 == word.length() && r.isWord)
                return true;
            else
                return containsWord(r.array[map(word.charAt(k))], word, k+1);
        }
        return false;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import classfile.Aron;
import classfile.Print;
import java.util.stream.*;
import java.util.stream.Collectors;

// Tries2.java 
// better version: http://localhost/html/indexTriesDataStructure.html
// another tries data structure again!
// add: count all the longest paths
class TNode{
    boolean isWord;
    String word;
    TNode[] arr = new TNode[26];
    // use Map<String, TNode> map;
    public TNode(){
        isWord = false;
    }
}

public class Tries2{
    public static void main(String[] args) {
//        a | b | c |
//                d | 
//            e f | 
          

        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        TNode r = new TNode();
        String s = "a";
        String s1 = "ab";
        String s2 = "abc";
        String s3 = "abd";
        String s4 = "aef";
        int inx = 0;
        insert(r, s, inx);
        insert(r, s1, inx);
        insert(r, s2, inx);
        insert(r, s3, inx);
        insert(r, s4, inx);
        Print.pb(contains(r, "a", inx) == true);
        Print.pb(contains(r, "ac", inx) == false);
        Print.pb(contains(r, "ab", inx) == true);
        Print.pb(contains(r, "abc", inx) == true);
        int count = countPath(r);
        Print.pb(count);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        TNode r = new TNode();
        String s = "a";
        String s1 = "ab";
        String s2 = "abc";
        String s3 = "abd";
        String s4 = "aef";
        int inx = 0;
        insert(r, s, inx);
        insert(r, s1, inx);
        insert(r, s2, inx);
        insert(r, s3, inx);
        insert(r, s4, inx);

        String input = "ab";
        List<String> list = autoComplete(r, input, inx);
        Print.pb(list);

        Aron.end();
    }
    public static void insert(TNode r, String s, int inx){
        if (inx < s.length()){
            int index = s.charAt(inx) - 'a';
            if(r.arr[index] == null)
                r.arr[index] = new TNode();
            insert(r.arr[index], s, inx + 1);
        }else{
            r.word = s;
            r.isWord = true;
        }
    }
    public static boolean contains(TNode r, String s, int inx){
        if(inx < s.length()){
            int index = s.charAt(inx) - 'a';
            if(r.arr[index] != null){
                return contains(r.arr[index], s, inx+1);
            }else{
                return false;
            }
        }else{
            return r.isWord;
        }
    }
    /*
    Count the number of paths of Tries
    Input Tries
    Return number of paths or number of words in Tries
    Count the number of longest paths in Tries
    */
    public static int countPath(TNode r){
        if(r != null){
            int s = 0;
            int i = 0;
            for(i=0; i<r.arr.length; i++){
                if(r.arr[i] != null){
                    s += countPath(r.arr[i]);
                }
            }
            if (s == 0) // all nodes are null, we hit the bottom
                return 1;
            else
                return s;
        }else{
            return 0;
        }
    }
    public static void getList(TNode r, List<String> list){
        if(r != null){
            int c = 0;
            for(int i=0; i<r.arr.length; i++){
                if(r.arr[i] != null){
                    getList(r.arr[i], list);
                    c++;
                }
            }
            if(c == 0){
                list.add(r.word); 
            }
        }
    }
    public static List<String> autoComplete(TNode r, String s, int inx){
        if (inx < s.length()){
            int index = s.charAt(inx) - 'a';
            if(r.arr[index] != null){
                return autoComplete(r.arr[index], s, inx + 1);
            }else{
                return new ArrayList<String>();
            }
        }else{
            List<String> list = new ArrayList<String>();
            getList(r, list);
            return list;
        }
    }
} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// gx http://www.geeksforgeeks.org/find-pair-rows-binary-matrix-maximum-bit-difference/
// count the maximum different bits in binary matrix
class TNode{
    public TNode[] arr = new TNode[2];
    public boolean isWord = false;
    public TNode(boolean isWord){
        this.isWord = isWord;
    }
    public TNode(){
    }
}

public class TriesBinary{
    public static void main(String[] args) {
//        test0();
//        test1();
        test2();
    }
    public static void insert(TNode node, String s, int index){
        if(index < s.length()){
            int inx = s.charAt(index) - '0';
            if(node.arr[inx] == null)
                node.arr[inx] = new TNode(false);
            insert(node.arr[inx], s, index+1);
        }else{
            node.isWord = true;
        }
    }
    public static boolean contains(TNode root, String s, int index){
        if(s != null){
            if(index < s.length()){
                int n = s.charAt(index) - '0';    
                if(root.arr[n] == null)
                    return false;
                else
                    return contains(root.arr[n], s, index+1);
            }else{
                return root.isWord;
            }
        }
        return false;
    }
    
    public static void print(TNode node){
        if(node != null){
            if(node.arr[0] != null){
                Print.pp(0);
                print(node.arr[0]);
                Print.pp("\n");
            }
            if(node.arr[1] != null){
                Print.pp(1);
                print(node.arr[1]);
                Print.pp("\n");
            }
        }
    }
   
    public static int countDiff(TNode node){
        if(node != null){
            if(node.arr[0] != null && node.arr[1] != null){
                int l = countDiff(node.arr[0]);
                int r = countDiff(node.arr[1]);
                return l + r + 1;
            }
        }
        return 0;
    }
    public static void test0(){
        Aron.beg();

        String s1 = "011";
        String s2 = "111";
        String s3 = "010";
        TNode root = new TNode(true);
        int index = 0;
        insert(root, s1, index);
        insert(root, s2, index);
        insert(root, s3, index);
        print(root);
        Aron.end();
    }

    public static void test1(){
        Aron.beg();
        String[] array = {
            "011",
            "111",
            "010",
            "000",
        };
        String s1 = "011";
        String s2 = "111";
        String s3 = "010";
        TNode root = new TNode();
        int index = 0;

        for(int i=1; i<array.length; i++){
            insert(root, array[i], index);
        }

        int num = countDiff(root);
        Print.pp("num=" + num);

        Aron.end();
    }

    static void test2(){
        Aron.beg();

        String[] array = {
            "011",
            "111",
            "010",
        };
        TNode root = new TNode();
        int index = 0;

        for(int i=1; i<array.length; i++){
            insert(root, array[i], index);
        }
        
        boolean b = contains(root, "111", index);
        Test.t(b == true);
        b = contains(root, "000", index);
        Test.t(b == false);

        Aron.end();
    } 
} 

import java.util.*;
import java.io.*;
import classfile.*;

// Tries with HashMap
class XNode {
    public Map<Character, XNode> map = new HashMap<Character, XNode>();
    public boolean isWord = false;
    public String word;
    public XNode(boolean isWord) {
        this.isWord = isWord;
    }
}

public class TriesMap{
    public static void main(String[] args) {
        test0_insert();
        test1_insert();
        test2_insert();
        test3_insert();
        test4_insert();
        test4_autocomplete();
        test5_autocomplete();
        test5_autocompleteList();
        test6_autocompleteList();
        test7_autocompleteList();
        test8_autocompleteList();
        test9_autocompleteList();
    }

    
    //[ file=triesmap.html title=""
    /**
    * insert str to Tries from the root, if str doesn't exist in Tries
    * set isWord to be true, and assign str to word
    * if str does exist in the tries, do nothing
    *
    * @param root   the root node of Tries, it can't be null
    * @param str    the String is being inserted
    * @param index  index of str, initial value is zero
    *
    * return void
    */
    public static void insert(XNode root, String str, int index) {
        if(index == str.length()) {
            root.isWord = true;
            root.word = str;
        } else {
            char ch = str.charAt(index);
            XNode node = root.map.get(ch);
            if(node == null) {
                node = new XNode(false);
                root.map.put(ch, node);
            }
            insert(node, str, index+1);
        }
    }

    /**
    * check if the str exist in the Tries,
    *
    * @param root the root of Tries
    * @param str  the String to be checked
    * @param index index of str
    *
    * @return true if str exists in the Tries, false otherwise
    */
    public static boolean contains(XNode root, String str, int index) {
        if(index == str.length()) {
            return root.isWord;
        } else {
            if(root.map.containsKey(str.charAt(index))) {
                return contains(root.map.get(str.charAt(index)), str, index + 1);
            } else {
                return false;
            }
        }
    }

    public static XNode autocomplete(XNode root, String partialWord, int index) {
        if(index == partialWord.length()) {
            return root;
        }else {
            XNode node = root.map.get(partialWord.charAt(index));
            if(node != null) {
                return autocomplete(node, partialWord, index + 1);
            }
            return null;
        }
    }
    public static void autocompleteList(XNode node, String partialWord, int index, List<String> list) {
        if(node.isWord)
            list.add(node.word);
        else{
            for(Map.Entry<Character, XNode> entry : node.map.entrySet()){
                if(entry.getValue().isWord)
                    list.add(entry.getValue().word);
                else
                    autocompleteList(entry.getValue(), partialWord, index+1, list);
            } 
        }
    }
    //]

    public static void print(XNode root) {
        if(root != null) {
            if(root.isWord)
                Print.pb(root.word);

            for(Map.Entry<Character, XNode> entry : root.map.entrySet()) {
                print(entry.getValue());
            }
        }
    }

    static void test0_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, str, index);
        Test.t(contains(root, str, index));
        Aron.end();
    }
    static void test1_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "ab", index);
        Test.f(contains(root, str, index));
        Aron.end();
    }
    static void test2_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "a", index);
        insert(root, "ab", index);
        insert(root, "abc", index);
        insert(root, "abcd", index);

        Test.t(contains(root, "", index));
        Test.t(contains(root, "a", index));
        Test.t(contains(root, "ab", index));
        Test.t(contains(root, "abcd", index));
        Test.t(contains(root, "abc", index));

        Test.f(contains(root, "abb", index));
        Test.f(contains(root, "abcc", index));
        Aron.end();
    }
    static void test3_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "abcd", index);

        Test.t(contains(root, "", index));
        Test.f(contains(root, "a", index));
        Test.f(contains(root, "ab", index));
        Test.t(contains(root, "abcd", index));
        Test.f(contains(root, "abc", index));

        Aron.end();
    }
    static void test4_insert() {
        Aron.beg();
        XNode root = new XNode(true);
        String str = "a";
        int index = 0;
        insert(root, "abcd", index);
        insert(root, "a", index);
        insert(root, "abc", index);
        print(root);

        Aron.end();
    }
    static void test4_autocomplete() {
        Aron.beg();

        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        
        String str = "cat";
        XNode node = autocomplete(root, str, index);
        Test.t(node.isWord == true);
        Test.t(node.word.equals(str));

        Aron.end();
    }
    static void test5_autocomplete() {
        Aron.beg();

        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        
        String str = "ca";
        XNode node = autocomplete(root, str, index);
        Test.t(node.isWord == false);

        Aron.end();
    }
    static void test5_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "qua";
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Print.pbl(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test6_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "q";
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Print.pbl(str);
        Aron.printList(list);

        Aron.end();
    }
    static void test7_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "c";
        Print.pbl(str);
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Aron.printList(list);

        Aron.end();
    }
    static void test8_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        insert(root, "quality", index);
        insert(root, "qualify", index);
        insert(root, "quart", index);
        insert(root, "quarter", index);
        insert(root, "quantify", index);
        insert(root, "quantifying", index);
        insert(root, "quantified", index);
        insert(root, "quantifies", index);
        insert(root, "quant", index);
        insert(root, "quantitative", index);
        insert(root, "quadratic", index);
        insert(root, "satellite", index);
        insert(root, "beijing", index);
        insert(root, "vienna", index);
        
        String str = "";
        Print.pbl(str);
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Aron.printList(list);

        Aron.end();
    }
    static void test9_autocompleteList() {
        Aron.beg();
        XNode root = new XNode(true);
        int index = 0;
        insert(root, "", index);
        insert(root, "cat", index);
        insert(root, "quantum", index);
        
        String str = "cat";
        Print.pbl(str);
        XNode node = autocomplete(root, str, index);

        List<String> list = new ArrayList<String>(); 
        autocompleteList(node, str, index, list);
        Aron.printList(list);

        Aron.end();
    }
}

import java.lang.Character;
public class Trim 
{
    public static void main(String[] args)
    {
        String str = "   hello world  ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = "";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = "a";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = " ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = " a";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = "a ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = " a ";
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");

        str = null;
        System.out.println("["+str+"]");
        System.out.println("["+trim(str)+"]");


    }
    public static String trim(String str)
    {
        String ret = null;
        if(str != null)
        {
            ret = "";
            int i = 0;
            while(str.length() > 0 && str.length() > i && Character.isSpace(str.charAt(i)))
            {
                            i++;
            }
            int l = str.length();

            while(l > 0 && Character.isSpace(str.charAt(l-1)))
            {
                            l--;
            }
            for(int k = i; k < l; k++)
            {
                            ret = ret + str.charAt(k);
            }
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;


public class Try444{
    public static void main(String[] args) {
        test0();
    }
    public static void test0(){
        Aron.beg();
        
        long[] arr = {1, 2, 3, 4, 5};
        int width = arr.length; 

        long[][] list = XList.partition(arr, 2);
        Aron.printArray2D(list);

        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryChar{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        char currChar = '1';
        if(Character.isLetterOrDigit(currChar)){
            Print.pbl(currChar);
        }
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryCoin{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        List<Integer> coinList = new ArrayList<>(Arrays.asList(1, 2, 3));
        
        List<Integer> list = new ArrayList<>();
        int s = 10;
        coinChange(coinList, s, list);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    // given a list of coins and an Integer, find the number of combinations of coins are added up the s
    // assume s > 0 and all face value of coins are greater than zero
    public static void coinChange(List<Integer> coinList, Integer s, List<Integer> list){
        if(s == 0)
            Aron.printList(list);    
        else if (s > 0){
            for(Integer n : coinList){
                list.add(n);
                coinChange(coinList, s-n, list); 
                list.remove(list.size()-1);
            }
        }
    }
} 

import java.lang.reflect.InvocationTargetException;
 
import org.codehaus.commons.compiler.CompileException;
import org.codehaus.janino.ExpressionEvaluator;
 
public class TryCompiler{
 
    public static void
    main(String[] args) throws CompileException, InvocationTargetException {
 
        // Now here's where the story begins...
        ExpressionEvaluator ee = new ExpressionEvaluator();
 
        // The expression will have two "int" parameters: "a" and "b".
        ee.setParameters(new String[] { "a", "b" }, new Class[] { int.class, int.class });
 
        // And the expression (i.e. "result") type is also "int".
        ee.setExpressionType(int.class);
 
        // And now we "cook" (scan, parse, compile and load) the fabulous expression.
        ee.cook("a + b");
 
        // Eventually we evaluate the expression - and that goes super-fast.
        int result = (Integer) ee.evaluate(new Object[] { 19, 23 });
        System.out.println(result);
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryCopyList{
    public static void main(String[] args) {
        test0();
        test1();
    }

    public static void test0(){
        Aron.beg();
        List<Integer> list = new ArrayList<>(Arrays.asList(1, 2, 3)); 
        List<Integer> ll = list.stream().collect(Collectors.toList()); 
        Aron.printList(ll);
        

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void copyList(){
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryCreateTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Node r = createGeneralTree();
        print(r);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void print(Node r){ 
        Print.p(r.data);
        for(Node n : r.list)
            print(n);
    }

    public static Node createGeneralTree(){
        Node r = new Node(1); 
        Node n1 = new Node(2);
        Node n2 = new Node(3);
        Node n3 = new Node(4);

        Node nn1 = new Node(11);
        Node nn2 = new Node(12);
        Node nn3 = new Node(13);

        Node nn4 = new Node(14);
        Node nn5 = new Node(15);

        n1.list.add(nn1);
        n1.list.add(nn2);
        n1.list.add(nn3);

        n2.list.add(nn4);
        n2.list.add(nn5);

        r.list.add(n1);
        r.list.add(n2);
        r.list.add(n3);
        return r;
    }

} 

import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.stream.*;
import java.util.*;
import java.io.*;
import classfile.*;

// *j_json* *json* *json_array* *json seri *
class Item implements Serializable {
    @SerializedName("_OrderDetails")
    private OrderDetails[] mOrderDetails;

    @SerializedName("Id")
    private String mId;
    public String getId(){
        return mId;
    }

    public OrderDetails[] getMOrderDetails(){ 
        return mOrderDetails;
    }

    @SerializedName("OrderData")
    private String mOrderDate;

    @SerializedName("Number")
    private String mNumber;

    @SerializedName("CustomerName")
    private String mCustomerName;

    @SerializedName("Note")
    private String mNote;

    // Add setters and getters

    public static class OrderDetails implements Serializable {
        @SerializedName("ProductName")
        private String mProductName;
        String getMProductName(){
            return mProductName;
        }

        @SerializedName("TotalAfterDiscount_Lc")
        private String mTotalAfterDiscount;

        @SerializedName("MeasureUnitName")
        private String mMeasureUnitName;

        @SerializedName("TotalPrice_Lc")
        private String mTotalPrice;

        @SerializedName("PricePerUnit_Lc")
        private String mPricePerUnit;

        @SerializedName("Quantity")
        private String mQuantity;

        // Add setters and getters
    }
}

public class TryJsonArray {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String responseJSON = "[\n" +
                              "  {\n" +
                              "    \"_OrderDetails\": [\n" +
                              "      {\n" +
                              "         \"ProductName\": \"FUCHS SUPER GT SAE 10W30 6X5 / FP10100010102\",\n" +
                              "        \"TotalAfterDiscount_Lc\": \"7500\",\n" +
                              "        \"MeasureUnitName\": \"كرتونة\",\n" +
                              "        \"TotalPrice_Lc\": \"7500\",\n" +
                              "        \"PricePerUnit_Lc\": \"75\",\n" +
                              "        \"Quantity\": \"100\"\n" +
                              "      }\n" +
                              "    ],\n" +
                              "    \"Id\": \"274\",\n" +
                              "    \"OrderDate\": \"4/10/2014 12:00:00 AM\",\n" +
                              "    \"Number\": \"16\",\n" +
                              "    \"CustomerName\": \"الأسد\",\n" +
                              "    \"Note\": \"\"\n" +
                              "  }\n" +
                              "]";

        Item[] placelist;
        Gson gson = new Gson();
        placelist = gson.fromJson(responseJSON, Item[].class);
        System.out.println(Arrays.toString(placelist));
        for(Item m : placelist){
            Print.pbl(m.getId());
            for(Item.OrderDetails order : m.getMOrderDetails()){
                Print.pbl(order.getMProductName());
            }
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}


import java.util.*;
import java.io.*;
import classfile.*;

public class TryLevel{
    public static void main(String[] args) {
//        test0();
        test1();
        test2();
    }
    public static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        //Aron.binImage(b1.root);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(9);
        int level = 1;

        
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        level(b1.root, map, level);
        int sum = 0;
        for(int k=0; k<=map.size(); k++){
            int m = (int)Math.pow(2, k);
            for(int i=1; i<=m; i++){
                int index = sum + i;
                Integer value = map.get(index);
                if(value != null)
                    Print.pbl("k=" + k + "  s=" + (sum + i) + " v=" + value);
                
            }
            sum += m;
            Aron.line();
        } 

        int index = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, index, isLeaf);
//        Aron.binImage(b1.root);
        
        Aron.end();
    }
    
    static void test2(){
        Aron.beg();
        int level = 1;
        Aron.line();
        BST b1 = Aron.createBin();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        level(b1.root, map, level);

        int index = 1;
        boolean isLeaf = true;
        Node root = buildTree(map, index);
        Aron.prettyPrint(root, index, isLeaf);


        Aron.end();
    } 

    
    public static Node buildTree(Map<Integer, Integer> map, int index){
        Node r = null;
        Integer n = map.get(index);
        if(n != null){
            r = new Node(n);
            r.left = buildTree(map, 2*index);
            r.right = buildTree(map, 2*index+1);
        }
        return r;
    }

    public static void printLevel(){
        int level = 1;
        Aron.line();
        BST b1 = Aron.createBin();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        level(b1.root, map, level);
        int sum = 0;
        int num = 0;
        int k = 0;
        while(num < map.size()){
            int m = (int)Math.pow(2, k);
            for(int i=1; i<=m; i++){
                int index = sum + i;
                Integer value = map.get(index);
                if(num < map.size() && value != null){
                    Print.pb("k=" + k + "  s=" + (sum + i) + " v=" + value);
                    num++;
                }
                
            }
            sum += m;
            k++;
            Aron.line();
        } 
//
//        int index = 0;
//        boolean isLeaf = true;
//        Aron.prettyPrint(b1.root, index, isLeaf);
    }
    public static void level(Node r, Map<Integer, Integer> map, int level){
        if(r != null){
            Print.pbl(level + "=>" + r.data);
            map.put(level, r.data);
            level(r.left, map, 2*level);
            level(r.right, map, 2*level + 1);
        }
    } 
} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryMM{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        //String s = "kabcabckFABCFdd";
        String s = "name#778-338-4145dd";

        //Pattern pattern = Pattern.compile("k([a-c]+)|(F([A-C]+)F)");
        //Pattern pattern = Pattern.compile("(k([a-c]+)|([A-C]+))");
        Pattern pattern = Pattern.compile("(\\w+)|#([0-9-]+)");
        Matcher matcher = pattern.matcher(s);
        while(matcher.find()) {
            Print.pbl("groupCount=" + matcher.groupCount());
            Ut.l();
            int gc = matcher.groupCount();
            for(int i=1; i<=gc; i++){
                if(matcher.group(i) != null)
                    Print.pb(matcher.group(i));
            } 
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String s = "dog\r\ncat";
        String str = s.replace("\r\n", "-");
        Print.pbl("str=" + str);
        Aron.end();
    } 
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryMin2{
    public static void main(String[] args) {
        test0();
        String str = "test it";
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.time.LocalDateTime;
import java.time.Duration;

interface ICar{
    public double getPrice();
}

class SmallCar implements ICar {
    String name;
    public SmallCar(String name) {
        this.name = name;
    }
    public double getSize() {
        return 114;
    }
}

class MiddleCar implements ICar {
    String name;
    public MiddleCar(String name) {
        this.name = name;
    }
    public double getSize() {
        return 314;
    }
}

class Ticket {
    double price;
    String id;
    LocalDateTime start;
    LocalDateTime end;
    public Ticket(String id, double price) {
        this.id = id;
        this.price = price;
        this.start = LocalDateTime.now();
    }
    public LocalDateTime diff() {
        return LocalDateTime.now();
    }
}

class ParkingSpace {
    Ticket ticket;
    ICar car;
    public ParkingSpace(Ticket ticket, ICar car) {
        this.ticket = ticket;
        this.car = car;
    }
}

class ParkSystem {
    Map<String, ParkingSpace> map = new HashMap<>();
    public ParkSystem(int max) {
    }
    public void add(ParkingSpace parkingSpace) {
        map.put(parkingSpace.ticket.id, parkingSpace);
    }
    public void remove(parkingSpace parkingSpace) {
        map.remove(ParkingSpace.ticket.id);
    }
}


public class TryPark {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();

        ParkSystem ps = new ParkSystem(10);
        Ticket t1 = new Ticket("1", LocalDateTime.now());
        Ticket t2 = new Ticket("2", LocalDateTime.now());
        Ticket t3 = new Ticket("3", LocalDateTime.now());

        ps.add(t1, new ParkingSpace(t1, new SmallCar("2323", 345.3)));

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        LocalDateTime from = LocalDateTime.now();
        LocalDateTime to = LocalDateTime.now();
        Duration duration = Duration.between(from, to);
        Print.pbl(duration.toString());
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryParseXML{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String str = "/Users/cat/myfile/github/java/text/filex.txt";

        validate(str);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
    public static boolean validate(String fname){
        try{
            BufferedReader br = new BufferedReader(new FileReader(fname));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pbl(line);
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
        return true;
    }

    public static void buildTree(Iterator<String> ite){
        if (ite.hasNext()){

            Pattern r = Pattern.compile("\\d+", Pattern.CASE_INSENSITIVE);
            Matcher mat = r.matcher("CAPTHEOREM");
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
     
            if(ite.next().equals("[")){
                    
            }
        }else{

        }
        
        
        
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryPath{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 1, 0, 0},
            {0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        List<Integer> list = new ArrayList<Integer>(); 
        int n1=0, n2=5;
        list.add(n1);
        allpath(arr2d, n1, n2, list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        int[][] arr2d = {
            {0, 1, 1, 1, 0, 0},
            {0, 0, 1, 0, 0, 1},
            {0, 0, 0, 1, 0, 0},
            {0, 0, 0, 0, 1, 1},
            {0, 0, 0, 0, 0, 1},
            {0, 0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);

        int height = arr2d.length;
        int width = arr2d[0].length; 
        List<Integer> list = new ArrayList<Integer>(); 
        List<Integer> mlist = new ArrayList<Integer>(); 
        int n1=0, n2=5;
        list.add(n1);
        shortest(arr2d, n1, n2, list, mlist);
        Aron.printList(mlist);

        Aron.end();
    }
    public static void allpath(int[][] arr2d, int n1, int n2, List<Integer> list){
        int height = arr2d.length;
        int width = arr2d[0].length;
        if(n1 < height){
            if(n1 != n2){
                for(int i=0; i<width; i++){
                    if(arr2d[n1][i] == 1){
                        list.add(i);
                        allpath(arr2d, i, n2, list);
                        list.remove(list.size()-1);
                    }
                } 
            }else{
                Aron.printList(list);
            }
        }
    }

    public static void shortest(int[][] arr2d, int n1, int n2, List<Integer> list, List<Integer> mlist){
        int height = arr2d.length;
        int width = arr2d[0].length;
        if(n1 < height){
            if(n1 != n2){
                for(int i=0; i<width; i++){
                    if(arr2d[n1][i] == 1){
                        list.add(i);
                        shortest(arr2d, i, n2, list, mlist);
                        list.remove(list.size()-1);
                    }
                } 
            }else{
                if(mlist.size() == 0)
                    mlist = list.stream().collect(Collectors.toList());
                else{
                    if(list.size() < mlist.size()){
                        mlist = list.stream().collect(Collectors.toList());
                        Aron.printList(mlist);
                    }
                }
            }
        }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryPostOrder{
    public static void main(String[] args) {
        //test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        BST b = Aron.createBin();
        postorder(b.root);
        
        Aron.end();
    }
    
    static void test1(){
        Aron.beg();
        BST b = Aron.createBin();
        printSequence(b.root);

        Aron.end();
    }
    
    public static void postorder(Node r){
        Stack<Node> s1 = new Stack<>();
        Stack<Node> s2 = new Stack<>();
        if(r != null){
            s1.push(r);
            while(!s1.empty()){
                Node n = s1.pop();
                if(n.left != null)
                    s1.push(n.left);
                if(n.right != null)
                    s1.push(n.right);
                s2.push(n);
            }
            while(!s2.empty())
                Print.pbl(s2.pop().data);
        }
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    }

    public static void printSequence(Node r){
       Stack<Node> s1 = new Stack<>();  
       Stack<Node> s2 = new Stack<>();  
       if(r != null){ 
           s1.push(r);
           while(!s1.empty() || !s2.empty()){
               while(!s1.empty()){
                   Node n = s1.pop();
                   Print.p(n.data);

                   if(n.left != null)
                       s2.push(n.left);
                   if(n.right != null)
                       s2.push(n.right);
               }

               while(!s2.empty()){
                   Node n = s2.pop();
                   Print.p(n.data);
                   if(n.right != null)
                       s1.push(n.right);
                   if(n.left != null)
                       s1.push(n.left);
               }
           }
           
       }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryPrime{
    public static void main(String[] args) {
        test00();
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        List<Integer> list = prime(10); 
        Aron.printList(list);
        Aron.end();
    }
    public static void test00(){
        Aron.beg();
        List<Integer> list = prime(2); 
        Aron.printList(list);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        List<Integer> list = nprime(10); 
        Aron.printList(list);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        List<Integer> list = nprime(1); 
        Aron.printList(list);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        List<Integer> list = nprime(2); 
        Aron.printList(list);

        Aron.end();
    }
    public static List<Integer> nprime(int n){
        List<Integer> list = new ArrayList<>();

        if(n >= 1){
            list.add(2);
            int k = 1;
            int i = 3;
            while(k < n){
                boolean isPrime = true;
                for(Integer p : list){
                    if( i % p == 0){
                        isPrime = false;
                        break;
                    }
                }
                if(isPrime){
                    list.add(i);
                    k++;
                }
                i++;
            } 
            
        }
        return list;
    }
    public static List<Integer> prime(int n){
        List<Integer> list = new ArrayList<>();

        if(n >= 2){
            list.add(2);
            for(int i=3; i<=n; i++){
                boolean isPrime = true;
                for(Integer p : list){
                    if( i % p == 0){
                        isPrime = false;
                        break;
                    }
                }
                if(isPrime)
                    list.add(i);
            } 
            
        }
        return list;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class TryRArr{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        Aron.printArray2D(arr2d);
        Aron.line();

        rotate(arr2d);
        Aron.printArray2D(arr2d);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 
        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3,  4},
            { 5,   6,   7,  8},
            { 9,   10,  11, 12},
            { 13,  14,  15, 16},
            { 17,  18,  19, 20},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3},
            { 4,   5,   6},
            { 7,   8,  9},
            { 10,  11,  12},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   2,   3},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        int[][] arr2d = {
            {1},
            {2},
            {3},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        int[][] arr2d = {
            {1, 2},
            {3, 4},
            {5, 6},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        int[][] arr2d = {
            {1},
        };
        int height = arr2d.length;
        int width = arr2d[0].length; 

        spiral(arr2d);
        Aron.printArray2D(arr2d);

        Aron.end();
    }

    public static void rotate(int[][] array){
        int len = array.length;
        for(int k=0; k<len/2; k++){
            for(int i=k; i<len-1-k; i++){
                int tmp = array[k][i];
                array[k][i] = array[len-1-i][k];
                array[len-1-i][k] = array[len-1-k][len-1-i];
                array[len-1-k][len-1-i] = array[i][len-1-k];
                array[i][len-1-k] = tmp;
            }
        }
    }

    // /Users/cat/myfile/github/java/TryRArr.java
    public static void spiral(int[][] arr){
        int height = arr.length;
        int width= arr[0].length;
        int min = Math.min(width, height);
        int k = 0;
        while(k < width){
            // [2, 1]
            // horizonal 
            if(height - 2*k == 1){
                for(int i=k; i<width-k; i++)
                    Print.p(arr[k][i]); // horizontal

                break;
            }
            else if(width - 2*k == 1){
                for(int i=k; i<height-k; i++)
                    Print.p(arr[i][k]); // vertical 

                break;
            }
            else{
                for(int i=k; i<width-1-k; i++)
                    Print.p(arr[k][i]);
                for(int i=k; i<height-1-k; i++)
                    Print.p(arr[i][width-1-k]);
                for(int i=k; i<width-1-k; i++)
                    Print.p(arr[height-1-k][width-1-i]);
                for(int i=k; i<height-1-k; i++)
                    Print.p(arr[height-1-i][k]);
            }
            k++;
        }
    }

} 

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TrySerialize{
    public static void main(String[] args) {
        test0();
    }
    public static void test0(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        List<String> list = new ArrayList<String>(); 
        inorder(b1.root, list);
        Aron.printList(list);


        Iterator<String> ite = list.iterator(); 
        Node root = serialize(ite);

        level = 0;
        isLeaf = true;
        Aron.prettyPrint(root, level, isLeaf);
        Aron.binImage(root); 

    }
    public static void inorder(Node r, List<String> list){
        if(r != null){
            list.add(r.data + "");
            inorder(r.left, list);
            inorder(r.right, list);
        }else{
            list.add("#");
        }
    }
    
    public static Node serialize(Iterator<String> ite){
        if(ite.hasNext()){
            String s = ite.next();
            if(!s.equals("#")){
                Node parent = new Node(s);
                parent.left = serialize(ite); 
                parent.right = serialize(ite);
                return parent;
            }
        }
        return null;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryTime{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        XTime.start();
        for(int i=0; i<1000000; i++)
            Print.pbl(i);
            
        XTime.stop();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class TryTry0{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        int[][] arr = {{}};
        int len = arr.length;
        int wlen = arr[0].length;
        Print.p(len);
        Print.p(wlen);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        int[][] array = new int[0][0];
        int alen = array.length;
        int walen = array[0].length;
        Print.p("alen=" + alen);
        Print.p("walen=" + walen);

        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

// gx http://stackoverflow.com/questions/31986332/visitor-vs-servant-vs-command-patterns 
interface IMobile{
}

class IPhone implements IMobile{
    String name;
    public IPhone(String name){
        this.name = name;
    }
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

class Android implements IMobile{
    String name;
    public Android(String name){
        this.name = name;
    }
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

interface IBluetooth{
    public void switchOn(IPhone iphone);
    public void switchOn(Android android);
}

class VisitorBlueTooth implements IBluetooth{
    public void switchOn(IPhone iphone){
        Print.pbl(iphone.name);
    }
    public void switchOn(Android android){
        Print.pbl(android.name);
    }
}

public class TryVisitorPattern{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();

        IPhone iphone = new IPhone("iPhone");
        Android android = new Android("android");
        VisitorBlueTooth visitor = new VisitorBlueTooth();
        visitor.switchOn(iphone);
        visitor.switchOn(android);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class Tryee{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
import java.nio.file.DirectoryStream;
import java.nio.file.Files;
import java.nio.file.Path;
//
import classfile.*; 

public class Tryhh{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        
        String fname = "/Users/cat/myfile/github/java";
        List<String> list = Aron.getCurrentDir(fname);
        Aron.printList(list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String fname = "/Users/cat/myfile/github/java";
        List<String> list = fileList(fname);
        Aron.printList(list);

        Aron.end();
    }

    // get all files from current directory
    // return a list of absoluate paths
    // getcurrent file, 
    public static List<String> getCurrentFiles(String directoryName) {
        List<String> list = new ArrayList<String>(); 
        File directory = new File(directoryName);
        File[] fList = directory.listFiles();
        for (File file : fList) {
            if (file.isFile()) {
                list.add(file.getAbsolutePath());
            } 
        }
        return list;
    }

    public static List<String> fileList(String directory) {
        List<String> fileNames = new ArrayList<>();
        try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(Paths.get(directory))) {
            for (Path path : directoryStream) {
                fileNames.add(path.toString());
            }
        } catch (IOException ex) {}
        return fileNames;
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class TwoIntSum
{
	public static void main(String args[])
	{
		int[] Arr={1, 2, 3, 3, 3, 3, 1, 5, 2, 4};
		TwoIntSum(Arr, 6);
	}
	//list has repeating numbers
	public static void TwoIntSum(int[] Arr, int sum)
	{
		if(Arr != null)
		{
			Map<Integer, Integer> map = new HashMap<Integer, Integer>();
			int len = Arr.length;
			int[] diffArr = new int[len];

			for(int i=0; i<len; i++)
			{ diffArr[i] = sum - Arr[i]; 
				if(map.containsKey(new Integer(Arr[i])))
				{ int val = map.get(new Integer(Arr[i])).intValue();
					val++;
					map.put(new Integer(Arr[i]), new Integer(val));
				}
				else
					map.put(new Integer(Arr[i]), new Integer(1)); 
			}

			for(int i=0; i<len; i++)
			{ if(map.containsKey(new Integer(diffArr[i])))
				{ int val = map.get(new Integer(diffArr[i])).intValue();
					if(val>0)
					{ val--;
						map.put(new Integer(diffArr[i]), val);

						int pair = sum - diffArr[i];	
						if(map.containsKey(new Integer(pair)))
						{
							int pval = map.get(new Integer(pair)).intValue();
							if(pval > 0)
							{
								pval--;
								map.put(new Integer(pair), pval);
								System.out.println("["+i+"]="+diffArr[i]);
								System.out.println("pair="+pair);
							}
						}
					}
				}
			}
		}	 //end if
	}//end TwoIntSum()
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.stream.Collectors;

/*
-------------------------------------------------------------------------------- 
Tue Nov 20 10:57:59 2018 
Java typing, java type, about typing, about type 
<? extends Number> <? super Number>
-------------------------------------------------------------------------------- 
*/
public class TypeExample{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
    // gx https://docs.oracle.com/javase/tutorial/java/generics/subtyping.html
        Aron.beg();
        // it does work
//        List<Number> listNum = new ArrayList<>();
//        List<Integer> listInt = new ArrayList<>();
//        listNum = listInt;

        // it works
        List<? extends Number> listNum = new ArrayList<>();
        List<? extends Integer> listInt = new ArrayList<>();
        listNum = listInt;

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        List<Number> listNum = new ArrayList<>();
        List<Integer> listInt = new ArrayList<>();
        listNum = listInt;
        Aron.end();
    }
} 

import java.util.*;

class Pair{
    public String name;
    public Pair(String name){
        this.name = name;
    }
}

class PairCompare implements Comparator<Pair>{
    public int compare(Pair p1, Pair p2){
        return p1.name.compareToIgnoreCase(p2.name); 
    }
}

public class UniquePair{
    public static void main(String[] args){
        List<Pair> list = new ArrayList<Pair>();
        list.add(new Pair("dog"));
        list.add(new Pair("god"));
        list.add(new Pair("abc"));

        Collections.sort(list, new PairCompare());

        for(Pair p : list){
            System.out.println("[" + p.name + "]");
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Item{
    String name;
    double price;
}
                     
class VendorMachine {
    Map<String, List<Item>> map = new Hashmap<String, List<Item>>();
    double total;
    public VendorMachine(){
    }

    public Item buy(double cash, String key){
        List<Item> list = map.get(key);
        if(list != null){
            if(cash > list[list.size()-1].price){
                Item item = list.remove();
                if(list.isEmpty())
                    map.remove(key);
            }
        }
        return item;
    }
    public double change(double cash, Item item){
        if(item != null){
            return cash - item.price;
        }
        return 0;
    }
}


public class Hello
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test99();
    }
    public static void test99() {
        Queue<String> q1 = new LinkedList<String>();
        Queue<String> q2 = new LinkedList<String>();
        q1 = q2;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;

// gf http://stackoverflow.com/questions/31986332/visitor-vs-servant-vs-command-patterns
interface IMobile{
}

class IPhone implements IMobile{
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

class Android implements IMobile{
    public void turnOn(IBluetooth b){
        b.switchOn(this);
    }
}

interface IBluetooth{
    public void switchOn(IPhone iphone);
    public void switchOn(Android android);
}

class VisitorBlueTooth implements IBluetooth{
    public void switchOn(IPhone iphone){
    }
    public void switchOn(Android android){
    }
}

public class VisitorPattern{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Ellipse2D;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Random;

import javax.imageio.ImageIO;
import javax.swing.JFrame;

public class VoronoiDiagram extends JFrame {
    static double p = 3;
    static BufferedImage I;
    static int px[], py[], color[], cells = 100, size = 1000;

    public VoronoiDiagram() {
        super("VoronoiDiagram Diagram");
        setBounds(0, 0, size, size);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
        int n = 0;
        Random rand = new Random();
        I = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);
        px = new int[cells];
        py = new int[cells];
        color = new int[cells];
        for (int i = 0; i < cells; i++) {
            px[i] = rand.nextInt(size);
            py[i] = rand.nextInt(size);
            color[i] = rand.nextInt(16777215);

        }
        for (int x = 0; x < size; x++) {
            for (int y = 0; y < size; y++) {
                n = 0;
                for (byte i = 0; i < cells; i++) {
                    if (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {
                        n = i;

                    }
                }
                I.setRGB(x, y, color[n]);

            }
        }

        Graphics2D g = I.createGraphics();
        g.setColor(Color.BLACK);
        for (int i = 0; i < cells; i++) {
            g.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));
        }

        try {
            ImageIO.write(I, "png", new File("voronoi.png"));
        } catch (IOException e) {

        }

    }

    public void paint(Graphics g) {
        g.drawImage(I, 0, 0, this);
    }

    static double distance(int x1, int x2, int y1, int y2) {
        double d;
        d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); // Euclidian
    //  d = Math.abs(x1 - x2) + Math.abs(y1 - y2); // Manhattan
    //  d = Math.pow(Math.pow(Math.abs(x1 - x2), p) + Math.pow(Math.abs(y1 - y2), p), (1 / p)); // Minkovski
        return d;
    }

    public static void main(String[] args) {
        new VoronoiDiagram().setVisible(true);
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class WordPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        List<String> list = new ArrayList<String>();
        Set<String> dict = new HashSet<String>(Arrays.asList("cat", "kat", "kit")); 
        int index = 0;

        String sWord = "cat";
        String eWord = "kit";


        String foundWord = removeWord(sWord, dict, index);
        list.add(foundWord);
        if(!foundWord.equals(eWord)){
            dict.remove(foundWord);
        }
        Print.p(foundWord);


        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        List<String> list = new ArrayList<String>();
        Set<String> dict = new HashSet<String>(Arrays.asList("cat", "kat", "kit", "cit")); 
        int index = 0;

        String sWord = "cat";
        String eWord = "kit";
        listWords(sWord, eWord, list, dict);
        Aron.printList(list);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        List<String> list = new ArrayList<String>();
        Set<String> dict = new HashSet<String>(Arrays.asList("kat", "cat", "cow")); 
        int index = 0;

        String sWord = "cat";
        String eWord = "cow";
        listWords(sWord, eWord, list, dict);
        Aron.printList(list);

        Aron.end();
    }

    // cat -> kat
    public static void listWords(String sWord, String eWord, List<String> list, Set<String> dict){
        int index = 0;
        String foundWord = removeWord(sWord, dict, index);
        if(foundWord.length() > 0){ 
            list.add(foundWord);
            dict.remove(foundWord);
            Print.p("fw=" + foundWord);
            Print.p("eWord=" + eWord);
            if(!foundWord.equals(eWord)){
                listWords(foundWord, eWord, list, dict);
            }else{
                Print.p("size=" + list.size());
                Aron.printList(list);
            }
            dict.add(foundWord);
            list.remove(list.size()-1);
        }
    }

    // index = 0
    public static String removeWord(String sWord, Set<String> dict, int index){
        String ret = "";
        if(index < sWord.length()){
            for(char ch='a'; ch<='z' && ret.length() == 0; ch++){
            //for(char ch='a'; ch<='z'; ch++){
                char[] arr = sWord.toCharArray();
                char tmp = arr[index];
                arr[index] = ch;
                String changeWord = new String(arr); 
                if(dict.contains(changeWord)){
                    return changeWord;
                }
                ret = removeWord(sWord, dict, index+1);
            }
        }
        return ret;
    }
} 

import java.util.*;
class ConvertWordToNumber
{
    Map<String, Integer> map = new HashMap<String, Integer>();
    public ConvertWordToNumber()
    {
        InitMap();
    }
    public void InitMap()
    {
        map.put("zero", 0);
        map.put("one", 1);
        map.put("two", 2);
        map.put("three", 3);
        map.put("four", 4);
        map.put("five", 5);
        map.put("six", 6);
        map.put("seven", 7);
        map.put("eight", 8);
        map.put("nine", 9);

        map.put("ten", 10);
        map.put("eleven", 11);
        map.put("twelve", 12);
        map.put("thirteen", 13);
        map.put("fourteen", 14);
        map.put("fifteen", 15);
        map.put("sixteen", 16);
        map.put("seventeen", 17);
        map.put("eighteen", 18);
        map.put("nineteen", 19);

        map.put("twenty", 20);
        map.put("thirty", 30);
        map.put("forty", 40);
        map.put("fifty", 50);
        map.put("sixty", 60);
        map.put("seventy", 70);
        map.put("eighty", 80);
        map.put("ninety", 90);

        map.put("hundred", 100);
        map.put("thousand", 1000);
        map.put("million", 1000000);
        map.put("billion", 1000000000);
    }

    public int Convert2(String englishWord)
    {
        String[] array = englishWord.split(" ");
        int sum = 0;
        int total = 0;
        for(int i=0; i<array.length; i++)
        {
            int base = map.get(array[i]);
            if(base == 1000 || base == 1000000 
                    || base == 1000000000)
            {
                sum *= base;
                total += sum;
                sum = 0;
            }
            else
            {
                if(base == 100)
                    sum *= base;
                else
                    sum += base;
            }
        }
        total += sum;
        return total;
    }

    public int Convert(String englishWord)
    {
        String[] array = englishWord.split(" ");    
        int sum = 0; int s = 0;
        if(array != null)
        {   
            for(int i=0; i<array.length; i++)
            {
                Integer n = map.get(array[i]);            
                System.out.print("{"+n+"}");
                if(n == 1000 || n == 1000000 || n == 1000000000)
                {
                    s *= n;
                    sum += s;
                    s = 0;
                }
                else if( n == 100)
                {
                    s *= n;
                }
                else
                {
                    s += n;
                }
            }
            sum += s;
        }
        return sum;
    }
}

public class WordToNumber 
{
    public static void main(String[] args)
    {
        System.out.println("Convert English spoken number to numerical number");
        ConvertWordToNumber num = new ConvertWordToNumber();
        String words = "nine million five thousand two hundred twelve";
        int n =  num.Convert2(words);
        System.out.println();
        System.out.println(words);
        System.out.println("["+n+"]");

        words = "one";
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "one thousand";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "two hundred twelve ";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "seven million twelve thousand four hundred twenty nine";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");

        System.out.println();
        words = "seven million twenty one thousand four hundred twenty nine";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");


        System.out.println();
        words = "zero";
        System.out.println(words);
        n =  num.Convert2(words);
        System.out.println("["+n+"]");


    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.output.TeeOutputStream;

import classfile.*;

public class WriteOutputConsole {
    public static void main(String[] args) {
//        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String fName = "./text/myfile3.txt";
        String content = "This is my file";
        Aron.writeFileBoth(fName, content);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        
        String fName = "./text/file33.txt";
        List<String> list = Arrays.asList("cat\n", "dog\n", "cow\n");

        Aron.writeFileBoth(fName, list);

        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

public class allPairSum{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }
    public static void test0() {
        Aron.beg();
        Integer[] arr = {1, 2, 3, 4}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 0);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Integer[] arr = {1, 3, 3, 7}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 2);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 7}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 4);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 4}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 2);

        Aron.end();
    }

    public static void test4() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 4, 4}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 4);

        Aron.end();
    }
    public static void test5() {
        Aron.beg();
        Integer[] arr = {1, 4, 4, 4, 4, 4, 7}; 
        int sum = 8;
        List<Integer> list = sum(arr,  sum);
        Aron.printList(list);
        Test.t(list.size(), 6);

        Aron.end();
    }

    //[ file=pairofelements.html title=""
    // [4, 1, 7] 8
    // {4, 7, 1}
    // 4 -> 1
    // 7 -> 1
    // 1 -> 1
    //
    // [4, 4, 1, 7]
    // {4, 4, 7, 1}
    // 4->2
    // 7->1
    // 1->1
    public static List<Integer> sum(Integer[] arr, int sum) {
        List<Integer> list = new ArrayList<Integer>(); 
        if(arr != null){
            int len = arr.length;
            Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
            for(Integer n : arr){
                if(map.containsKey(n)){
                    Integer v = map.get(n);
                    map.put(sum - n, v.intValue() + 1);
                }else{
                    map.put(sum - n, 1);
                }
            }

            for(Integer n : arr){
                if(map.containsKey(n)){
                    Integer v = map.get(n);
                    if(v != null){
                        if(2*n == sum){
                            if(v.intValue() > 1){
                                if(v.intValue() % 2 == 1){
                                    for(int i=0; i<v.intValue()-1; i++)
                                        list.add(n);
                                }else{
                                    for(int i=0; i<v.intValue(); i++)
                                        list.add(n);
                                }
                                map.remove(n);
                            }
                        }else{
                            list.add(n);
                        }
                    }
                }
            }
            
        }
        return list;
    }
    //]

}

import java.io.*;
class allprime 
{
	public static void main(String args[])
	{
		allprime(10000);
	}
	public static void allprime(int num)
	{
		boolean[] primeArr = new boolean[num+1];
		for(int i=2; i<=num; i++)
			primeArr[i] = true;	

		for(int i=2; i<=num; i++)
			for(int j=i; i*j<=num; j++)
				primeArr[i*j] = false;

		int count=1;
		for(int i=2; i<=num; i++)
		{
			if(primeArr[i])
			{
				System.out.print(String.format("%6d", i));
				if(count%30==0)	
					System.out.println();
				count++;
			}
		}
		System.out.println();
	}
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.stream.Collectors;

public class backwardsubstitute{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        
        Double[][] arr2d = {
            {4.0, 2.0},
            {0.0, 6.0}
        };
        Double[] b = {8.0, 2.0}; 
        Double[] x = new Double[b.length];

        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length;
        int h = 0, w = 0; 

        backwardSubstitute(arr2d, x, b);
        Print.p(x);

        Aron.end();
    }

    /**
        backward substitute

        a11 a12 a13 x[0] = b[0]
            a22 a23 x[1] = b[1]
                a33 x[2] = b[2]
    */
    public static void backwardSubstitute(Double[][] a, Double[] x, Double[] b){
        // check null here
        int height = a.length;
        int width = a[0].length; 
        for(int h = height - 1; h >= 0; h--){
            int s = 0;
            for(int w = width - 1; w >= h; w--){
                if(w == h){
                    x[h] = b[h]/a[h][w];
                }else{
                    s += a[h][w]*x[w];
                }
            }
        }
    }
} 

import java.io.*;

abstract class Abst
{
	int n;
 	public Abst()
	{
	}
	abstract void face();
	public void print()
	{
		System.out.println("print");
	}
}

class myclass extends Abst
{
	void face()
	{
		System.out.println("face");
	}
}


class Abstract
{
	public static void main(String args[])
	{
		myclass a = new myclass();
		a.face();
		a.print();
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Add 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr1={9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9};
		int[] Arr2={9, 7};
		int[] Arr = new int[3];
		Arr = Add(Arr1, Arr2);
		for(int i=0; i<Arr1.length; i++)
			System.out.print(Arr1[i]+" ");
		System.out.println();

		for(int i=0; i<Arr2.length; i++)
			System.out.print(Arr2[i]+" ");
		System.out.println();

		for(int i=0; i<Arr.length; i++)
			System.out.print(Arr[i]+" ");
		System.out.println();
	}
	public static int[] Multiple(int[] Arr1, int[] Arr2)
	{

		return null;
	}
	public static int[] Add(int[] Arr1, int[] Arr2)
	{
		int[] Arr = null;
		int mod=0; int c=0;
		if(Arr1 != null && Arr1 != null)
		{
			int len1 = Arr1.length;
			int len2 = Arr2.length;
			Arr = new int[len1>len2?len1+1:len2+1];
			if(len1 > 0 && len2 > 0 && len1 >= len2)
			{
				for(int i=0; i<len1; i++)
				{
					if(len2-1-i >= 0)
					{
						mod = (c + Arr1[len1-1-i] + Arr2[len2-1-i])%10;
						c = (c + Arr1[len1-1-i] + Arr2[len2-1-i])/10;
					}
					else
					{
						mod = (c + Arr1[len1-1-i])%10;
						c = (c + Arr1[len1-1-i])/10;
					}
					Arr[len1+1-1-i]=mod;
				}
				if(c>0)
					Arr[0]=c;
			}
			else if(len1 > 0 && len2 > 0 && len2 > len1)
			{
				for(int i=0; i<len2; i++)
				{
					if(len1-1-i >= 0)
					{
						mod = (c + Arr1[len1-1-i] + Arr2[len2-1-i])%10;
						c = (c + Arr1[len1-1-i] + Arr2[len2-1-i])/10;
					}
					else
					{
						mod = (c + Arr1[len2-1-i])%10;
						c = (c + Arr1[len2-1-i])/10;
					}
					Arr[len2+1-1-i]=mod;
				}
				if(c>0)
					Arr[0]=c;
			}
		}
		if(c == 0)
		{
			int[] A = new int[Arr.length-1];
			for(int i=1; i<Arr.length; i++)
				A[i-1]=Arr[i];
			Arr=null;
			Arr = new int[A.length];
			for(int i=0; i<A.length; i++)
				Arr[i]=A[i];
		}
		return Arr;
	}
}
public class AddMultiString 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        System.out.println("9+98");
        System.out.println(Add("0", "1"));
    }
    public static String Add(String s1, String s2)
    {
        String ret = "0";
        if(s1 != null && s2 != null)
        {
            if(s1 == "0" && s2 == "0")
                return ret; 

            int len1 = s1.length();
            int len2 = s2.length();
            int maxlen = len1 > len2 ? len1 : len2;
            int[] A1 = new int[maxlen];
            int[] A2 = new int[maxlen];

            for(int i=0; i<maxlen; i++)
                A1[i] = A2[i] = 0;

            int index1 = 0, index2 = 0;
            while(index1 < len1)
            {
                A1[(maxlen-len1)+index1] = s1.charAt(index1)-'0';
                index1++;
            }

            while(index2 < len2)
            {
                A2[(maxlen-len2)+index2] = s2.charAt(index2)-'0';
                index2++;
            }

            int[] sum = new int[maxlen+1];
            int s=0, carry = 0, i=0;
            for(i=maxlen-1; i >= 0; i--)
            {
                s = A1[i] + A2[i] + carry;    
                sum[i+1] = s % 10;
                carry = s / 10;
            }
            if(carry > 0)
            {
                sum[0] = carry;
            }
            
            for(int j=0; j<maxlen+1; j++)
            {
                if((j == 0 && sum[j] > 0) || j > 0)
                    ret += sum[j] + "";
            }
        }
        return ret;
    }
}
import java.util.*;

class AddRemoveRandomClass
{
   Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
   int lastIndex;
   int max;
   int[] array;
   public AddRemoveRandomClass(int max)
   {
       lastIndex= 0;
       this.max = max;
       array = new int[max];
   }
   public void add(Integer num)
   {
       if(!map.containsKey(num) && lastIndex < max)
       {
           map.put(num, lastIndex);
           array[lastIndex] = num;
           lastIndex++;
       }
   }
   public void remove(int num)
   {
       Integer value = null;
       if((value = map.get(num)) != null)
       {
            map.remove(num);
            map.put(array[lastIndex], value);
            array[value] = array[lastIndex];
            lastIndex--;
       }
   } 
   public Integer getRandom()
   {
       if(lastIndex > 0)
       {
           Random ran = new Random(); 
           int index = ran.nextInt(lastIndex);
           return array[index];
       }
       else 
       {
           return -1;
       }
   }
   public void print()
   {
       for(int i=0; i < lastIndex; i++)
       {
            System.out.println("["+i+"]=["+array[i]+"]");
       }
   }
}

public class AddRemoveRandom 
{
				public static void main(String[] args)
				{
                    AddRemoveRandomClass stuff = new AddRemoveRandomClass(100);
                    stuff.add(20);
                    stuff.add(40);
                    stuff.add(2);
                    stuff.add(0);
                    stuff.print();
                    stuff.remove(40);
                    stuff.remove(2);
                    stuff.remove(0);
                    stuff.remove(20);
                    System.out.println();
                    stuff.print();
                    System.out.println("random=" + stuff.getRandom());
				}
}
public class AdjacentMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("AdjacentMatrix");
        int array[][] = new int[][]{
        { 0, 2, 3, 4, 5 },
        { 0, 0, 1, 2, 9 },
        { 0, 0, 0, 6, 5 },
        { 0, 0, 0, 0, 7 },
        { 0, 0, 0, 0, 0 }
        };
        int row = 0;
        int max = findMinPath(array, row);
        System.out.println("max=" + max);
    }
    static int findMinPath(int[][] array, int row)
    {
        int max = 0;
        if(array != null)
        {
            int height = array.length;
            int width  = array[0] != null ? array[0].length : 0;
            //System.out.println("height=" + height);
            //System.out.println("width=" + width);

            if(row < height)
            {
                int currMax = 0;
                for(int col=0; col < width; col++)
                {
                    if(array[row][col] != 0)
                    {
                        System.out.println("("+row+")"+array[row][col]+"->("+col+")");
                        int subMax = findMinPath(array, col) + array[row][col];
                        if(subMax > currMax) 
                            currMax = subMax;
                    }
                }
                //System.out.println("max=" + currMax);
                max = currMax;
            }
        }
        return max;
    }
}
public class AllSquareNumber 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SquareNumber(10);
    }
    //(X-1)^2 = X^2 -2X + 1
    //=>   X^2= (X-1)^2 + 2X + 1
    //=>   X^2= (X-1)^2 + (X-1) + X 
    static void SquareNumber(int n)
    {
        int prev = 0;
        int prevSquare = 0;   
        for(int curr=1; curr<=n; curr++)
        {
            prevSquare = prevSquare + prev + curr;
            System.out.println("["+prevSquare+"]");
            prev = curr;
        }
    }
}
import java.util.*;

public class AllUniqueSubPalindrome 
{
    public static void main(String[] args)
    {
        System.out.println("Palindrome With Space");
        int count = allUniqueSubPalindrome("aabaa");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);
        count = allUniqueSubPalindrome("a");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);
        count = allUniqueSubPalindrome("aa");
        System.out.println("------------------------------------------------");
        System.out.println("count=" + count);

        System.out.println("count=" + count);
        boolean b = isPalindrome("abc");
        System.out.println("abc=" + b);
         b = isPalindrome("aba");
        System.out.println("aba=" + b);
        b = isPalindrome("a");
        System.out.println("a=" + b);
        b = isPalindrome("ab");
        System.out.println("ab=" + b);
        b = isPalindrome("aabbccee");
        System.out.println("aabbccee=" + b);
        System.out.println("================================================");

        List<String> list = allSubString("abcdefg");
        for(String str:list){
            System.out.println(str);
        }
        System.out.println("================================================");
        List<String> list1 = mySubstring("helloworld", "world");
        for(String str:list1){
            System.out.println(str);
        }

    } 
    public static boolean isPalindrome(String str) {
        boolean ret = true; 
        if( str != null){
            int len = str.length();
            for(int i=0; i<len/2 && ret; i++){
                if(str.charAt(i) != str.charAt(len-1-i)){
                    ret = false; 
                }
            }
        }
        return ret;
    }

    public static List<String> mySubstring(String str1, String str2) {
        List<String> list = new ArrayList<String>();
        int len1 = str1.length();
        int len2 = str2.length();
        for(int i=0; i<len1 - len2 + 1; i++){
            String str = str1.substring(i, i+len2);
            list.add(str);
        }
        return list;
    }
    public static List<String> allSubString(String str) {
        List<String> list = new ArrayList<String>(); 
        int len = str.length();
        for(int i=0; i<len; i++){
            for(int j=i; j<len; j++){
                String substr = str.substring(i, j+1);
                list.add(substr);
            }
        }
        return list;
    }
    public static int allUniqueSubPalindrome(String str) {
        Set<String> set = new HashSet<String>();
        if(str != null){
            int len = str.length();
            for(int i=0; i<len; i++){
                for(int j=i; j<len; j++){
                    String substr = str.substring(i, j+1);
                    if(!set.contains(substr) && isPalindrome(substr)){
                        set.add(substr);
                    }
                }
            }
        }
        return set.size();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.List;

public class AmazonLocker{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test();
    }

    static int countOp(long n){
        List<Long> list = new ArrayList<Long>();
        if(n == 0)
            list.add((long)0);
        else if(n > 0){
            while(n > 0){
                long r = n % 2;
                list.add(r);
                n = n/2;
            }
        }

        int sum = 0;
        for(int i=0; i<list.size(); i++){
            if(list.get(i) == 1)
                sum += i+1;
        }
        return sum;
    }
    static void test(){
        System.out.println(countOp(5));
        System.out.println(countOp(3));
        System.out.println(countOp(6));
    }

    
    // amazon locker, locker, problem, manhattan problem,
    static int[][] getLockerDistanceGrid(int cityLength, int cityWidth, int[] lockerXCoordinates, int[] lockerYCoordinates) {
        int[][] gridArray = new int[cityLength][cityWidth];
        
        for (int i = 0; i < cityLength; i++) {
            for (int j = 0; j < cityWidth; j++) {
                for (int k = 0; k < lockerXCoordinates.length; k++) {
                    int distance1 = Math.abs(lockerXCoordinates[k] - i + 1 );
                    int distance2 = Math.abs(lockerYCoordinates[k] - j + 1 );
                    int sumDistance = distance1 + distance2;
                    
                    if (k == 0) {
                        gridArray[i][j] = sumDistance;
                    } else {
                        if (sumDistance < gridArray[i][j]) {
                            gridArray[i][j] = sumDistance;
                        }
                    }
                }
            }
        }
        return gridArray;
    }
}
import java.util.*;
import java.math.BigInteger;


final class Sortkey{
    //[ file=sortkeyanagram.html title=""
    //================================================================================ 
    // java anagram 
    // Use sort technic to solve anagrams problem 
    // Use sorted str as key
    // {dog, god}
    // dgo->{dog, god}
    // -------------------------------------------------------------------------------- 
    static String sortStr(String s) {
        char[] clist = s.toCharArray();
        Arrays.sort(clist);
        return String.valueOf(clist);
    }
    static List<String> anagrams(List<String> list, String input) {
        Map<String, List<String>> map = new HashMap<String, List<String>>();

        if(list != null && input != null) {

            for(String str : list) {
                String key = sortStr(str);
                List<String> l = map.get(key);
                if(l != null) {
                    l.add(str);
                    map.put(key, l);
                } else {
                    List<String> ll = new ArrayList<String>();
                    ll.add(str);
                    map.put(key, ll);
                }
            }
        }
        return map.get(sortStr(input));
    }
    //]
}

final class Better {
    public  static List<Integer> genePrima(int count) {
        List<Integer> list = new LinkedList<Integer>();
        list.add(2);
        Integer prime=3;
        int c=0;
        while(c < count) {
            boolean isPrime = true;
            for(Integer p : list) {
                if(prime % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(prime);
                c++;
            }
            prime = prime + 1;
        }
        return list;
    }
    public  static Map<Character, BigInteger> generate() {
        Map<Character, BigInteger> map = new HashMap<Character, BigInteger>();
        List<Integer> plist = genePrima(25);

        char ch = 'a';
        for(int i=0; i<26; i++) {
            Character chara = new Character(ch);
            BigInteger big = BigInteger.valueOf((plist.get(i).intValue()));
            map.put(chara, big);
            ch = (char)(ch + 1);
        }
        return map;
    }
    public  static Map<BigInteger, List<String>> anagram(List<String> list) {
        Map<Character, BigInteger> map = generate();
        Map<BigInteger, List<String>> wordMap = new HashMap<BigInteger, List<String>>();
        for(String word:list) {
            BigInteger product = BigInteger.valueOf(1);
            for(int i=0; i<word.length(); i++) {
                char ch = word.charAt(i);
                if(map.containsKey(ch))
                    product = product.multiply(map.get(ch));
            }
            if(wordMap.containsKey(product)) {
                List<String> wordList = wordMap.get(product);
                wordList.add(word);
                wordMap.put(product, wordList);
            } else {
                List<String> wordList = new ArrayList<String>();
                wordList.add(word);
                wordMap.put(product, wordList);
            }
            product = BigInteger.valueOf(1);
        }
        return wordMap;
    }
}

final class Basic {
    public static List<Integer> getPrime(int n) {
        int k = 0;
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int num = 3;
        while(k < n) {
            boolean isPrime = true;
            for(Integer p : list) {
                if( num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(num);
                k++;
            }
            num++;
        }
        return list;
    }

    //[ file=anagrambasic.html title=""
    public static Map<String, Integer> primeMap() {
        List<Integer> list = getPrime(26);
        Map<String, Integer> map = new HashMap<String, Integer>();
        char ch = 'a';
        for(Integer p : list) {
            map.put(ch + "", p);
            ch += 1;
        }
        return map;
    }

    public static Integer getProduct(String str) {
        Map<String, Integer> map = primeMap();
        int p = 1;
        for(int i=0; i<str.length(); i++) {
            p *= map.get((str.charAt(i) + "").toLowerCase());
        }
        return p;
    }

    public static List<String> anagrams(List<String> list, String str) {
        Map<Integer, List<String> > map = new HashMap<Integer, List<String>>();

        for(String s : list) {
            List<String> l = map.get(getProduct(s));
            if(l != null) {
                l.add(s);
                map.put(getProduct(s), l);
            } else {
                List<String> ll = new ArrayList<String>();
                ll.add(s);
                map.put(getProduct(s), ll);
            }
        }
        return map.get(getProduct(str));
    }
    //]
}

public class Anagram {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test0();
        test1();
        test2();
        test3();
    }

    public static void test0() {
        System.out.println("test1()");
        List<String> list = new ArrayList<String>() {
            {
                add("dog");
                add("god");
                add("nice");
                add("debitcard");
                add("badcredit");
            }
        };
        Map<BigInteger, List<String>> wordMap = Better.anagram(list);
        for(BigInteger big: wordMap.keySet()) {
            List<String> wordlist = wordMap.get(big);
            System.out.println(big);
            for(String word: wordlist) {
                System.out.println(word);
            }
            System.out.println();
        }
    }

    public static void test1(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        words.add("God");
        words.add("Barack");
        words.add("Obama");
        List<String> list = Basic.anagrams(words, "dog");
        for(String s : list){
            System.out.println(s);
        }
    }

    public static void test2(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        List<String> list = Basic.anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }

    public static void test3(){
        List<String> words = new ArrayList<String>();
        words.add("");
        List<String> list = Basic.anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }
}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Anagrams2{

    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        words.add("God");
        words.add("Barack");
        words.add("Obama");
        List<String> list = anagrams(words, "dog");
        for(String s : list){
            System.out.println(s);
        }
    }

    static void test1(){
        List<String> words = new ArrayList<String>();
        words.add("dog");
        List<String> list = anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }

    static void test2(){
        List<String> words = new ArrayList<String>();
        words.add("");
        List<String> list = anagrams(words, "d");
        if(list != null) {
            for (String s : list) {
                System.out.println(s);
            }
        }
    }


    //[file=anagram2.html title=""
    static List<Integer> getPrime(int n){
        int k = 0;
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int num = 3;
        while(k < n){
            boolean isPrime = true;
            for(Integer p : list){
                if( num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime){
                list.add(num);
                k++;
            }
            num++;
        }
        return list;
    }

    static Map<String, Integer> primeMap(){
        List<Integer> list = getPrime(26);
        Map<String, Integer> map = new HashMap<String, Integer>();
        char ch = 'a';
        for(Integer p : list){
            map.put(ch + "", p);
            ch += 1;
        }
        return map;
    }

    static Integer getProduct(String str){
        Map<String, Integer> map = primeMap();
        int p = 1;
        for(int i=0; i<str.length(); i++){
            p *= map.get((str.charAt(i) + "").toLowerCase());
        }
        return p;
    }

    static List<String> anagrams(List<String> list, String str){
        Map<Integer, List<String> > map = new HashMap<Integer, List<String>>();

        for(String s : list){
            List<String> l = map.get(getProduct(s));
            if(l != null){
                l.add(s);
                map.put(getProduct(s), l);
            }else{
                List<String> ll = new ArrayList<String>();
                ll.add(s);
                map.put(getProduct(s), ll);
            }
        }
        return map.get(getProduct(str));
    }
    //]
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

// amazon test anagram amazontest amazon_test
public class AnagramIndex{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();

        String haystack = "abdcghbaabcdij";
        String needle = "bcda";
        List<Integer> list = getAnagramIndices1(haystack, needle);
        Print.pbl(list);
        Aron.end();
    }

    static void test1(){
        Aron.beg();

        String haystack = "bbbababaaabbbb";
        String needle = "ab";
        List<Integer> list = getAnagramIndices1(haystack, needle);
        Print.pbl(list);

        Aron.end();
    }

    public static List<Integer> getAnagramIndices1(String haystack, String needle) {
        List<Integer> list = new ArrayList<Integer>(); 
        int len = needle.length();
        int hlen = haystack.length();
        String sortNeedle = Aron.sortStr(needle);
        for(int i=0; i<hlen; i++){
            if(len  + i <= hlen){
                String subStr = haystack.substring(i, len + i); 
                String s1 = Aron.sortStr(subStr);
                if(s1.equals(sortNeedle)){
                    list.add(i);
                }
                Print.pbl(subStr);
            }
        }
        return list;
    }
} 


import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class MyNode{
    String data;
    int count;
    public MyNode(String data, int count){
        this.data = data;
        this.count = count;
    }
}

class TextMap{

    public TextMap(){
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }
}

public class AnimalLogic{
    public static void main(String[] args) {
//        test0();
//        test1();
        //test2();
//        test3();
//        test4();
//        test5();
//        test00();
//        test11();
//        test12();
        test13();
    }

    static void test00(){
        Aron.beg();
        
        int n = random(1);
        Print.pbl("n=" + n);

        for(int i=0; i<10; i++){
            int n1 = random(2);
            Print.pbl("n1=" + n1);
        }

        Aron.end();
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public static void test12(){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }

    public static void test13(){
        Aron.beg();

        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        Map<Map<String, String>, Map<Integer, String>> revMap = createBiMap(map);

        String seedFirst = "one";
        String seedSecond = "two";
        int numWords = 10;
        List<String> wordList = generateText(numWords, seedFirst, seedSecond, map, revMap);
        Aron.printList(wordList);
    }

    public static List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }

//    public static Map<String, String> newKeyMap(Map<String, String> map, String newWord){
//        map.get
//    }

    public static Map<Map<String, String>, Map<Integer, String>> createBiMap(Map<Map<String, String>, Map<String, Integer>> map){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 
        return revMap;
    }

    public static void test11(){
        Aron.beg();
        String[] arr = {"dog", 
                        "cat", 
                        "cow", 
                        "dog", 
                        "cat", 
                        "cow", 
                        "rat", 
                        "pig"}; 

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();

        List<String> list = getWords("./text/animal_logic.txt"); 
        //Map<Map<String, String>, Map<String, Integer>> map = createMap(arr); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }


    public static Map<Map<String, String>, Map<String, Integer>> createMap(List<String> list){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        for(int i=0; i<list.size() - 2; i++){
            Map<String, String> key = new HashMap<String, String>(); 
            Map<String, Integer> value = new HashMap<String, Integer>(); 
            key.put(list.get(i), list.get(i+1)); 
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key); 
            if(v == null){
                map.put(key, value);
            }else{
                Integer n = v.get(list.get(i+2));
                if(n == null){
                    v.put(list.get(i+2), 1);
                }else{
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    public static Map<Map<String, String>, Map<String, Integer>> createMap(String[] arr){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        List<String> list = Arrays.asList(arr); 
        map = createMap(list);
        return map;
    }
    public static void test0(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");

        String fileName = "text/myfile.txt";
        List<String> list = getWords(fileName); 

        for(String s : list){
            List<String> pairList = pair(s); 
            for(String k : pairList){
                if(map.containsKey(k)){
                    int count = map.get(k);
                    count++;
                    map.put(k, count);
                }else{
                    map.put(k, 1);
                }
            }
        }
        
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        } 
        
        Aron.printList(list);

        Aron.end();
    }
    public static List<String> pair(String s){
        List<String> list = new ArrayList<String>(); 
        if(s.length() > 1){
            for(int k=0; k < s.length(); k++){
                for(int i=0; i < s.length()-(1 + k); i++){
                    list.add(s.substring(i, i+(2 + k)));
                }
            }
        }
        return list;
    }

    // read a text file capture all words
    // word: non-whitespace char 
    public static List<String> getWordsNonWhiteSpace(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)\\S+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read a text file and capture all words
    // word: a-z char
    public static List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }
    public static void test1(){
        Aron.beg();
        
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
                
        String fileName = "text/textfile.txt";
        List<String> list = getWordsNonWhiteSpace(fileName);
        Aron.printList(list);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        String s = "abc";                
        int len = s.length();

            // "abc" [ "" -> "abc"]
            //       [ "a" -> "bc"]
            //       [ "ab"-> "c" ]
            for(int j=0; j<len-1; j++){
                    String prefix = s.substring(0, j);
                    String suffix = s.substring(j, len);
                    Print.pbl("prefix=" + prefix);
                    Print.pbl("suffix=" + suffix);
            }

        Aron.end();
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public static Map<Integer, String> inverseMap(Map<String, Integer> map){

        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        return revMap;
    }
    public static void test5(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        Map<Integer, String> revMap = inverseMap(map); 

        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        String s = "abc";                
        
        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        
        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        // 1 -> k1
        // 2 -> k2
        // 3 -> k2

        Aron.end();
    }
} 

import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;


// Markov chain algorithm, markov chain generate text, random text, rand text, 
// random markov chain text
//
// java javafx, javaui, java ui, java ui api, javafx ui, javafx api
// javafx textarea textfield, javafx messagebox, javafx control, javavx vbox hbox, javafx button
// animal logic task, animal logic project, animallogic, animal_logic task
final class TextMap {
    String fileName;
    Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() { }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read file line by line to list
    public List<String> readFile(String fileName) {
        List<String> list = new ArrayList<String>();
        try {
            BufferedReader in = new BufferedReader(new FileReader(fileName));
            String str;
            while((str = in.readLine()) != null) {
                list.add(str.trim());
            }
            in.close();
        } catch(IOException io) {
            io.printStackTrace();
        }
        return list;
    }


    // generate map from prefix -> suffix, e.g.  <my, dog> -> <is, 1>
    public Map<Map<String, String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            Map<String, String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.put(list.get(i), list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    // generate list of words from prefix, suffix
    public List<String> generateText(int numWords, String prefix, String suffix, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {
        List<String> list = new ArrayList<String>();

        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {
                        int ranKey = random(revValueMap.size());
                        String newSuffix = revValueMap.get(ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }

    // generate map: <prefix, suffix> -> <frequency, word>
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<Map<String, String>, Map<String, Integer>> map) {
        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);
            }
        }
        return tableMap;
    }

    public List<String> textGeneMap() {
        List<String> list = getWords();
        map = prefixSuffixMap(list);

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                str += keyEntry.getKey() + " " + keyEntry.getValue() + " => ";

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                str += "\n";
            }
            retList.add(str);
        }
        return retList;
    }

    // generate list of words from user inputs: maximum number of words, prefix, and suffix
    public List<String> processFile(int maxWords, String prefix, String suffix) {
        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class AnimalLogicTask  extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");
        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                if(fileName != null) {

                    String[] prefixArr = prefixTF.getText().trim().split("\\s+");
                    String[] suffixArr = suffixTF.getText().trim().split("\\s+");
                    if(prefixArr.length == 2 && suffixArr.length == 1) {
                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }
                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }
                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 1000, 800));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import java.util.List;
import java.util.function.Predicate;
import java.util.ArrayList;

import classfile.*;

class Employee {
    public int id;
    public String name;
    public int sal;
    public Employee(int id,String name,int sal  ) {
        this.id = id;
        this.name = name;
        this.sal = sal;
    }
    public static List<Employee> getEmpList() {
        List<Employee> list = new ArrayList<>();
        list.add(new Employee(1, "A", 2000));
        list.add(new Employee(2, "B", 3000));
        list.add(new Employee(3, "C", 4000));
        list.add(new Employee(4, "D", 5000));
        return list;
    }
}

public class AnyMatch {
    public static void main(String[] args) {
        Predicate<Employee> p1 = e -> e.id < 10 && e.name.startsWith("A");
        Predicate<Employee> p2 = e -> e.sal < 10000;
        List<Employee> list = Employee.getEmpList();
        //using allMatch
        boolean b1 = list.stream().allMatch(p1);
        System.out.println(b1);
        boolean b2 = list.stream().allMatch(p2);
        System.out.println(b2);
        //using anyMatch
        boolean b3 = list.stream().anyMatch(p1);
        System.out.println(b3);
        boolean b4 = list.stream().anyMatch(p2);
        System.out.println(b4);
        //using noneMatch
        boolean b5 = list.stream().noneMatch(p1);
        System.out.println(b5);
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class AutoComplete{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        List<String> list = Arrays.asList("cat", "cow"); 
        Map<String, List<String>> map = autocomplete(list);
        Aron.printMap(map);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        List<String> list = Arrays.asList("cat", "cow", "ban", "ball", "banana", "b"); 
        Map<String, List<String>> map = autocomplete(list);
        Aron.printMap(map);

        Aron.end();
    }

    //[ file=autocomplete.html title=""
    // auto complete, autocomplete
    // 1:01 - 1:34
    //-------------------------------------------------------------------------------- 
    // cat
    // cow
    // c -> [at, ow]
    // ca ->[t]
    // co ->[w] 
    public static Map<String, List<String>> autocomplete(List<String> list){
        Map<String, List<String>> map = new HashMap<>();
        for(String s : list){
            int len = s.length();
            for(int i=0; i<len; i++){
                String prefix = s.substring(0, i);
                String suffix = s.substring(i, len);

                if(prefix.length() > 0){
                    List<String> l = map.get(prefix);
                    if( l != null){
                        l.add(suffix);
                        map.put(prefix, l);
                    }else{
                        List<String> ll = new ArrayList<>();
                        ll.add(suffix);
                        map.put(prefix, ll);
                    }
                }
            }
        }
        return map;
    }
    //]


}

import java.util.*;
import classfile.*;

class BSTDict{
    public Node root;
    public BSTDict() {
        root = null;
    }

    public void insert(int n) {
        if(root == null) {
            root = new Node(n);
        } else {
            Node curr = root;
            boolean end = false;
            while(curr != null && !end) {
                if(n < curr.data) {
                    if(curr.left == null) {
                        curr.left = new Node(n);
                        end = true;
                    } else
                        curr = curr.left;
                } else {
                    if(curr.right == null) {
                        curr.right = new Node(n);
                        end = true;
                    } else
                        curr = curr.right;
                }
            }
        }
    }
    public void OneQueue(Node curr) {
        if(curr != null) {
            Queue<Node> q = new LinkedList<Node>();
        }
    }
    public void inorder(Node curr) {
        if(curr != null) {
            inorder(curr.left);
            System.out.println("[" + curr.data + "]");
            inorder(curr.right);
        }
    }
    public boolean findNode(int n) {
        Node curr = root;
        boolean ret = false;
        if(curr != null) {
            if(n < curr.data)
                curr = curr.left;
            else if(n > curr.data)
                curr = curr.right;
            else
                ret = true;
        }
        return ret;
    }
    public boolean findSum(Node r, int n) {
        boolean ret = false;
        if(r == null) {
            if(n == 0)
                ret = true;
        } else if(r != null) {
            boolean bl = findSum(r.left, n - r.data);
            boolean br = findSum(r.right, n - r.data);
            ret = (bl || br);
        }
        return ret;
    }
}

public class BSTDictionary{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        String str1 = "tenny";
        String str2 = "tea";
        String str3 = "ten";
        String str4 = "tee";
        Print.p(str1.hashCode());
        Print.p(str2.hashCode());
        Print.p(str3.hashCode());
        Print.p(str4.hashCode());

        BSTDict bst = new BSTDict();
        bst.insert(str1.hashCode());
        bst.insert(str2.hashCode());
        bst.insert(str3.hashCode());
        bst.insert(str4.hashCode());
        
        Aron.end();
    }
}

import java.io.*;
import java.lang.String;
import java.util.*;

// preorder to inorder
// convert preorder to inorder
class Node {
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST {
	Node root;
	public BST()
	{ root = null;};
	public void insert(int n) {
		if(root == null) { 
            root = new Node(n); 
        }
		else { 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end) {
				if(n < cur.data) { 
					if(cur.left == null) { 
                        cur.left = new Node(n);  
                        break;
                    }
                    else 
                        cur = cur.left;
				}else {
					if(cur.right == null) { 
                        cur.right = new Node(n); 
                        break;
                    }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur) {
		if(cur != null) {
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public boolean Find(int n) {
		Node cur = root;
		boolean ret = false;
		if(cur != null) {
			if(n < cur.data)
				cur = cur.left;
			else if(n > cur.data)
				cur = cur.right;
			else
				ret = true;
		}
		return ret;
	}
	public boolean findSum(Node r, int n) {
		boolean ret = false;
		if(r == null) { 
			if(n == 0)
				ret = true;
		}
		else if(r != null) {
			boolean bl = findSum(r.left, n - r.data);
			boolean br = findSum(r.right, n - r.data);
			ret = (bl || br);
		}
		return ret;
	}
	
	public void LevelOrder() {
		Node cur = root;
		Queue<Node> Q1 = new LinkedList<Node>();
		Queue<Node> Q2 = new LinkedList<Node>();
		Q1.offer(cur);
		while(Q1.peek() != null || Q2.peek() != null) {
			while(Q1.peek() != null) {
				Node top = Q1.poll();
				System.out.print(top.data + " ");
				if(top.left != null)
					Q2.offer(top.left);
				if(top.right != null)
					Q2.offer(top.right);
			}
			System.out.println();
			while(Q2.peek() != null) {
				Node top = Q2.poll();
				
				System.out.print(top.data + " ");
				if(top.left != null)
					Q1.offer(top.left);
				if(top.right != null)
					Q1.offer(top.right);
			}
			System.out.println();
		}
	}
	public Node getRoot() { 
        return root;
    }
}
class BSTfromPreOrderInOrder {
	public static void main(String args[]) {
		int[] pArr = {10, 5, 1, 7, 15, 12, 20};
		int[] iArr = {1, 5, 7, 10, 12, 15, 20};
		
		ArrayList<Node> preArr = new ArrayList<Node>();
		ArrayList<Node> inArr = new ArrayList<Node>();
		for(int i=0; i<pArr.length; i++) {
			preArr.add(new Node(pArr[i]));
			inArr.add(new Node(iArr[i]));
		}
		Node root = buildBST(preArr, inArr);
		Inorder(root);

	}
	public static void split(ArrayList<Node> preArr, ArrayList<Node> inArr, ArrayList<Node> preL_tree,ArrayList<Node> preR_tree,ArrayList<Node> inL_tree, ArrayList<Node> inR_tree) {
	if(preArr != null && inArr != null && preL_tree != null && preR_tree != null && inL_tree != null && inR_tree != null) {
			int prelen = preArr.size(), inlen = inArr.size();	
			if(prelen > 0) {
				boolean L = true;
				Node root = preArr.get(0);
				for(int i=0; i<inlen; i++) {
					if(L == true && inArr.get(i).data != root.data)
						inL_tree.add(inArr.get(i));
					else if(inArr.get(i).data == root.data)
						L = false;
					else if(L == false && inArr.get(i).data != root.data) {
						inR_tree.add(inArr.get(i));
					}
				}
				for(int i=1; i<prelen; i++) {
					if(i < (inL_tree.size() + 1))
						preL_tree.add(preArr.get(i));	
					else
						preR_tree.add(preArr.get(i));	
				}
			}
		}
	}	

	public static Node buildBST(ArrayList<Node> preArr, ArrayList<Node> inArr) {
		Node parent = null;
		if( preArr != null && inArr != null) {
			int prelen = preArr.size(), inlen= inArr.size();
			if(prelen > 0) {
				parent = new Node(preArr.get(0).data);
				ArrayList<Node> preL_tree = new ArrayList<Node>();
				ArrayList<Node> preR_tree = new ArrayList<Node>();

				ArrayList<Node> inL_tree = new ArrayList<Node>();
				ArrayList<Node> inR_tree = new ArrayList<Node>();
				split(preArr, inArr, preL_tree, preR_tree, inL_tree, inR_tree);
				parent.left 	= buildBST(preL_tree, inL_tree);
				parent.right 	= buildBST(preR_tree, inR_tree);
			}
		}
		return parent;
	}	

	public static void Inorder(Node root) {
		if(root != null) {
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

// select dep.name from Department where id = 100 
// select dep.id   from Department where name = "David"
class Department{
    Map<Integer, String> map;
    public Department(Map<Integer, String> map){
        this.map = map;
    }
}

class DB{

}

public class BaiduDatabase{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;

public class BalanceBracket 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        String s = "[12(3)4[5)]";
        char prev = 'a';
        int[] arr = new int[1];
        arr[0] = 0;
        boolean ret = balanceBracket(s);
        System.out.println("ret="+ret);
    }
    public static boolean balanceBracket(String s)
    {
        boolean ret = true;
        Stack<Character> stack = new Stack<Character>();        
        if(s != null)
        {
            for(int i=0; i<s.length(); i++)
            {
                char ch = s.charAt(i);
                if(ch == '[' || ch == '(')
                {
                    stack.push(ch);
                }
                else if(ch == ']' || ch == ')')
                {
                    Character left = stack.pop();
                    if(!(left == '[' && ch == ']' || left == '(' && ch == ')'))
                        ret = false;
                }
                else if(!('0' <= ch && ch <= '9'))
                {
                    ret = false;
                }

            }
            if(!stack.empty())
                ret = false;
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class BinDeleteNode{
    static Node prevNode = null;
    public static void main(String[] args) {
//        test9();
//        test10();
//        test11();
//        test12();
//        test13();
        test14();
    }
    
    static void test9(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 15;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test11(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        int n = 7;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test12(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test13(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 12;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test14(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 10;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }
    static void test15(){
        Aron.beg();
        
        BST b1 = new BST();
        b1.insert(10);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 
        int n = 13;
        Node newRoot = delete(b1.root, n);
        Aron.binImage(newRoot); 

        Aron.end();
    }


    public static Node findMin(Node r){
        Node curr = r;
        while(r != null && curr.left != null){
            curr = curr.left;
        }
        return curr;
    }

    // gf http://quiz.geeksforgeeks.org/binary-search-tree-set-2-delete/
    public static Node delete(Node r, int n){
        if(r != null){
            if(n < r.data)
                r.left = delete(r.left, n);
            else if(n > r.data)
                r.right = delete(r.right, n);
            else{
                if(r.left == null)
                    return r.right;
                else if(r.right == null)
                    return r.left;
                else{
                    Node min = findMin(r.right);
                    r.data = min.data;
                    r.right = delete(r.right, min.data);
                }

            }
            return r;
        }
        return null;
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class BinDict{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        Aron.beg();
        BST bst = new BST();

        // read dictionary file
        List<String> list = Aron.readFile("text/words.txt"); 

        // add dictionary file to list
        int count = 0;
        while(count < list.size()){
            Random ran = new Random();
            int index = ran.nextInt(list.size());
            //Print.p("index=[" + index + " " + list.size());
            bst.insert(list.indexOf(index));
            list.remove(index);
            //Print.p(list.indexOf(index));
        }

          Aron.inorder(bst.root);
//        Test.t(bst.contains("cat".hashCode()));
//
//        Print.pl("level=" + Aron.level(bst.root));

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(1);
        bst.insert(2);
        bst.insert(3);

        Test.t(Aron.height(bst.root) == 2);
        Test.t(Aron.level(bst.root) == 3);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        
        Aron.end();
    } 
} 
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

//[ file=binite.html title=""
// binary iterator
class BinaryIterator {
    Node curr;
    Stack<Node> stack;
    public BinaryIterator(Node root) {
        curr = root;
        stack = new Stack<Node>();
    }

    public boolean hasNext() {
        return (curr != null || stack.isEmpty() == false);
    }

    public Node next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node;
            }
        }
        return null;
    }
}
//]

public class BinIterator {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    
    static void test0() {
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);

        BinaryIterator bi = new BinaryIterator(bst.root);
        System.out.println("\n---------------------------------");
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------");
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);

        BinaryIterator bi = new BinaryIterator(bst.root);
        System.out.println("\n---------------------------------");
        Aron.inorder(bst.root);
        System.out.println();
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(20);
        bst.insert(18);

        BinaryIterator bi = new BinaryIterator(bst.root);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------");
        while(bi.hasNext()) {
            System.out.println("[" + bi.next().data + "]");
        }
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class BinToCircularDll 
{

	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);

		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
        
		Node r = b1.getRoot();
		//Node t = BinToDLL(r);
        Inorder(r);
        System.out.println("");
        BinToCircularDll(r);
        int k=0;
        if(head != null)
        {
            Node curr = head;
            Node right = head.right;
            if(curr == right) //one node
                System.out.print(curr.data + " ");
            else
            {
                System.out.print(head.data + " ");
                while(head != right)
                {
                    System.out.print(right.data + " ");
                    right = right.right;
                }
            }
        }
	}

    static Node head = null;
    static Node prev = null;
    public static void BinToCircularDll(Node curr)
    {
        if(curr != null)
        {
            BinToCircularDll(curr.left);
            if(prev == null)
                head = curr;
            else
            {
                prev.right = curr;
                curr.left = prev;
            }
            prev = curr;
            Node right = curr.right;
            if(head != null)
            {
                head.left = curr;
                curr.right = head;
            }
            BinToCircularDll(right);
        }
    }


    public static void Inorder(Node r)
    {
        if(r != null)
        {
            Inorder(r.left);
            System.out.print("["+r.data+"]");
            Inorder(r.right);
        }
    }
	public static Node BinToDLL(Node r)
	{
		Node h=null, t=null, cur=null;
		Queue<Node> queue = new LinkedList<Node>();
		if(r != null)
		{
			queue.offer(r);
			while(queue.peek() != null)
			{
				Node no = queue.remove();
				if(no != null && no.left != null)
				{queue.offer(no.left); no.left=null;}

				if(no != null && no.right!= null)
				{queue.offer(no.right); no.right=null;}

				if(h == null)
				{ h = cur = no; }
				else 
				{ no.left = cur;
					cur.right = no;
					cur = cur.right;
				}
			}
			t = cur;
		}
		return t;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
	
	public Node getRoot()
	{ return root;}
}
class BinToDLLRecur 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(1);
		b1.Insert(2);
		b1.Insert(3);
		b1.Insert(4);
		b1.Insert(5);
		b1.Insert(6);
		b1.Insert(7);
		b1.Insert(8);
		b1.Inorder(b1.getRoot());

		Node r = BinToDLL(b1.getRoot());
		boolean bool = isCircularList(r);
		System.out.println("bool=" + bool);
        Node first = r;
        Node left = r.left;
        while( first != left)
        {
		    System.out.println("left=" + left.data);
            left = left.left;
        }

	}
	public static boolean isCircularList(Node r)
	{
		boolean ret = false;
		if(r != null)
		{
			Node cur = r;
			Node next = cur.right;

			while(next != null && cur != next)
			{
				System.out.print("cur="+cur.data + " ");
				if(cur != null)
				cur = cur.right;
				
				next = next.right;
				if(next != null)
					next = next.right;
			}
			if(cur == next)
			{
				System.out.print("cur="+cur.data + " ");
				ret = true;
			}
		}
		return ret;
	}
    
    //convert bst to double
	static Node prev=null;
	static Node head=null;
	public static Node BinToDLL(Node r)
	{
		if(r != null)
		{
			BinToDLL(r.left);
			
			if(prev != null)
			{ 
                prev.right= r;
            }
			else
				head = r;
			r.left = prev;
            prev = r;
			Node right = r.right;

            if(head != null)
                head.left = r;
			r.right = head;

			BinToDLL(right);
		}
		return head;
	}
	public static boolean isBST(Node r)
	{

		if(r == null)
			return true;
		else
		{
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	public static boolean equalBinaryTree(Node r1, Node r2)
	{
		if(r1==null && r2==null)
			return true;
		else if(r1 != null && r2 != null)
		{
			if(r1.data != r2.data)
					return false;
			if(!equalBinaryTree(r1.left, r2.left)) 
					return false;
			if(!equalBinaryTree(r1.right, r2.right))
					return false;
		}
		else 
			return false;
		return true;
	}
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class Pair {
    Queue<Integer> queue = new LinkedList<Integer>();
    int index;
    public Pair() {
        index = -1;
    }
}

class BinarySearch {
    public static void main(String args[]) {
        Test1();
        Test2();
        Test3();
        Test4();
        test5();
        test6();
    }
    static void test5(){
        Aron.beg();

        int[] arr = {0, 2, 3, 5};
        int lo = 0;
        int hi = arr.length - 1;
        int key = 6;
        List<Integer> list = new ArrayList<Integer>(); 

        BinSearchBetween(arr, lo, hi, key, list);
        Aron.printList(list);

        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        int[] arr = {-Integer.MAX_VALUE, 0, 2, 3, 5, Integer.MAX_VALUE};
        int lo = 0;
        int hi = arr.length - 1;
        int key = -1;
        List<Integer> list = new ArrayList<Integer>(); 

        BinSearchBetween(arr, lo, hi, key, list);
        Aron.printList(list);

        Aron.end();
    } 

    public static void BinSearchIndex(int[] arr, int left, int right, int key, Pair pair) {
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            if(key < arr[middle]) {
                if(pair.queue.size() >= 2)
                    pair.queue.remove();
                pair.queue.add(middle-1);

                BinSearchIndex(arr, left, middle - 1, key, pair);
            } else if(key > arr[middle]) {
                if(pair.queue.size() >= 2)
                    pair.queue.remove();
                pair.queue.add(middle+1);

                BinSearchIndex(arr, middle + 1, right, key, pair);
            } else
                pair.index = middle;
        }
    }

    public static boolean BinSearch(int[] arr, int left, int right, int key) {
        boolean ret = false;
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            if(key < arr[middle]) {
                ret = BinSearch(arr, left, middle - 1, key);
            } else if(key > arr[middle]) {
                ret = BinSearch(arr, middle + 1, right, key);
            } else
                ret = true;
        }
        return ret;
    }
    public static boolean BinSearchBetween(int[] arr, int left, int right, int key, List<Integer> list) {
        boolean ret = false;
        if(arr != null && left <= right) {
            int middle = (left + right)/2;
            list.add(middle);

            if(key < arr[middle]) {
                ret = BinSearchBetween(arr, left, middle - 1, key, list);
            } else if(key > arr[middle]) {
                ret = BinSearchBetween(arr, middle + 1, right, key, list);
            } else
                ret = true;
        }
        return ret;
    }


    public static void Test1() {
        int[] arr = {1, 2, 3, 5};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test2() {
        int[] arr = {1};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test3() {
        int[] arr = {2};
        int left = 0;
        int right = arr.length - 1;
        int key = 1;
        boolean ret = BinSearch(arr, left, right, key);
        System.out.println(ret);
    }

    public static void Test4() {
        int[] arr = {0, 2, 3, 5};
        int left = 0;
        int right = arr.length - 1;
        int key = 6;
        Pair pair = new Pair();

        BinSearchIndex(arr, left, right, key, pair);
        for(Integer p:pair.queue) {
            System.out.println("p="+p);
        }
        System.out.println("index="+pair.index);
    }
}

//Binary search in two dimension is based on one dimension search
public class BinarySearch2D 
{
    public static void main(String[] args)
    {
        Test1();
        Test2();
    }

    public static void printArray(int[][] array, int height, int width)
    {
        for(int col=0; col<=height; col++)
        {
            for(int row=0; row<=width; row++)
            {
                System.out.print("["+array[col][row]+"]");
            }
            System.out.println();
        }
    }
    public static void Test1()
    {
        System.out.println("Binary search in two dimension");
        int[][] array = {{1,  100, 200, 201},
                         {5,  105, 205, 1000},
                         {11, 107, 300, 1001},
                         {13, 108, 302, 1002},
                         {104,301, 305, 1003}};
        int key = 201;
        int rlo = 0;
        int rhi = array[0].length-1;
        int clo = 0;
        int chi = array.length-1;
        printArray(array, chi, rhi);

        boolean ret2 = BinSearch2D(array, clo, rlo, chi, rhi, key);
        System.out.println("ret2="+ret2);

        boolean ret3 = binSearchMN(array, clo, rlo, chi, rhi, key);
        System.out.println("ret3="+ret3);
    }

    public static void Test2()
    {
        System.out.println("Binary search in two dimension");
        int[][] array = {{203}};
        int key = 203;
        int rlo = 0;
        int rhi = array[0].length-1;
        int clo = 0;
        int chi = array.length-1;
        printArray(array, chi, rhi);

        boolean ret2 = BinSearch2D(array, clo, rlo, chi, rhi, key);
        System.out.println("ret2="+ret2);

        boolean ret3 = binSearchMN(array, clo, rlo, chi, rhi, key);
        System.out.println("ret3="+ret3);
    }

    //Binary search from top right corder, eliminate row/column algorithm 
    //Complexity O(m+n)
    public static boolean binSearchMN(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        int width = rowhi - rowlo + 1;
        int height = colhi - collo + 1;
        int col = collo;
        int row = rowhi;
        for(int i=0; i<width+height; i++)
        {
            if(key < array[col][row])
            {
                if(row > rowlo)
                    row--;
            }
            else if(key > array[col][row])
            {
                if(col < colhi)
                    col++;
            }
            else 
                return true;
        }
        return false;
    }
    
    //Binary search: eliminate one quandrant in each step
    //Complexity O(lg(m)+lg(n))
    public static boolean BinSearch2D(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        boolean ret = false;
        if(array != null)
        {
            int colm = (collo + colhi)/2;
            int rowm = (rowlo + rowhi)/2;
            if(collo <= colhi && rowlo <= rowhi)
            {
                if(key < array[colm][rowm])
                {
                    boolean b1 = BinSearch2D(array, collo, rowlo,
                                                  colm-1, rowm-1, key);
                    boolean b2 = BinSearch2D(array, collo, rowm,
                                                  colm-1,rowhi, key);
                    boolean b3 = BinSearch2D(array, colm, rowlo,
                                                  colhi, rowm-1, key);
                    ret = b1 || b2 || b3;
                }
                else if(key > array[colm][rowm])
                {
                    boolean b1 = BinSearch2D(array, colm+1, rowm+1,
                                                  colhi,  rowhi, key);
                    boolean b2 = BinSearch2D(array, collo, rowm+1,
                                                  colm,  rowhi, key);
                    boolean b3 = BinSearch2D(array, colm+1, rowlo,
                                                  colhi,  rowm, key);
                    ret = b1 || b2 || b3;
                }
                else
                    ret = true;
            }
        }
        return ret;
    } 
}
    //Binary search: eliminate one quandrant in each step
    //Complexity O(lg(m)+lg(n))
    public static boolean BinSearch2D(int[][] array, int collo, int rowlo, 
                                                     int colhi, int rowhi, int key)
    {
        if(array != null)
        {
            int colm = (collo + colhi)/2;
            int rowm = (rowlo + rowhi)/2;
            if(collo <= colhi && rowlo <= rowhi)
            {
                if(key < array[colm][rowm])
                {
                    boolean b1 = false, b2 = false, b3 = false;
                    b1 = BinSearch2D(array, collo, rowlo,
                                                  colm-1, rowm-1, key);

                    b2 = BinSearch2D(array, collo, rowm,
                                                  colm-1,rowhi, key);
                    b3 = BinSearch2D(array, colm, rowlo,
                                                  colhi, rowm-1, key);
                    return b1 || b2 || b3;
                }
                else if(key > array[colm][rowm])
                {
                    boolean b1 = false, b2 = false, b3 = false;
                    b1 = BinSearch2D(array, colm+1, rowm+1,
                                                  colhi,  rowhi, key);
                    b2 = BinSearch2D(array, collo, rowm+1,
                                                  colm,  rowhi, key);
                    b3 = BinSearch2D(array, colm+1, rowlo,
                                                  colhi,  rowm, key);
                    return b1 || b2 || b3;
                }
                else
                    return true;
            }
        }
        return false;
    } 
import java.io.*;
import java.lang.String;
import java.util.*;
class BinarySearchIteration 
{
	public static void main(String args[])
	{
		int[] Arr = {1, 2, 3, 5};
		int left = 0;
		int right = Arr.length - 1;
		int key = 5;
		int ret = BinSearch(Arr, left, right, key);
		System.out.println(ret);
	}
	public static int BinSearch(int[] Arr, int left, int right, int key)
	{
        int ret = -1;
        while(left <= right && ret == -1)
        {
            //int mid = (left + right)/2;
            int mid = left + (right - left)/2;
            if(Arr[mid] == key)
                ret = mid; 
            else if(Arr[mid] < key)
                left = mid + 1;
            else 
                right = mid -1; 
        }
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import Lib.*;

class BinarySearchTree {
	public static Node prev = null;
	public static void main(String args[]) {
		BST b1 = new BST();

		b1.insert(15);
		b1.insert(12);
		
		b1.insert(14);
		b1.insert(17);
		b1.insert(19);
		b1.insert(130);
		b1.insert(16);
		b1.insert(10);
		
		int[] Arr = new int[100];
		int len=0;
		Node r = b1.getRoot();

		b1.LevelOrder();

		System.out.println(contain(r, 15));

        test1();
        test2();
        test3();
        test4();
        test5();
	}

    public static void kdistance(Node r, int k){
        if(r != null){
            if(k == 0)
                System.out.println(r.data);
            else{
                kdistance(r.left, k-1);
                kdistance(r.right, k-1);
            }
        }
    }

	public static boolean isBST(Node r) {
		if(r == null)
			return true;
		else {
			if(!isBST(r.left))
				return false;
			if(prev != null && prev.data >= r.data)
				return false;
			prev = r;
			if(!isBST(r.right))
				return false;
		}
		return true;
	}
	//init len = 0
	public static void printAllPath(Node r, int[] Arr, int len) {
		if( r != null && Arr != null) {
			Arr[len] = r.data;
			if( r.left == null && r.right == null) {
				for(int i=0; i<len+1; i++)
					System.out.print(Arr[i]+" ");
				System.out.println();
			}
			else {
				printAllPath(r.left, Arr, len+1);
				printAllPath(r.right, Arr, len+1);
			}
		}
	}
	public static int MaxDepth(Node r) {
		if( r != null) {
			int nl = MaxDepth(r.left);
			int nr = MaxDepth(r.right);

			return (nl>nr?nl:nr)+1;
		}
		return 0;
	}
	public static boolean equalBinaryTree(Node r1, Node r2)
	{
		if(r1==null && r2==null)
			return true;
		else if(r1 != null && r2 != null) {
			if(r1.data != r2.data)
					return false;
			if(!equalBinaryTree(r1.left, r2.left)) 
					return false;
			if(!equalBinaryTree(r1.right, r2.right))
					return false;
		}
		else 
			return false;
		return true;
	}
	public static void Inorder(Node root) {
		if(root != null) {
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
	public static boolean contain(Node r, int value) {
		if( r != null) {
			if(contain(r.left, value))
				return true;
			if(r.data == value)
				return true;
			if(contain(r.right, value))
				return true;
		}
		return false;
	}
    // 10 5 1_ _ 6_ _ 14 11 _
    // 10 _ _
    // 10 5_ _ 12_ _
    // int[] k = new int[1];
	public static Node generateBinaryTree(Node r, String[] list, int[] k) {
        if(k[0] < list.length && list[k[0]] != "_"){
            if(r == null)
                r = new Node(Integer.parseInt(list[k[0]]));
            k[0]++;
            r.left = generateBinaryTree(r.left, list, k);
            k[0]++;
            r.right = generateBinaryTree(r.right, list, k);
            return r;
        }
        return null;
    }

    public static void test5() {
        System.out.println("test5"); 
        BST b1 = new BST();
        int k = 2;
		b1.insert(15);
		b1.insert(5);
		b1.insert(20);
		b1.insert(30);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 
    public static void test4() {
        System.out.println("test4"); 
        BST b1 = new BST();
        int k = 1;
		b1.insert(15);
		b1.insert(5);
		b1.insert(20);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 
    public static void test3() {
        System.out.println("test3"); 
        BST b1 = new BST();
        int k = 0;
		b1.insert(15);
		Node r = b1.getRoot();
        kdistance(r, k);
    } 

    public static void test2() {
        System.out.println("test2"); 
        String[] list = {
            "10",
            "8",
            "_",
            "_",
            "12",
            "_",
            "19"
        };
        Node r = null;
        int[] k= new int[1];
        k[0] = 0;
        Node root = generateBinaryTree(r, list, k);
        Inorder(root);
    } 
    public static void test1() {
        System.out.println("test1"); 
        String[] list = {
            "10",
            "_",
            "_"
        };
        Node r = null;
        int[] k= new int[1];
        k[0] = 0;
        Node root = generateBinaryTree(r, list, k);
        Inorder(root);
    } 
}
	public static boolean BinSearch(int[] arr, int left, int right, int key)
	{
		boolean ret = false;
		if(arr != null && left <= right)
		{
			int middle = (left + right)/2;
			if(key < arr[middle])
			{
                ret = BinSearch(arr, left, middle - 1, key);
			}
			else if(key > arr[middle])
			{
                ret = BinSearch(arr, middle + 1, right, key);
			}
			else 
				ret = true;
		}
		return ret;
	}
import java.util.*;
class Node{
        int data;
        Node left;
        Node right;
    public Node(int data){
        this.data = data;
        left = null;
        right = null;
    }
}

class BinaryTree{
    Node root;
    public BinaryTree(){
        root = null;
    }
    public void insert(int data){
        if(root == null){
            root = new Node(data);
        }else{
            Node current = root;
            boolean end = false;
            while(!end){
                if(data < current.data){
                   if(current.left == null){
                       current.left = new Node(data);
                       end = true;
                   }else{
                       current = current.left; 
                   }
                }
                else{
                    if(current.right== null){
                       current.right= new Node(data);
                        end = true;
                    }
                    else{
                       current = current.right;
                    }
                }
            }
        } 
    }
    public void preorder(Node root)
    {
        if(root != null){
            System.out.println("preorder["+root.data+"]");
            preorder(root.left);
            preorder(root.right);
        }
    }

}

public class BinaryToArray 
{
    public static void main(String[] args)
    {
        BinaryTree bin = new BinaryTree();
        bin.insert(10);
        bin.insert(15);
        bin.insert(12);
        bin.insert(20);
        bin.insert(30);
            
        bin.preorder(bin.root);

        int[] Array = new int[20];
        System.out.println("Hello World!");
    }
    public void int[] BinaryToArray(Node root){
        
        Queue<Node> queue1 = new LinkedList<Node>();
        Queue<Node> queue2 = new LinkedList<Node>();
        if(root != null)
            queue1.offer(root);
        while(queue1.peek()){
            Node no = queue1.remove();
            if(no.left != null){
                queue2.offer(no.left);
            }
        }

    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	boolean visited;
	public Node(int n)
	{ data = n; left = null; right = null; visited=false;}
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class BoundryBinaryTree 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(50);
        
		b1.Insert(39);
		b1.Insert(18);
		b1.Insert(35);
		b1.Insert(36);
		b1.Insert(41);
		b1.Insert(43);
        
        b1.Insert(51);
		b1.Insert(91);
		b1.Insert(76);
		b1.Insert(60);
		b1.Insert(99);
		b1.Insert(59);
		b1.Insert(58);

		
        
        System.out.println();
        PrintBoundry(b1.getRoot());
        System.out.println();
        Node right = null;
        //InorderLeftLeafNode(b1.getRoot(), right); 
        System.out.println();
        PrintBoundryWithInorder(b1.getRoot());
	}
	
    //Initialize right = null
    static boolean leaf = false;
    public static void InorderLeftLeafNode(Node curr)
    {
        if(curr != null)
        {
            if(!leaf)
                System.out.print("{" + curr.data + "}");
            if(curr.left == null && curr.right == null)
            {
                if(leaf)
                    System.out.print("[" + curr.data + "]");
                leaf = true;
            }
            InorderLeftLeafNode(curr.left);
            InorderLeftLeafNode(curr.right);
        }
    }
    public static void PrintBoundryWithInorder(Node curr)
    {
        InorderLeftLeafNode(curr);
        if(curr != null)
        {
            Node right = curr.right;
            Stack<Node> stack = new Stack<Node>();
            while(right != null)
            {
                if(right.left != null || right.right != null)
                {
                    stack.push(right);
                    //System.out.print("[" + right.data + "]");
                }
                right = right.right;
            }
            while(!stack.empty())
            {
                System.out.print("[" + stack.pop().data + "]");
            }
        }
            

    }
    public static void PrintBoundry(Node curr)
    {
        Stack<Node> st = new Stack<Node>();
        Set<Integer> hashset = new HashSet<Integer>();
        boolean first = false;
        Node root = curr;
        while(curr != null || !st.empty())
        {
            if(curr != null)
            {
                if(!first)
                {
                    System.out.println("[" + curr.data + "]");
                    hashset.add(curr.data);
                }
                st.push(curr);
                curr = curr.left;
            }
            else
            {
                if(!first)
                    first = true;
                Node node = st.pop();
                if(node.left == null && node.right == null)
                {
                    if(!hashset.contains(node.data))
                    {
                        System.out.println("[" + node.data + "]");
                        hashset.add(node.data);
                    }
                }
                curr = node.right;
            }
        }
        //Print out the nodes in the right side of the tree
        if(root != null)
        {
            Stack<Node> stack = new Stack<Node>();
            Node right = root.right;
            while(right != null)
            {
                if(!hashset.contains(right.data))
                {
                    hashset.add(right.data);
                    stack.push(right);
                }
                right = right.right;
            }
            while(!stack.empty())
            {
                System.out.println("[" + stack.pop().data + "]");
            }
        }
    }

    public static void PostOrder(Node r)
    {
        if( r != null)
        {
            PostOrder(r.left);
            PostOrder(r.right);
            System.out.println("normal[" + r.data + "]");
        }
    }

    public static void PostorderSimple(Node root)
    {
        if(root != null)
        {
            Stack<List<Node>> st = new Stack<List<Node>>();
            
            while(root != null || !st.empty())
            {
                if(root != null)
                {
                    List<Node> list = new LinkedList<Node>();
                    list.add(0, root);
                    if(root.left != null)
                        list.add(1, root.left);
                    if(root.right != null)
                        list.add(2, root.right);

                    root = root.left;
                }
            }
        }
    }
        
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
public class BracketsMatch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
    }
    public static int[] fun()
    {
        int[] array = {1, 2};
        return array;
    }
    public static void test1()
    {
        System.out.println("test1"); 
        String str = "()";
        int index = 0;
        System.out.println(match(str, index)); 
    } 
    public static void test2()
    {
        System.out.println("test2"); 
        String str = "(}";
        int index = 0;
        System.out.println(match(str, index)); 
    } 
    public static boolean match(String str, int index){
        if(str.charAt(index) == '('){
            match(str, index+1);
        }else{
            if(index-1 < 0)
                return false;
            if(str.charAt(str.length-1-index) == '(' &&  str.charAt(index) != ')')
                return false;
        }
        return true;
    }
}
import java.util.*;
import java.math.*;
import classfile.*;

public class CarmichaelNumber{
    public static void main(String[] args) {
        test1();
    }
    //[ file=carmichaelnumber.html title=""
    public static boolean CarmichaelNumber(int n){
        for(int b=2; b<n; b++){
            if(gcd(b, n) == 1){
                BigDecimal bg = new BigDecimal(b);
                BigDecimal big = bg.pow(n-1);
                BigDecimal bgremainder = big.remainder(new BigDecimal(n));
                if(Integer.parseInt(bgremainder.toString()) != 1)
                    return false;
            }
        }
        return true;
    }
    //]
    static void test0(){
        Aron.beg();
        System.out.println("3=[" + gcd(0, 3) + "]");
        System.out.println("1=[" + gcd(2, 3) + "]");
        System.out.println("1=[" + gcd(3, 2) + "]");
        System.out.println("3=[" + gcd(3, 3) + "]");
        System.out.println("2=[" + gcd(2, 4) + "]");
        System.out.println("2=[" + gcd(6, 4) + "]");
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int carnum = 561;
        System.out.println("561 is Carmichael Number? [" + CarmichaelNumber(carnum) + "]");
        Aron.end();
    }
    public static int gcd(int a, int b){
        if(a == 0 && b > 0)
            return b;
        else if( a > 0 && b == 0){
            return a;
        }else{
            if(a >= b){
                return gcd(a-b, b);
            }else{
                return gcd(a, b-a);
            }
        }
    }
}
public class CofactorMatrix 
{
				public static void main(String[] args)
				{
								System.out.println("Hello World!");
								int[][] A = {
															{1, 2},
															{3, 4}
														};

								int[][] B = cofactor(A, 1, 1);
								for(int r = 0;  B != null && r < B.length; r++)
								{
									for(int c = 0; c < B.length; c++)
									{
										System.out.print("["+B[r][c]+"]");
									}
									System.out.println();
								}
				}
				public static int[][] cofactor(int[][] A, int row, int col)
				{
					int len = 0;
					int[][] B = null; 
					if(A != null && (len = A.length) > 0 && row < len && col < len)
					{
						B = new int[len-1][len-1];
						int r1 = 0;
						for(int r = 0; r < len; r++)
						{
							if(r != row)
							{
								int c1 = 0;
								for(int c = 0; c < len; c++)
								{
									if(c != col)
									{
										B[r1][c1] = A[r][c];
										c1++;
									}
								}
								r1++;
							}
						}
					}
					return B;
				}
}
import java.util.*;

import classfile.*;

public class CoinChange {
    public static void main(String[] args) {
        /*
        test1();
        test2();
        test3();
        test4();
        test5();
        test8();
        test8_new();
        test10();
        test11();
        test12();
        */
        //test13();

        /*
        test20();
        test7();
        test9();
        test20();
        test21();
        test22();
        */

        //test2();

        test14();
        test15();
        //test23();
    }


    //[file=dynamic.html   title=""
    public static int[][] miniCoinDynamic(int[] coin, int sum) {
        int len = coin.length;
        int[][] array = init(len, sum);

        for(int i=0; i<len; i++) {
            for(int s = 0; s <=sum; s++) {
                if( s - coin[i] >= 0) {
                    int min = Integer.MAX_VALUE;
                    for(int k=0; k <=i; k++)
                        min = Math.min(min, array[k][s-coin[i]]);
                    array[i][s] = min == Integer.MAX_VALUE ? min: min + 1;
                }
            }
        }

        // find the mini value on the most right column
        int min = Integer.MAX_VALUE;
        for(int k=0; k <len; k++)
            min = Math.min(min, array[k][sum]);
        array[len-1][sum] = min;

        return array;
    }

    public static int[][] init(int height, int width) {
        int[][] array = new int[height][width+1];
        for(int i=0; i<height; i++) {
            for(int j=0; j<width+1; j++) {
                if(j == 0)
                    array[i][j] = 0;
                else
                    array[i][j] = Integer.MAX_VALUE;
            }
        }
        return array;
    }
    //]

    //Given coins[k] = {2, 3, 4} and change s = 9
    //Count the number of way for coin change
    //coins[k] is in the each change
    //coins[k] is not in the each change
    //count(coins, k, s) = count(coins, k-1, s) + count(coins, k, s-coins[k])
    public static int count_debug(int[] coin, int s, int k) {
        if( s < 0) {
            System.out.print("<"+s+","+k+">\n");
            return 0;
        } else if( s == 0 ) {
            System.out.print("<"+s+","+k+">\n");
            return 1;
        } else if( s > 0 && k > 0) {
            System.out.print("<"+s+","+k+">->");
            int left = count(coin, s, k-1);

            System.out.print("<"+s+","+k+">->");
            int right= count(coin, s-coin[k-1], k);
            return left + right;
        } else {
            System.out.println();
            return 0;
        }
    }

    public static int miniCointWithPerm(int[] coin, int s) {
        if(s == 0)
            return 0;
        else {
            int min = 100;
            for(int i=0; i<coin.length; i++) {
                if(s - coin[i] >= 0)
                    min = Math.min(min, miniCointWithPerm(coin, s-coin[i]) + 1);
            }
            return min;
        }
    }

    // Given coins[k] = {2, 3, 4} and change s = 9
    // Count the number of way for coin change
    // coins[k] is in the each change
    // coins[k] is not in the each change
    // count(coins, k, s) = count(coins, k-1, s) + count(coins, k, s-coins[k])
    public static int count(int[] coin, int s, int k) {
        if( s < 0)
            return 0;
        else if( s == 0 )
            return 1;
        else if( s > 0 && k > 0) {
            int right= count(coin, s-coin[k-1], k);
            int left = count(coin, s, k-1);
            return left + right;
        } else
            return 0;
    }

    //Coin change algorithm using dynamic programming
    //Use table from bottom up to model the recursion tree
    public static int countdy(int[] coin, int s, int k) {
        int[][] table = new int[s+1][k];
        for(int i=0; i<k; i++)
            table[0][i] = 1;

        System.out.println();

        Aron.printTable(table);

        for(int ss=1; ss<s+1; ss++) {
            for(int kk=0; kk<k; kk++) {
                int left  = kk-1 >= 0? table[ss][kk-1]:0;

                if(kk-1 >= 0)
                    System.out.print("["+ss+"]["+(kk-1)+"]=["+left+"]\n");
                else
                    System.out.print("["+ss+"]["+(kk-1)+"]=["+0+"]\n");

                int right = ss-coin[kk] >= 0?  table[ss-coin[kk]][kk]:0;
                int col = ss-coin[kk];

                if(ss-coin[kk] >= 0)
                    System.out.print("["+col+"]["+kk+"]=["+right+"]\n");
                else
                    System.out.print("["+col+"]["+kk+"]=["+0+"]\n");

                System.out.println();

                table[ss][kk] = left + right;
            }
        }

        printTable(table);

        return table[s][k-1];
    }

    //Print out all the coins which adds up to s
    public static void permuCount(int[] coin, int[] arr, int d, int s, int sum) {
        for(int i=0; i<coin.length; i++) {
            if(sum + coin[i] == s) {
                sum += coin[i];
                arr[d] = coin[i];
                for(int j=0; j<=d; j++) {
                    System.out.print("["+arr[j]+"]");
                }
                System.out.println();
            } else if(sum + coin[i] < s) {
                arr[d] = coin[i];
                sum += coin[i];
                permuCount(coin, arr, d+1, s, sum);
                sum -= coin[i];
            }
        }
    }

    public static int minCount_debug(int[] coin, int s, int k) {
        if(s < 0)
            return 100;
        if(s == 0) {
            System.out.print("["+s+"]\n");
            return 0;
        } else if( s > 0 && k <= 0)
            return 100;
        else {
            int min=100;
            for(int i=0; i<k; i++) {
                if(s - coin[i] > 0)
                    System.out.print("["+s+"]->");
                min = Math.min(min, minCount_debug(coin, s-coin[i], k)+1);
            }
            return min;
        }
    }

    //[file=CoinChangeRecursive.html   title=""
    //CoinChange.java
    //Given coin{2, 3, 4} and s = 6
    //Find the minimum number of coins sums up to s
    public static int minCount(int[] coin, int s, int k) {
        int min = Integer.MAX_VALUE;
        if(s == 0)
            min = 0;
        else if(s > 0) {
            // min(s) = min(s-coin[k]) + 1
            for(int i=0; i<k; i++) {
                int childMin = minCount(coin, s-coin[i], k);
                if(childMin != Integer.MAX_VALUE)
                    min = Math.min(min, childMin + 1);
            }
        }
        return min;
    }
    //]


    public static int minCountAllPath(int[] coin, int s, int k, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(s == 0){
            Aron.printList(list);
            min = 0;
        }
        else if(s > 0) {
            for(int i=0; i<k; i++) {
                list.add(coin[i]);
                int childMin = minCountAllPath(coin, s-coin[i], k, list);
                if(childMin != Integer.MAX_VALUE)
                    min = Math.min(min, childMin + 1);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }

        }
        return min;
    }
    //[file=CoinChangeWithHashMap.html   title=""
    // CoinChange.java
    // Given coin{2, 3, 4} and s = 6
    // Find the minimum number of coins sums up to s
    public static int minCountWithDynamic(int[] coin, int s, int k, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(s == 0){
            min = 0;
        }
        else if(s > 0) {
            for(int i=0; i<k; i++) {
                Integer value = map.get(s-coin[i]);
                if(value == null) {
                    value = minCountWithDynamic(coin, s-coin[i], k, map, list);
                    if(value < Integer.MAX_VALUE)
                        value += 1; 
                } 

                min = Math.min(min, value);

                if(s-coin[i] < 0)
                    map.put(s-coin[i], Integer.MAX_VALUE);
                else
                    map.put(s-coin[i], min);

            }
        }
        return min;
    }
    //]

    public static int minCount_Graph(int[] coin, int s, int k, int[] arr) {
        int min = Integer.MAX_VALUE;
        if(s == 0) {
            min = 0;
        } else if(s > 0) {
            // min(s) = min(s-coin[k]) + 1
            int parent = arr[0];
            for(int i=0; i<k; i++) {
                String parentLabel = parent + "[label="+ s +"];";
                System.out.println(parentLabel);

                arr[0] += 1 + i;
                int child = arr[0] ;


                String childLabel = "";
                if( s - coin[i] == 0)
                    childLabel = child + "[label="+ (s-coin[i]) +", style=filled, fillcolor=green]";
                else if(s - coin[i] < 0)
                    childLabel = child + "[label="+ (s-coin[i]) +", style=filled, fillcolor=red]";
                else
                    childLabel = child + "[label="+ (s-coin[i]) +"];";

                System.out.println(childLabel);

                System.out.println(parent + "->" + child + "[label="+ coin[i] +"];");

                int childMin = minCount_Graph(coin, s-coin[i], k, arr);
                if(childMin != Integer.MAX_VALUE) {
                    min = Math.min(min, childMin + 1);
                }
            }
        }
        return min;
    }


    public static void printTable(int[][] arr) {
        if(arr != null) {
            for(int c=0; c<arr.length; c++) {
                for(int r=0; r<arr[0].length; r++) {
                    System.out.print("["+arr[c][r]+"]");
                }
                System.out.println();
            }
        }
        System.out.println();
    }
    public static void test1() {
        System.out.println("test1()");
        int[] recoin = {1};
        int[] dycoin = {1};
        int k = recoin.length;
        int s = 0;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test2() {
        System.out.println("test1()");
        int[] recoin = {1, 2};
        int[] dycoin = {1};
        int k = recoin.length;
        int s = 3;
        int c = count(recoin, s, k);
        System.out.println("recursion count=["+c+"]");
    }

    public static void test3() {
        System.out.println("test1()");
        int[] recoin = {1, 2};
        int[] dycoin = {1, 2};
        int k = recoin.length;
        int s = 3;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test4() {
        System.out.println("test4()");
        int[] recoin = {1, 2, 3};
        int[] dycoin = {1, 2, 3};
        int k = recoin.length;
        int s = 4;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");

    }

    public static void test5() {
        System.out.println("test5()");
        int[] recoin = {2, 3, 4};
        int[] dycoin = {2, 3, 4};
        int k = recoin.length;
        int s = 10;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println();
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");
    }




    public static void test8() {
        System.out.println("test8()");
        int[] recoin = {2, 3, 4, 5, 6};
        int[] dycoin= {2, 3, 4, 5, 6};
        int k = recoin.length;
        int s = 15;
        int c = count(recoin, s, k);
        int dc = countdy(dycoin, s, k);
        System.out.println();
        System.out.println("recursion count=["+c+"]");
        System.out.println("dynamic   count=["+dc+"]");
    }

    public static void test8_new() {
        System.out.println("test8_new()");
        int[] recoin = {2, 3, 4, 5, 6};
        int k = recoin.length;
        int s = 15;
        String count = " ";
        int min = miniCointWithPerm(recoin, s);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test9() {
        System.out.println("test9()");
        final int Num = 10;
        int[] coin = new int[Num];

        for(int i=0; i<Num; i++)
            coin[i] = 3+i;

        int s = 150;
        int[][] table = miniCoinDynamic(coin, s);
        int row = table.length;
        int col = table[0].length;
        System.out.println("min=" + table[row-1][col-1]);
    }

    public static void test10() {
        System.out.println("test10()");
        int[] coin = {1, 2};
        int s = 3;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }
    public static void test11() {
        System.out.println("test11()");
        int[] coin = {1, 2, 4};
        int s = 5;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }
    public static void test12() {
        System.out.println("test12()");
        int[] coin = {1, 2, 3, 16};
        int s = 17;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        Aron.printTable(table);
    }

    public static void test6() {
        System.out.println("test6()");
        int[] recoin = {2, 3, 4, 5, 6};
        int[] arr = new int[recoin.length+10];
        int d = 0;
        int s = 15;
        int sum = 0;
        permuCount(recoin, arr, d, s, sum);
        System.out.println();
    }

    public static void test13() {
        System.out.println("test13()");
        final int Num = 4;
        int[] coin = new int[Num];
        for(int i=1; i<Num; i++)
            coin[i] = 2*i;

        int s = 45;
        int[][] table = miniCoinDynamic(coin, s);
        System.out.println();
        // Aron.printTable(table);
    }

    public static void test14() {
        Aron.beg();
        final int Num = 14;
        int[] coin = new int[Num];

        for(int i=0; i<Num; i++)
            coin[i] = 2+i;

        int s = 45;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>(); 
        int min = minCountWithDynamic(coin, s, Num, map, list);
        System.out.println("min[" + min + "]"); 

        Aron.end();
    }
    public static void test15() {
        Aron.beg();
        final int Num = 4;
        int[] coin = new int[Num];
        for(int i=0; i<Num; i++)
            coin[i] = 2+i;

        int s = 20;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>(); 
        int min = minCountAllPath(coin, s, Num, list);
        System.out.println("min[" + min + "]"); 

        Aron.end();
    }


    public static void test7() {
        System.out.println("test7()");
        int[] coin = {2, 3, 15, 18};
        int k = coin.length;
        int s = 19;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }


    public static void test20() {
        System.out.println("test20()");
        int[] coin = {2, 3, 15, 18};
        int k = coin.length;
        int s = 20;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test21() {
        System.out.println("test21()");
        int[] coin = {2};
        int k = coin.length;
        int s = 2;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }

    public static void test22() {
        System.out.println("test22()");
        int[] coin = {2, 3, 4, 5};
        int k = coin.length;
        int s = 10;
        int min = minCount(coin, s, k);
        System.out.println("min="+min);
        System.out.println();
    }
    public static void test23() {
        int[] coin = {1, 2};
        int k = coin.length;
        int s = 3;
        int[] arr = new int[1];
        arr[0] = 100;
        System.out.println("digraph G {\n");
        int min = minCount_Graph(coin, s, k, arr);
        System.out.println("}\n");

        System.out.println();
    }
}
import java.util.Map;
import java.util.List;
import java.util.ArrayList;
import java.util.HashMap;
import classfile.*;

class CoinChange{
    Integer curr_total;
    Integer curr_bill;
    Map<Integer, Integer> map = new HashMap<Integer, Integer>();
    List<Integer> list = new ArrayList<Integer>();;
    
    public CoinChange(){
        curr_total = 0;
        curr_bill = 0;
        list.add(25);
        list.add(10);
        list.add(5);
        list.add(1);

        map.put(25, 10);
        map.put(10, 10);
        map.put(5, 10);
        map.put(1, 10);
    }
    public void insertBill(Integer bill){
        if(bill > 25){
            curr_bill = bill;
        }
    }

    public Map<Integer, Integer> withDraw(){
        Map<Integer, Integer> retMap = new HashMap<Integer, Integer>();
                for(Integer coin : list){
                    if(curr_bill > 0){
                    int quotient = curr_bill / coin;
                    if(quotient > 0){
                        Integer numCoins = map.get(coin);
                        if(quotient <= numCoins){
                            curr_bill = curr_bill - quotient*coin;
                            retMap.put(coin, quotient);
                            map.put(coin, numCoins - quotient);
                        }
                    }
            }
        }
        if(curr_bill == 0)
            return retMap;
        else
            return null;
    }
}
public class CoinMachine{
    public static void main(String[] args){
        test0();
        test1();
        test2();
    }
    
    static void test0(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(54);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }

    static void test1(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(1);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        CoinChange cc = new CoinChange();
        cc.insertBill(103);
        Map<Integer, Integer> map = cc.withDraw();
        if(map != null){

           for(Map.Entry<Integer, Integer> entry : map.entrySet()){
                System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
           }
        }
        Aron.end();
    }
}
// print all combination 0 to n-1
public class Combination 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] path = new int[3];
        int row = 0;
        combination(path, row);
        test1();
        test2();
    }
    public static void combination(int[] path, int row)
    {
        if(path != null)
        {
            if(row == path.length)
            {
                for(int r = 0; r < path.length; r++)
                {
                    System.out.print("["+path[r]+"]");
                }
                System.out.println("");
            }
            for(int col=0; col<path.length && row < path.length; col++)
            {
                path[row] = col; 
                combination(path, row+1);
            }
        }
    }
    public static void test1()
    {
        System.out.println("=================================="); 
        int[] path = {1}; 
        int row = 0;
        int len = path.length;
        combination(path, row);
    }
    public static void test2()
    {
        System.out.println("=================================="); 
        int[] path = {1, 2}; 
        int row = 0;
        int len = path.length;
        combination(path, row);
    } 
}
import java.util.*;

// Comparable
class Contact implements Comparable<Contact> {
    String name;
    String addr;
    int    age;
    public Contact(String name, String addr, int age) {
        this.name = name;
        this.addr = addr;
        this.age = age;
    }

    //Minimum heap
    public int compareTo(Contact c) {
        return this.age - c.age;
        //Maximum heap
        //return -(this.age - c.age);
    }

    public String toString() {
        return "["+name+"]["+addr+"]["+age+"]";
    }
}

class Person {
    String name;
    int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public int getAge() {
        return age;
    }

}


// Comparator
class LexicographicComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.getName().compareToIgnoreCase(p2.getName());
    }
}

class AgeComparator implements Comparator<Person> {
    public int compare(Person p1, Person p2) {
        return p1.getAge() - p2.getAge() == 0? 0 : p1.getAge() < p2.getAge() ? -1 : 1;
    }
}



public class CompareDemo {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        List<Person> listPerson = new ArrayList<Person>(
            Arrays.asList(
                new Person("David", 20),
                new Person("Ann", 19),
                new Person("Michael", 18),
                new Person("Sunny", 6)
            )
        );

        Collections.sort(listPerson, new LexicographicComparator());
        Collections.sort(listPerson, new AgeComparator());
        for(Person p: listPerson) {
            System.out.println(p.getName() + " " + p.getAge());
        }
        List<Contact> listContact = new ArrayList<Contact>(
            Arrays.asList(
                new Contact("David", "Mountain View", 20),
                new Contact("Ann", "Palo Alto", 19),
                new Contact("Michael", "RedWood City", 26)
            )
        );

        System.out.println();
        Collections.sort(listContact);
        for(Contact c: listContact) {
            System.out.println(c.name + " " + c.addr + " " + c.age);
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class Compress {
    public static void main(String args[]) {
        test0();        
        test00();        
        test1();        
        test2();        
        test3();        
        test4();        
        test5();        
        test6();        
        test7();        
        test8();        
        test9();        
        test10();        
        test11();        
    }
    //[ file=compressstr.html title=""
    public static String CompressStr(String str) {
        String ret="";
        if(str != null && str.length() > 0) {
            if(str.length() == 0 || str.length() == 1)
                ret = str;
            else {
                int c=1;
                int i=0;
                for(i=0; i<str.length()-1; i++) {
                    if(str.charAt(i) == str.charAt(i+1))
                        c++;
                    else{
                        if(c > 1) {
                            ret = ret + str.charAt(i) + c + "";
                            c=1;
                        }else{
                            ret = ret + str.charAt(i) + "";
                        }
                    } 
                }

                if(c > 1)
                    ret = ret + c	+ str.charAt(i) + "";
                else
                    ret = ret + str.charAt(i) + "";
            }
        }
        return ret;
    }

    public static String compress(String str) {
        int c = 1;
        String retStr = "";
        int i=0;
        for(; i<str.length()-1; i++) {
            if(str.charAt(i) == str.charAt(i+1)) {
                c++;
            } else {
                if(c == 1)
                    retStr += str.charAt(i) + "";
                else if(c > 1)
                    retStr += str.charAt(i) + "" + c;

                c = 1;
            }
        }

        if(c == 1)
            retStr += str.charAt(i) + "";
        else if(c > 1)
            retStr += str.charAt(i) + "" + c;

        return retStr;
    }

    public static String compress2(String str) {
        int c = 1;
        String retStr = "";
        str += "0";
        for(int i=0; i<str.length()-1; i++) {
            if(str.charAt(i) == str.charAt(i+1)) {
                c++;
            } else {
                if(c == 1)
                    retStr += str.charAt(i) + "";
                else if(c > 1)
                    retStr += str.charAt(i) + "" + c;

                c = 1;
            }
        }

        return retStr;
    }
    //]
    
    static void test0(){
        Aron.beg();
        String str="aabba";
        String ret = CompressStr(str);
        System.out.println("aabba[" + ret + "]"); 
        Aron.end();
    }

    static void test00(){
        Aron.beg();
        String str="a";
        String ret = CompressStr(str);
        System.out.println("a[" + ret + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String str="aabba";
        String ret = compress(str);
        System.out.println("aabba[" + ret + "]"); 
        Aron.end();
    }

    static void test2(){
        Aron.beg();
        String str="a";
        String ret = compress(str);
        System.out.println("a[" + ret + "]"); 
        Aron.end();
    }

    static void test3(){
        Aron.beg();
        String str="aa";
        String ret = compress(str);
        System.out.println("aa[" + ret + "]"); 
        Aron.end();
    }

    static void test4(){
        Aron.beg();
        String str="ab";
        String ret = compress(str);
        System.out.println("ab[" + ret + "]"); 
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        String str="aabbb";
        String ret = compress(str);
        System.out.println("aabbb[" + ret + "]"); 
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        String str="aabbba";
        String ret = compress(str);
        System.out.println("aabbba[" + ret + "]"); 
        Aron.end();
    }

    static void test7(){
        Aron.beg();
        String str="a";
        String ret = compress2(str);
        System.out.println("compress2 a[" + ret + "]"); 
        Aron.end();
    }
    static void test8(){
        Aron.beg();
        String str="aa";
        String ret = compress2(str);
        System.out.println("compress2 aa[" + ret + "]"); 
        Aron.end();
    }
    static void test9(){
        Aron.beg();
        String str="abbb";
        String ret = compress2(str);
        System.out.println("compress2 abbb[" + ret + "]"); 
        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str="aabbbc";
        String ret = compress2(str);
        System.out.println("compress2 aabbbc[" + ret + "]"); 
        Aron.end();
    }

    static void test11(){
        Aron.beg();
        String str="";
        String ret = compress2(str);
        System.out.println("compress2 empty_str[" + ret + "]"); 
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Compress2
{
	public static void main(String args[])
	{
		String str="aaaaa";
		String ret = Compress2(str);
		System.out.println("str=" + ret);
	}
	public static String Compress2(String str) 
	{
		String ret="";
		if(str != null)
		{
			int len=str.length();
			if(len > 0)
			{ int c=1; int i=0;
				for(i=0; i<len-1; i++)
				{ if(str.charAt(i) == str.charAt(i+1))
						c++;
					else 
					{
						if(c>1)
							ret = ret + c + str.charAt(i);
						else 
							ret = ret + str.charAt(i);
						c=1;
					}
				}
				if(c>1)
					ret = ret + c + str.charAt(i);
				else 
					ret = ret + str.charAt(i);
			}
		}
		return ret;
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class ConnectedIsland {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        //test0_maxWords();
        test1_maxWords();
        test2_maxWords();
        test3_maxWords();
        test4_maxWords();
        test5_maxWords();

        test00_maxWords();
        test01_maxWords();
        test02_maxWords();
    }

    //[file=connectedisland.html title=""
    // 2:41 - 3:12
    //--------------------------------------------------------------------------------
    // [0, 1, 1, 0]
    // [0, 1, 0, 0]
    // [1, 0, 0, 1]
    // [1, 0, 1, 0]
    //
    //--------------------------------------------------------------------------------
    // w = 0, h = 0, width = 4, height = 4
    // arr[0][0] = 0
    // arr[0][1] = 1
    // arr[0][2] = 1
    // arr[0][3] ret
    // arr[0][1] = 2 ret
    // arr[-1][1] = ret
    // w = 0, h = 0
    public static int countConnection(int[][] arr, int w, int width, int h, int height) {
        if(arr != null) {
            if(arr[h][w] == 1) {
                arr[h][w] = 2;
                int right = 0, left = 0, up = 0, down = 0;
                if(w + 1 < width)
                    right =countConnection(arr, w+1, width, h, height);
                if(w - 1 >= 0)
                    left = countConnection(arr, w-1, width, h, height);
                if(h - 1 >= 0)
                    up =   countConnection(arr, w, width, h-1, height);
                if(h + 1 < height)
                    down = countConnection(arr, w, width, h+1, height);

                return right + left + up + down + 1;
            }
        }
        return 0;
    }
    public static int maxConnection(int[][] arr) {
        int max = 0;
        if(arr != null) {
            int height = arr.length;
            int width = arr[0].length;
            for(int h=0; h<height; h++) {
                for(int w=0; w<width; w++) {
                    int m = countConnection(arr, w, width, h, height);
                    if(m > max)
                        max = m;
                }
            }
        }
        return max;
    }
    //]
    public static void test0() {
        Aron.beg();

        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
            {1, 0, 0, 0},
            {1, 1, 0, 0},
            {1, 1, 0, 1},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        int[][] arr2d = {
            {0}
        };
        int max = maxConnection(arr2d);
        Test.t(max, 0);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        int[][] arr2d = {
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 0);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();

        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 1, 1, 0},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 4);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();

        int[][] arr2d = {
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {1, 0, 0, 1},
            {1, 1, 1, 1},
        };
        int max = maxConnection(arr2d);
        Test.t(max, 10);

        Aron.end();
    }

    public static boolean isWord(String s) {
        String[] arr = {
            "a",
            "b",
            "e",
            "ill",
            "ball",
            "app",
            "ban",
            "cat",
            "banana",
            "ancestor",
            "scene",
            "descend",
            "descended",
            "sibling",
            "dangling"
        };
        Set<String> set = new HashSet<>(Arrays.asList(arr));
        return set.contains(s);
    }
    public static void test0_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'a', 'n', 'a'},
            {'a', 'p', 'e', 'n'},
            {'a', 'p', 'p', 'a'},
            {'d', 'a', 'n', 'g'},
            {'a', 'p', 'k', 'k'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test1_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test2_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a', 'b'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test3_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'a', 'p', 'p'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test4_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'a', 'n'},
            {'a', 'n', 'a'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test5_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'e', 'e'},
            {'a', 'l', 'i'},
            {'l', 'n', 'l'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<String> set = new HashSet<>();
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        int w = 0, h = 0;

        maxWords(set, uniqueSet, word, arr, h, height, w, width);
        Aron.printSet(set);
//        for(int h=0; h<height; h++){
//            for(int w=0; w<width; w++){
//                Aron.printSet(set);
//            }
//        }
        Aron.end();
    }
    public static void test00_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b'},
            {'e'},
        };
        //public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int w, int h, int width, int height){
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];
        //int w = 0, h = 0;

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }
        Aron.end();
    }
    public static void test01_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'i', 'e', 'f'},
            {'e', 'k', 'l', 'l'},
        };
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }

        Aron.end();
    }
    public static void test02_maxWords() {
        Aron.beg();
        Character[][] arr = {
            {'b', 'i', 'p', 'f'},
            {'e', 'k', 'p', 'l'},
            {'k', 'a', 'l', 'l'},
        };
        Set<Integer> uniqueSet = new HashSet<>();
        StringBuffer word = new StringBuffer();

        int height = arr.length;
        int width = arr[0].length;
        boolean[][] visited = new boolean[height][width];

        for(int h=0; h<height; h++){
            for(int w=0; w<width; w++){
                Set<String> set = new HashSet<>();
                maxWords(set, uniqueSet, word, arr, h, height, w, width);
                Aron.printSet(set);
            }
        }

        Aron.end();
    }


    //
    // 3:23 4:49 5:19
    // word = "";
    public static void maxWords(Set<String> set, Set<Integer> uniqueSet, StringBuffer word, Character[][] arr, int h, int height, int w, int width) {
        word.append(arr[h][w]);
        int index = h*width + w;
        if(!uniqueSet.contains(index)) {
            uniqueSet.add(index);

            if(isWord(word.toString()))
                set.add(word.toString());

            if(w + 1 < width) {
                maxWords(set, uniqueSet, word, arr, h, height, w + 1, width);
            }

            if(w - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h, height, w - 1, width);
            }

            if(h + 1 < height) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w, width);
            }

            if(h - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w, width);
            }

            if(w + 1 < width && h + 1 < height) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w + 1, width);
            }

            if(w - 1 >= 0 && h - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w - 1, width);
            }

            if(h + 1 < height && w - 1 >= 0) {
                maxWords(set, uniqueSet, word, arr, h + 1, height, w - 1, width);
            }

            if(h - 1 >= 0 && w + 1 < width) {
                maxWords(set, uniqueSet, word, arr, h - 1, height, w + 1, width);
            }
            uniqueSet.remove(h*width + w);
        }
        if(word.length() > 0)
            word.deleteCharAt(word.length()-1);
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

public class ConnectedIslandNew{
    public static void main(String[] args) {
//        test0();
//        test1();
//        test2();
        test_count8_0();
        test_count8_1();
        test_count8_2();
        test_count8_3();
    }
    public static void test0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   0,  1},
            { 1,   1,   0,  1},
            { 0,   1,   0,  1},
            { 0,   1,   1,  0},
        };
          
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Print.pbl(max);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        for(int j=-1; j<=1; j++){
            for(int i=-1; i<=1; i++){
                Print.pbl(j + " " + i);
            } 
        }
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 0,   0,   0,  0},
            { 0,   0,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 2);
        Aron.end();
    }
    public static void test_count8_0(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 0,   0,   0,  0},
            { 0,   0,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 2);
        Aron.end();
    }
    public static void test_count8_1(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  0},
            { 1,   1,   0,  0},
            { 1,   1,   0,  0},
            { 1,   1,   0,  1},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 7);
        Aron.end();
    }
    public static void test_count8_2(){
        Aron.beg();
        int[][] arr2d = {
            { 0,   0,   1,  1},
            { 0,   1,   0,  0},
            { 0,   0,   0,  1},
            { 1,   1,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 3);
        Aron.end();
    }
    public static void test_count8_3(){
        Aron.beg();
        int[][] arr2d = {
            { 1,   0,   1,  1},
            { 0,   1,   0,  0},
            { 1,   0,   1,  1},
            { 0,   1,   0,  0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int h = 0, w = 0;
       
        int max = 0;
        for(int i=0; i<height; i++){
            for(int j=0; j<width; j++){
                int num = count8(arr2d, i, j, height, width);
                Print.pbl(num);
                max = num > max ? num : max;
            }
        } 
        Test.t(max, 8);
        Aron.end();
    }

    // *connected_island* *island*
    public static int count(int[][] arr, int h, int w, int height, int width){
        if(arr[h][w] == 1){
            arr[h][w] = 2;
            int n1 = 0, n2 = 0, n3 = 0, n4 = 0;
            if(h + 1 < height)
                n1 = count(arr, h+1, w, height, width);
            if(h - 1 >= 0)
                n2 = count(arr, h-1, w, height, width);
            if(w + 1 < width)
                n3 = count(arr, h, w+1, height, width);
            if(w - 1 >= 0)
                n4 = count(arr, h, w-1, height, width);

            return n1 + n2 + n3 + n4 + 1;
        }
        return 0;
    }

    //
    // east, west, north, south, east/noth, north/west, west/south, south/east
    // 8 direction *8direction* *9direction* *9direct* 
    public static int count8(int[][] arr, int h, int w, int height, int width){
        int s = 0;
        if(arr[h][w] == 1){
            arr[h][w] = 2;
            for(int hh=-1; hh<=1; hh++){
                for(int ww=-1; ww<=1; ww++){
                    if(hh != 0 || ww != 0){
                        if(
                            (h + hh >= 0 && h+hh < height) && 
                            (w + ww >= 0 && w+ww < width) 
                            ) 
                        s +=count8(arr, h+hh, w+ww, height, width); 
                    }
                }
            }
            s += 1;
        }
        return s;
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Power 
{
	public static void main(String args[])

	  int[] A={2, 3, 3, 2,3,4};
		Co(A);
	}
	public static boolean  Co(int[] A)
	{
		int c=1;
		int max=1;
		int num=A[0];
		for(int i=0; i<A.length-1; i++)
		{
			if(A[i] == A[i+1])
			{
				c++;
				if(c > max)
				{
					max=c;
					num = A[i];
				} 
			}
			else
			{
				c--;
				if(c=0)
				{
					c=1;
				}
			}
		}
		System.out.println("max=" + max);
		System.out.println("num=" + num);
	}

}
import java.io.*;
import java.lang.String;
import java.util.*;
class CountNBit 
{
	public static void main(String args[])
	{
		CountNBit(32);
		System.out.println();
		int n = CountNBit(10);
		System.out.println("n=" + n);
	}

	public static int CountNBit(int n)
	{
		/*
		for(int i=0; i<n; i++)
		{
			String bin = Integer.toBinaryString(i);
			System.out.println(String.format("%5s", bin));
		}
		*/
		
		if(n==0)
			return 0;
		else if(n==1)
			return 1;
		else 
		{

			//a/2*x: half of column are 1
			//a is 2^floor(logn)
			//x = floor(logn)
			//
			//F(n-a): the number of 1 bit from 1 - 2^floor(logn)
			//
			//n-a+1 is the number of MSB from 2^floor(logn)-n
			//
			//F(n) = a/2*x + F(n-a) + n-a+1
			//
			int x = (int)Math.floor((double)Math.log(n)/(double)Math.log(2));
			int a = (int)Math.pow(2, x);
			return (a/2)*x + CountNBit(n-a) + (n-a+1);
		}
		
		
		
	}
}
public class CountOccurrences {
    public static void main(String[] args) {
        // write your code here
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    static void test0(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("a", "a");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    }
    static void test1(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aa", "a");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    }
    static void test2(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aaa", "aa");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 

    static void test3(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aacaaa", "aa");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 
    static void test4(){
        System.out.println("---------------------------------\n");
        int num = countOccurrences("aaccacc", "ac");
        System.out.println("[" + num + "]");
        System.out.println("---------------------------------\n");
    } 

    //[ file=countoccurrence.html title=""
    // count prefix occurrence
    static int countOccurrences(String str, String pattern){
        int count = 0;
        if(str == null || pattern == null)
            return 0;
        else if(str.length() == 0 || pattern.length() == 0)
            return 0;
        else {
            int start = 0;
            int k = 0;
            int len = pattern.length();
            int i = 0;
            while(i < str.length()){
                if(str.charAt(i) == pattern.charAt(k)){
                    if(k == 0)
                        start = i;
                    k++;
                    if(k == len){
                        count++;
                        k = 0;
                        i = start + 1;
                    }else{
                        i++;
                    }
                }else{
                    k = 0;
                    i = start + 1;
                    start++;
                }
            }
        }
        return count;
    }
    //]

}
import java.util.*;
import classfile.*;

public class Database {
  public static class Table {
    private final String name;
    private final String[] columnNames;
    private final List<List<Object>> data;

    public Table(String name, String[] columnNames, List<List<Object>> data) {
      this.name = name;
      this.columnNames = columnNames;
      this.data = data;
    }

    public void insert(Object[] row) {
      data.add(Arrays.asList(row));
    }

    public String getName() {
      return name;
    }

    public String[] getColumnNames() {
      return columnNames;
    }

    public List<List<Object>> getData() {
      return data;
    }

    public Table select(String[] projectedColumnNames) {
      // IMPLEMENT ME
      Aron.printList2d(data);
      for(List<Object> list : data){
        for(String cn : projectedColumnNames){
        }
      }
      return new Table("Select", null, null);
    }

    public Table where(String cName, Object value) {
      // IMPLEMENT ME
      int columnInx= 0;
      for(columnInx=0; columnInx<columnNames.length; columnInx++){
          if(columnNames[columnInx].equals(cName)){
              Print.p("columnInx=" + columnInx);
              break;
          }
      }

     Table tab = null;
     for(List<Object> ll : data){
         if(ll.get(columnInx).equals(value)){
             Print.p("columnInx.intValue()=" + value);

             List<List<Object>> rowList = new ArrayList<List<Object>>();
             rowList.add(ll);

             tab = new Table("dog", columnNames, rowList);
             break;
         }
     }

      // return new Table(getName(), null, null);
      return tab; 
    }

    @Override
    public String toString() {
      StringBuffer sb = new StringBuffer(String.join(", ", columnNames)).append("\n");
      for (List<Object> row : data) {
        if (row.size() != 0) {
          Object value = row.get(0);
          sb.append(value == null ? "" : value.toString());
          for (int i = 1; i < row.size(); i++) {
            value = row.get(i);
            sb.append(", ").append(value == null ? "" : value.toString());
          }
        }
        sb.append("\n");
      }
      return sb.toString();
    }
  }

  private final Map<String, Table> tableMap;

  public Database() {
    this.tableMap = new HashMap<String, Table>();
  }

  public void addTable(Table table) {
    this.tableMap.put(table.getName(), table);
  }

  public Table getTable(String tableName) {
    return tableMap.get(tableName);
  }

  public Table innerJoin(Table leftTable, String leftTableKeyName, Table rightTable, String rightTableKeyName) {
    // IMPLEMENT ME
    return new Table("InnerJoin", null, null);
  }

  public static void main(String[] args) {
    Table departmentTable = new Table("departments", new String[]{"id", "name"}, new ArrayList<List<Object>>());
    departmentTable.insert(new Object[] {0, "engineering"});
    departmentTable.insert(new Object[] {1, "finance"});

    Table userTable = new Table("users", new String[]{"id", "department_id", "name"}, new ArrayList<List<Object>>());
    userTable.insert(new Object[] {0, 0, "Ian"});
    userTable.insert(new Object[] {1, 0, "John"});
    userTable.insert(new Object[] {2, 1, "Eddie"});
    userTable.insert(new Object[] {3, 1, "Mark"});

    Table salaryTable = new Table("salaries", new String[]{"id", "user_id", "amount"}, new ArrayList<List<Object>>());
    salaryTable.insert(new Object[] {0, 0, 100});
    salaryTable.insert(new Object[] {1, 1, 150});
    salaryTable.insert(new Object[] {2, 1, 200});
    salaryTable.insert(new Object[] {3, 3, 200});
    salaryTable.insert(new Object[] {4, 3, 300});
    salaryTable.insert(new Object[] {5, 4, 400});

    Database db = new Database();
    db.addTable(departmentTable);
    db.addTable(userTable);
    db.addTable(salaryTable);

    // should print
    // id, department_id, name
    // 1, 0, John
    //
    // select id, department_id, name from users where id = 1
    //
    //System.out.println(db.getTable("users").where("id", 1).select(new String[] {"id", "department_id", "name"}));
    
    Table table = db.getTable("users");
    Print.p(table.getName());
    Table wtable = table.where("id", 1);
    Print.p(wtable.getName());
    Aron.printArray(wtable.columnNames);
    Aron.printList2d(wtable.data);
    wtable.select(new String[]{"name"});

    // should print
    // users.name, departments.name
    // Ian, engineering
    // John, engineering
//    System.out.println(
//        db.innerJoin(db.getTable("users"), "department_id", db.getTable("departments"), "id")
//            .where("departments.name", "engineering")
//            .select(new String[]{"users.name", "departments.name"}));
  }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Card
{
	String suits;
	int rank;
	public Card(int rank, String suits)
	{ this.suits = suits; this.rank = rank;}
}
class Deck
{
	final int SIZE=52;
	Card[] deck = null;
	public Deck()
	{
		int c=0;
		deck = new Card[52];
		if( deck != null)
		{
			for(int i=0; i<13; i++)
			{
				deck[c++] = new Card(i+1, "Diamonts");		
				deck[c++] = new Card(i+1, "Clubs");		
				deck[c++] = new Card(i+1, "Hearts");		
				deck[c++] = new Card(i+1, "Spades");		
			}
		}
		System.out.println("c="+c);
	}
	public void Shuttle()
	{
		Random ran = new Random();
		for(int i=0; i<SIZE; i++)
		{
			int r = ran.nextInt(SIZE);
			System.out.println("r="+r);
			Card tmp = deck[r];	
			deck[r] = deck[SIZE-1-i];
			deck[SIZE-1-i] = tmp;
		}
	}
	public void show()
	{
		for(int i=0; i<SIZE; i++)
		{
			System.out.print(deck[i].suits+" "+deck[i].rank+" ");
			if( (i+1)%4==0)
				System.out.println();
		}
	}

}
class DeckCard 
{
	public static void main(String args[])
	{
		Deck d = new Deck();
		d.Shuttle();
		d.show();
	}
}
public class DepthTree 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int depth(Node r)
    {
        return 0;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
public class Dequeue{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        Deque<Node> queue = new ArrayDeque<Node>();
        queue.add(new Node(1));
        queue.add(new Node(2));
        System.out.println("size[" + queue.size() + "]"); 
        queue.poll();
        System.out.println("size[" + queue.size() + "]"); 

        Aron.end();
    }
} 
public class DiagonalMatrix 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[][] Array = {
                        {1, 2, 3},
                        {4, 5, 6},
                        {7, 8, 9}
                        };
        for(int i=0; i<Array.length; i++)
        {
            for(int j=0; j<Array[0].length; j++)
            {
                System.out.print("["+Array[i][j]+"]");
            }
            System.out.println("");
        }
        System.out.println("");
        DiagonalMatrix(Array);
        System.out.println("");
        DiagonalMatrixAll(Array);
    }
    public static void DiagonalMatrix(int[][] matrix)
    {
        if(matrix != null)
        {
            int rowLen = matrix.length;
            if(matrix[0] != null)
            {
                int colLen = matrix[0].length;
                for(int i=0; i<rowLen; i++)
                {
                    for(int j=0; j<colLen; j++)
                    {
                        if(j-i >= 0)
                            System.out.print("["+matrix[j][j-i]+"]");
                        else
                            System.out.print("[ ]");
                    }
                    System.out.println("");
                }
            }
        }
    }
    public static void DiagonalMatrixAll(int[][] matrix)
    {
        if(matrix != null)
        {
            int rowLen = matrix.length;
            if(matrix[0] != null){
                int colLen = matrix[0].length;
                for(int i=0; i<rowLen; i++){
                    for(int j=0; j<colLen; j++){
                        if(j==j+i){
                            System.out.print("["+matrix[j][j+i]+"]");
                        }
                        else{
                            if(i%2 == 1){
                                if(j+i < colLen)
                                    System.out.print("["+matrix[j][j+i]+"]");
                                else
                                    System.out.print("[ ]");
                            }
                            else{
                                if(j-i >= 0)
                                    System.out.print("["+matrix[j][j-i]+"]");
                                else 
                                    System.out.print("[ ]");
                            }
                        }
                    }
                    System.out.println(" ");
                }
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import classfile.*;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 

class DoubleLinkedList_test{
    public static void main(String args[]) {
        test0();
        test_addFirst();
        test_addNext();
        test_delete_first();
        test_delete_middle();
        test_delete_last();
        test_delete_one();
        test_delete_none();
    }
    
    static void test0(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        
        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 3);
        Test.t(list.get(1).data, 4);
        Test.t(list.get(2).data, 5);

        Aron.end();
    }
    static void test_addFirst(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.append(p2);

        Node firstNode  = new Node(9);
        dll.addFirst(firstNode);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 9);
        Test.t(list.get(1).data, 3);
        Test.t(list.get(2).data, 4);

        Aron.end();
    }
    static void test_addNext(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.append(p2);

        Node nextNode = new Node(9);
        dll.addNext(p1, nextNode);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.get(0).data, 3);
        Test.t(list.get(1).data, 9);
        Test.t(list.get(2).data, 4);

        Aron.end();
    }

    static void test_delete_last(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);

        dll.delete(p3);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 3);
        Test.t(list.get(1).data == 4);

        Aron.end();
    }
    static void test_delete_first(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        dll.delete(p1);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 4);
        Test.t(list.get(1).data == 5);

        Aron.end();
    } 
    static void test_delete_middle(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        Node p3 = new Node(5);
        dll.append(p1);
        dll.append(p2);
        dll.append(p3);
        dll.delete(p2);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 2);
        Test.t(list.get(0).data == 3);
        Test.t(list.get(1).data == 5);

        Aron.end();
    } 

    static void test_delete_one(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        dll.append(p1);
        dll.delete(p1);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 0);

        Aron.end();
    } 

    static void test_delete_none(){
        Aron.beg();

        DoubleLinkedList dll = new DoubleLinkedList();
        Node p1 = new Node(3);
        Node p2 = new Node(4);
        dll.append(p1);
        dll.delete(p2);

        List<Node> list = new ArrayList<Node>(); 
        dll.toList(list); 
        Test.t(list.size() == 1);
        Test.t(list.get(0).data == 3);

        Aron.end();
    } 
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 

//[ file=eightqueen.html title=""
// n queens problem
class Queen{
    List<Move> list = new ArrayList<>();
    private int width = 4;
    public Queen(int width){
        this.width = width;
    }

    class Move{
        public int c;
        public int r;
        public Move(int c, int r){
            this.c = c;
            this.r = r;
        }
    }

    // int c = 0;
    public void queenSolver(int c){
        if(c == width){
            for(Move m:list){
                Print.p("[" + m.c + "," + m.r + "]");
            }
            Ut.l();
        }else{
            for(int r=0; r<width; r++){
                if(isValidMove(c, r)){
                    list.add(new Move(c, r));
                    queenSolver(c+1);
                    list.remove(list.size()-1);
                }
            }
        }
    }
    public boolean isValidMove(int c, int r){
        for(Move m : list){
            if(m.r == r || Math.abs(m.c - c) == Math.abs(m.r - r))
                return false;
        }
        return true;
    }
}
//]

public class EightQueen{
    public static void main(String[] args) {
        test0();
        test1();
    }
    
    static void test0(){
        Aron.beg();
        Queen q = new Queen(4);
        int c = 0;
        q.queenSolver(c);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

// <enum>enum class example</enum>
// *j_enum_example* *jenum_example*
enum MyType {
    NUM(3),
    ROW(4);
    int value;
    MyType(int value) {
        this.value=value;
    }
    int Value() {
        return this.value;
    }
}

enum DAY{
    SUNDAY,
    MONDAY,
    TUESDAY,
    WEDNESDAY,
    THURSDAY,
    FRIDAY,
    SATURDAY
}

public class EnumExample {
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        Print.pbl("NUM=" + MyType.NUM.Value());
        Print.pbl("NUM=" + MyType.ROW.Value());
        Aron.end();
    }
    static void test1(){
        Aron.beg();

        getDay(DAY.SUNDAY);
        getDay(DAY.MONDAY);

        Aron.end();
    }
    public static void getDay(DAY day){
        if (day == DAY.SUNDAY){
            Print.pbl("sunday");
        }else if( day == DAY.MONDAY){
            Print.pbl("monday");
        }

    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class EvaluateExpr {
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0() {
        Aron.beg();
        String str = "( 1 + 2 )";
        int sum = evaluate(str);
        Test.t(sum == 3);
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        String str = "( 1 - 2 )";
        int sum = evaluate(str);
        Test.t(sum == -1);
        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        String str = "( 1 - ( 2 - 4 ) )";
        int sum = evaluate(str);
        Test.t(sum == 3);
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        String str = "( 1 - ( ( 2 - 4 ) + 3 ) )";
        int sum = evaluate(str);
        Test.t(sum == 0);
        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        String str = "( 1 )";
        int sum = evaluate(str);
        Test.t(sum == 1);
        Aron.end();
    }
    public static void test10() {
        Aron.beg();
        String str = "12";
        boolean isNum = str.matches("[0-9]+");
        Print.pbl(isNum);

        str = "a12";
        isNum = str.matches("[0-9]+");
        Print.pbl(isNum);
        Aron.end();
    }
    // iterate the in order traversal  
    public static int evaluate(String str) {
        int sum = 0;
        Stack<Integer> operandStack = new Stack<Integer>();
        Stack<String> operatorStack = new Stack<String>();

        String[] arr = str.split("\\s+");
        for(String s : arr){
            if(Aron.isNumeric(s)) {
                operandStack.push(Integer.parseInt(s));
            } else if(s.equals("+") || s.equals("-")) {
                operatorStack.push(s);
            } else if(s.equals(")")) {
                if(operatorStack.size() > 0 && operandStack.size() > 1) {
                    String op = operatorStack.pop();
                    int right = operandStack.pop();
                    int left  = operandStack.pop();
                    if(op.equals("+")) {
                        operandStack.push(left + right);
                    } else if(op.equals("-")) {
                        operandStack.push(left - right);
                    } else
                        Print.pbl("Expression Error");
                }
            }
        }
        Aron.printArray(arr);
        return operandStack.peek();
    }
}

import java.util.*;
import classfile.*;

public class ExcelColumnNumber{
    public static void main(String[] args) {
        System.out.println("Print all permuation character with repeating character!");
        String s = "ABC";
        char[] array = new char[s.length()];
        int depth = 0;
        Set<Character> map = new LinkedHashSet<Character>();
        //permRepeated(s, array, depth);
        //perm(s, array, depth, map);

        int[] arr = new int[1];
        int num = 20;
        arr[0] = 1;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i, arr, num);

        ExcelSheetRowNumberDirect(1);
        System.out.println("================");
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test11_printBinary();

        test00_ExcelSheetRowNumberDirect();
    }
    
    static void test00_ExcelSheetRowNumberDirect(){
        Aron.beg();
        int num = 1;
        Print.p("num=" + num);
        ExcelSheetRowNumberDirect(num);

        num = 26;
        Print.p("num=" + num);
        ExcelSheetRowNumberDirect(num);

        Aron.end();
    }
    static void test11_printBinary(){
        Aron.beg();

        Test.t(printBinary(0), "0"); 
        Test.t(printBinary(1), "1"); 
        Test.t(printBinary(2), "10"); 
        Test.t(printBinary(3), "11"); 
        Test.t(printBinary(4), "100");

        Aron.end();
    } 

    public static void test5() {
        System.out.println("test5");
        String prefix = "";
        int nBits = 1;
        int count = 0;
        int height = 1;
        nBitsBinaryString("", nBits, count, height);
    }
    public static void test6() {
        System.out.println("test6");
        String prefix = "";
        int nBits = 2;
        int count = 0;
        int height = 2;
        nBitsBinaryString("", nBits, count, height);
    }
    public static void test7() {
        System.out.println("test7");
        String prefix = "";
        int nBits = 3;
        int count = 0;
        int height = 4;
        nBitsBinaryString("", nBits, count, height);
    }

    public static void nBitsBinaryString(String prefix, int nBits, int count, int height) {
        if(count == nBits && height == 0)
            System.out.println(prefix);
        else if(height > 0) {
            nBitsBinaryString(prefix + "0", nBits, count, height-1);
            nBitsBinaryString(prefix + "1", nBits, count+1, height-1);
        }
    }
    /*
    public static void permrepeating(String str, String permStr, int k, int h){
        int len = array.length;
        if(permStr.length() == k){
            System.out.println(permStr);
        }
        else{
            for(int i=0; i<len; i++){
                String s = str.charAt(i) + "";
                permrepeating(str, permStr + s, k, h+1);
            }
        }
    }
    */
    public static void test1() {
    }
    public static void test2() {
        ExcelSheetRowNumberDirect(1000000);
    }

    public static void test3() {
        int n = ExcelSheetStringToInteger("A");
        System.out.println("A=" + n);

        n = ExcelSheetStringToInteger("Z");
        System.out.println("Z=" + n);


        n = ExcelSheetStringToInteger("AA");
        System.out.println("AA=" + n);
        n = ExcelSheetStringToInteger("AB");
        System.out.println("AB=" + n);
    }

    public static void test4() {
        String str = ExcelSheetIntergeToString(1);
        System.out.println("1=" + str);

        str = ExcelSheetIntergeToString(2);
        System.out.println("2=" + str);

        str = ExcelSheetIntergeToString(26);
        System.out.println("26=" + str);

        str = ExcelSheetIntergeToString(28);
        System.out.println("28=" + str);
    }

    // 1 -> 0 -> 'A'
    // 2 -> 1 -> 'B'
    // 3 -> 2 -> 'C'
    // 26->25 -> 'Z'
    // 27->26 -> 'AA'

    public static String ExcelSheetIntergeToString(int n) {
        String ret = "";
        char[] array = new char[26];
        for(int i=0; i<26; i++)
            array[i] = (char)((int)'A' + i);

        if( n-1 == 0)
            ret = array[n-1] + "";
        else {
            while(n > 0) {
                int rem = (n-1) % 26;
                n = (n-1) / 26;
                ret = (char)array[rem] + "" + ret;
            }
        }
        return ret;
    }
    // 'A' -> 0 -> 1
    // 'B' -> 1 -> 2
    // 'C' -> 2
    // 'Z' -> 25
    // 'AA'-> 26 ->27
    // (a % m) = x
    // 1 % m = y
    // (a + 1) % m  = x + y
    //
    public static int ExcelSheetStringToInteger(String str) {
        int sum = 0;
        if(str != null) {
            int len = str.length();
            for(int i=0; i<len; i++) {
                int n = str.charAt(len-1-i) - 'A' + 1;
                sum += (int)Math.pow(26, i)*n;
            }
        }
        return sum;
    }

    //Calculate the excel sheet row number directly
    //   s = 26^1 + 26^2 + 26^3 + ... + 26^k
    // 26s = 26^2 + 26^3 + 26^4 + ... + 26^(k+1)
    // 25s = 26^(k+1) - 26
    // 25s + 26 = 26^(k+1)
    // log(25s+26)/log(26) = k+1
    // log(25s+26)/log(26)-1 = k
    public static void ExcelSheetRowNumberDirect(int num) {
        int k = (int)(Math.log(25*num + 26)/Math.log(26)) - 1;
        int diff = num - (int)(Math.pow(26, k+1) - 26)/25;
        int[] arr = new int[26];

        Print.p(k);
        Print.p("diff=" + diff);

        for(int i=0; i<26; i++)
            arr[i] = 'a'+i;

        int n = diff;
        if(diff == 0)
            n = num;

        while(n > 0) {
            int r = (n-1) % 26;
            Print.p((char)arr[r]);
            n /= 26;
        }
        System.out.println();
    }
    //print excel sheet row number algorithm based on permutation
    public static void ExcelSheetRowNumber(String s, int num) {
        int[] arr = new int[1];
        arr[0] = 1;
        char[] array = new char[s.length()];
        int depth = 0;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i, arr, num);
    }


    //Given string character array and integer k,
    //print all permutation with repeatation string length k
    public static void permRepeatedChooseK(String s, char[] array, int depth, int k, int[] arr, int num) {
        if(depth == k) {
            if(arr[0] == num)
                System.out.print("<"+num+">");
            System.out.print("{"+arr[0]+"}");
            arr[0]++;
            for(int i=0; i<depth; i++) {
                System.out.print("["+array[i]+"]");
            }
            System.out.println();
        } else {
            for(int i=0; i<s.length(); i++) {
                array[depth] = s.charAt(i);
                permRepeatedChooseK(s, array, depth+1, k, arr, num);
            }
        }
    }
    
    //[ file=headertonumber.html title=""
    static int excelNum(String header){
        int sum = 0;
        if(header != null){
            int len = header.length(); 
            for(int i=0; i<len; i++){
                int n = header.charAt(len-1 - i) - 'A' + 1;
                sum += n*Math.pow(26, i);
            }
        }
        return sum;
    }
    //]

    //[ file=numbertoheader.html title=""
    // 0 -> 'A'
    // 1 -> 'B'
    // 25 -> 'Z'
    // num = 1 -> 'A'
    // num = 26 -> 'A' + 25 = 'Z'
    // num = 27
    // reminder = 0 -> 'A'
    // num = 1
    // reminder = 0 -> 'A'
    // num = 52
    // (52 - 1) % 26 = 25 -> 'Z'
    // 52 / 26 = 2
    //  x = ['A' - 'Z'] - 'A'
    //  x = [0 ... 25]
    //  
    //  n = x + 1
    //  sum = (x + 1)*pow(26, 2) + (x + 1)*pow(26, 1) + (x+1)*pow(26, 0)
    static String numToHeader(int num){
        String str = "";
        while(num > 0){
            int reminder = (num - 1) % 26;
            char ch = (char)(reminder + 'A');
            str = ch + "" + str;
            num = (num - 1) / 26;
        }
        return str;
    }
    //]

    static String printBinary(int n){
        String str = "";
        if( n == 0)    
            str += "0";
        else{     
            while(n > 0){
                int reminder = n % 2;
                str = (reminder + "") + str;
                n /= 2;
            }
        }
        return str;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class ExcelNumberBinary{
    public static void main(String[] args) {
        test1();
        test3();

        test0_excel();
        test1_excel();
        test2_excel();

        test0_printExcel();
        test1_printExcel();
        test2_printExcel();
    }
    public static void test0() {
        Aron.beg();
        String str = intToAlphabet(0);
        Print.pb(str);
        Aron.end();
    }
    public static String intToAlphabet(int n) {
            int num = (int)'a' + n;
            char ch = (char)num;
            return "" + ch;
    }
    public static void test1() {
        Aron.beg();
        int num = 16;
        printAllBinary(num);
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        int num = 17;
        printAllBinary(num);
        Aron.end();
    }

    //[ file=printbin.html title=""
    /**
    * print all binary from zero to num-1 with length log2(num)
    * @param num maximum number 
    */
    public static void printAllBinary(int num) {
        String str = "";
        int binLen = (int)Math.ceil(Math.log(num)/Math.log(2));

        for(int j=0; j<num; j++){
            int n = j;
            for(int i=0; i<binLen; i++){
                if(n % 2 == 0)
                    str = "0" + str;
                else
                    str = "1" + str;

                n = n/2;
            } 
            Print.pbl(str);
            str = "";
        } 
    }
    //]


    //[ file=binexcel.html title=""
    // [1 -> 26] = ['A' -> 'Z']
    // [0 -> 25]   ['A' -> 'Z'] 
    public static void excelNumSaveLength(int num) {
        int binLen = 1;
        if(num == 1) 
            binLen = 1;
        else 
            binLen = (int)Math.ceil(Math.log(num)/Math.log(26));

        for(int j=1; j<=num; j++){
            int n = j;
            String str = "";
            for(int i=1; i<=binLen; i++){
                String s = Aron.intToAlphabetUpper((n-1)%26);
                str = s + str;
                n = (n-1)/26;
            } 
            Print.pbl(str);
        } 
    }
    //]
    //[ file=excelnum1.html title=""
    // [1 -> 26] = ['A' -> 'Z']
    // [0 -> 25]   ['A' -> 'Z'] 
    public static void printExcel(int num){
        int base = 26;
        for(int i=1; i<=num; i++){
            int x = i;
            String str = "";
            if(x-1 == 0)
                str = 'A' + str;
            else{
                while( x > 0){
                    int r = (x-1) % base;
                    String s = Aron.intToAlphabetUpper(r);
                    str = s + str;
                    x = (x-1) / base;
                }
            }
            Print.pbl(str);
        }
    }
    //]

    public static void test0_excel() {
        Aron.beg();
        int num = 26;
        excelNumSaveLength(num);

        Aron.end();
    }
    public static void test1_excel() {
        Aron.beg();
        int num = 1; 
        excelNumSaveLength(num);

        Aron.end();
    }
    public static void test2_excel() {
        Aron.beg();
        int num = 27; 
        excelNumSaveLength(num);
        Aron.end();
    }
    public static void test0_printExcel() {
        Aron.beg();
        int num = 1; 
        printExcel(num);
        Aron.end();
    }
    public static void test1_printExcel() {
        Aron.beg();
        int num = 26; 
        printExcel(num);
        Aron.end();
    }
    public static void test2_printExcel() {
        Aron.beg();
        int num = 27; 
        printExcel(num);
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

//[ file=throw.html title=""
// User-defined Exception
class BigException extends Exception{
    public BigException(String msg){
        super(msg);
    }
}

class SmallException extends Exception{
    public SmallException(String msg){
        super(msg);
    }
}


public class ExceptionExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
    }
    // throw IOException and try/catch them
    static void test0(){
        Aron.beg();

        try{
            openFile("text/myfile1.txt");
        }catch(IOException e){
            System.err.println(e.getMessage());
        }

        Aron.end();
    }
    
    static void test1(){
        Aron.beg();
        openFile1("text/myfile1.txt");
        Aron.end();
    }
    
    static void test2(){
        Aron.beg();
        sizeMatter(20);
        sizeMatter(1000);
        sizeMatter(-1000);
        Aron.end();
    } 

    static void sizeMatter(int n){
        try{
            if(n > 100){
                throw new BigException("Too big BigException");
            }else if(n < -100){
                throw new SmallException("Too small SmallException");
            }
        }catch(BigException e){
            Print.p(e.getMessage());
        }catch(SmallException e){
            Print.p(e.getMessage());
        }
    }
    static void openFile(String fName) throws IOException{
        BufferedReader br = new BufferedReader(new FileReader(fName));
        String line = null;
        while( (line = br.readLine()) != null){
            Print.pl(line);
        }
        throw new IOException("Yep, throw IOException");
    }

    static void openFile1(String fName) {
        try{
            BufferedReader br = new BufferedReader(new FileReader(fName));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pl(line);
            }
        }catch(IOException e){
            System.err.println(e.getMessage());
        }
    }
    //]
} 
import java.util.*;
import java.io.*;
import classfile.*;

public class ExeCommand{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String output = Aron.executeCommand("ls");
        Print.pbl(output);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import classfile.*;

// Fiabonacci number with matrix, fiabonacci matrix 
class Fibonacci {
    public static void main(String args[]) {
        int n=10;
        int[][] Arr = new int[2][2];
        int[][] A = nFibonacciNum2(Arr, n);
        System.out.println("A[1][0]=" + A[1][0]);

        int fib = nFibonacciNum1(n);
        System.out.println("fib=" + fib);
    }
    //O(n^2)
    public static int nFibonacciNum(int n) {
        if(n == 0)
            return 0;
        else if(n==1)
            return 1;
        return nFibonacciNum(n-1)+nFibonacciNum(n-2);
    }

    //O(n)
    public static int nFibonacciNum1(int n) {
        int ret=0;
        if(n==0)
            ret = 0;
        else if(n==1)
            ret = 1;
        else {
            int a=0;
            int b=1;
            int c=1;
            int count=2;
            while(count <= n) {
                c = a + b;
                a = b;
                b = c;
                count++;
            }
            ret = c;
        }
        return ret;
    }
    //O(logn)
    public static int[][] nFibonacciNum2(int[][] A, int n) {
        if(n==0) {
            A[0][0] = 0;
            A[1][0] = 0;
            A[0][1] = 0;
            A[1][1] = 0;
            return A;
        } else if(n==1) {
            A[0][0] = 1;
            A[1][0] = 1;
            A[0][1] = 1;
            A[1][1] = 0;
            return A;
        } else {
            if(n%2 == 0)
                return MultiMat(nFibonacciNum2(A, n/2), nFibonacciNum2(A, n/2));
            else
                return MultiMat(A, MultiMat(nFibonacciNum2(A, (n-1)/2), nFibonacciNum2(A, (n-1)/2)));
        }
    }

    public static int[][] MultiMat(int[][] A1, int[][] A2) {
        int[][] A = new int[2][2];

        A[0][0] = A1[0][0]*A2[0][0] + A1[0][1]*A2[1][0];
        A[1][0] = A1[1][0]*A2[0][0] + A1[1][1]*A2[1][0];
        A[0][1] = A1[0][0]*A2[1][0] + A1[0][1]*A2[1][1];
        A[1][1] = A1[1][0]*A2[0][1] + A1[1][1]*A2[1][1];
        return A;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// FileOutStream example, outputstream, output stream, write raw data to file,
// filetream filestream, stream file, write byte[] to file,
public class FileOutStreamExample {
    public static void main(String[] args) {
        test0();
    }
    public static void test0() {
        Aron.beg();

        File file = new File("./text/raw1.txt");
        String content = "write byte[] array to file";

        try (FileOutputStream fop = new FileOutputStream(file)) {
            // if file doesn't exists, then create it
            if (!file.exists()) {
                file.createNewFile();
            }

            // get the content in bytes
            byte[] contentInBytes = content.getBytes();

            fop.write(contentInBytes);
            fop.flush();
            fop.close();

            System.out.println("Done");

        } catch (IOException e) {
            e.printStackTrace();
        }

        Aron.end();
    }
}

import java.util.Vector;
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Arrays;
import java.util.List;
import java.util.Queue;
import java.util.LinkedList;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.Collections;
//
import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.io.IOException;
import java.io.*;
//
import classfile.*; 

// FileInputStream example, FileOutputStream example, 
// FileInputStream, FileOutputStream, read raw byte[] from file, read binary file
// read chunk file, skip file, seek file, 
class FileRead {
    public static void main(String args[]) {
//        test0();
        test1();
//        test2();
    }
    
    static void test0(){
        Aron.beg();

        try {
            // Open the file that is the first
            // command line parameter

            String fName = "/Users/cat/myfile/github/java/text/file3.txt";
            FileInputStream fstream = new FileInputStream(fName);
            // Get the object of DataInputStream
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
            String strLine;
            //Read File Line By Line
            while ((strLine = br.readLine()) != null) {
                // Print the content on the console
                System.out.println (strLine);
            }
            //Close the input stream
            in.close();
        } catch (Exception e) {
            //Catch exception if any
            System.err.println("Error: " + e.getMessage());
        }
        Aron.end();
    }
    static void test1(){
        Aron.beg();

//        try {
//            String fName = "/Users/cat/myfile/github/java/text/file3.txt";
//            File file = new File(fName);
//
//            FileInputStream fstream = new FileInputStream(fName);
//            int nbyte = 0;
//            //Read File Line By Line
//            byte[] arr = new byte[20];
//            while ((nbyte = fstream.read(arr)) != -1) {
//                for(int i=0; i<nbyte; i++){
//                    Print.pbl(arr[i]);
//                } 
//                String str = new String(arr);
//                Print.pbl(str + " size=" + nbyte);
//            }
//            //Close the input stream
//            fstream.close();
//        } catch (Exception e) {
//            //Catch exception if any
//            System.err.println("Error: " + e.getMessage());
//        }
        
        String fName = "/Users/cat/myfile/github/java/text/file3.txt";
        int bufSize = 40;
        List<String> list = readFileLineByte(fName, bufSize); 
        Aron.printList(list);
        Aron.end();
    }
    public static List<String> readFileLineByte(String fName, int bufSize){
        List<String> list = new ArrayList<String>(); 
        try {
            FileInputStream fstream = new FileInputStream(fName);
            int nbyte = 0;
            //Read File Line By Line
            byte[] arr = new byte[bufSize];
            byte[] lineArr = new byte[bufSize];
            int k=0;
            while ((nbyte = fstream.read(arr)) != -1) {
                String str = new String(arr);

                for(int i=0; i<nbyte; i++){
                    Print.pbl("char=" + arr[i]);
                    if(arr[i] == '\n'){
                        Print.pbl("newline=" + arr[i]);

                        lineArr[k] = arr[i];
                        list.add(new String(lineArr));
                        k = 0;
                        lineArr = new byte[bufSize];
                    }else{
                        lineArr[k] = arr[i];
                        k++;
                    }
                }
            }
            //Close the input stream
            fstream.close();
        } catch (Exception e) {
            System.err.println("Error: " + e.getMessage());
            e.printStackTrace();
        }
        return list;
    }
    
    static void test2(){
        Aron.beg();
        String currDir = "/Users/cat/myfile/github/java";
        List<String> list = Aron.getCurrentDirs(currDir);
        Aron.printList(list);
        List<String> flist = Aron.getCurrentFiles(currDir);
        Ut.l();
        Aron.printList(flist);

        Aron.end();
    }
}
import java.util.*;
import java.util.stream.*;
import java.io.*;
import classfile.*;

public class Filter {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        List<Integer> list1 = Arrays.asList(1, 2, 3); 
        List<Integer> list2 = Arrays.asList(2, 1, 3); 
        List<Integer> left = list1.stream().filter(x -> x < 2).collect(Collectors.toList());
        List<Integer> right = list1.stream().filter(x -> x > 2).collect(Collectors.toList());
        Aron.printList(left);
        Aron.printList(right);

        

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}

public class FindKeyRotateArray {
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }

    public static void test0() {
        System.out.println("Find the max element in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        int key = 1;
        boolean ret = findKey(array, left, right, key);
        //boolean ret1 = binarySearch(array, left, right, key);
        boolean ret2 = findKey(array, left, right, key);
        System.out.println("key="+ret);
        //System.out.println("key1="+ret1);
        System.out.println("key2="+ret2);
    }
    public static void test1() {
        System.out.println("Find the max element in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        int key = 1;
        Aron.printArray(array);
        System.out.println("key="+key);
        boolean ret = findKey(array, left, right, key);
        System.out.println("key="+ret);
    }

    public static void test2() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {1, 2, 3};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }
    public static void test3() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test4() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test5() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test6() {
        System.out.println("Find the max Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMaxIndex2(array, left, right);
        System.out.println("index="+index);
    }

    public static void test7() {
        System.out.println("Find the min Index in a sorted and rotated array");
        int[] array = {3, 2};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMinIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static void test8() {
        System.out.println("Find the min Index in a sorted and rotated array");
        int[] array = {2, 3, 1};
        int left = 0;
        int right = array.length - 1;
        Aron.printArray(array);
        int index = findMinIndex(array, left, right);
        System.out.println("index="+index);
    }

    public static int findMaxIndex(int[] array, int left, int right) {
        int ret = -1;
        int len = right - left + 1;
        if( len == 1)
            ret = left;
        else if( len == 2)
            ret = array[left] > array[right]? left:right;
        else if(len > 2) {
            int mid = (left + right)/2;
            if(array[left] < array[mid])
                ret = findMaxIndex(array, mid, right);
            else
                ret = findMaxIndex(array, left, mid);
        }
        return ret;
    }

    public static boolean findKey(int[] array, int left, int right, int key) {
        if(left == right)
            return array[left] == key;

        int maxIndex = findMaxIndex(array, left, right);
        return binarySearch(array, left, maxIndex, key) || binarySearch(array, maxIndex+1, right, key);
    }
    public static boolean binarySearch(int[] array, int left, int right, int key) {
        boolean ret = false;
        if(array != null) {
            int mid = (left + right)/2;
            if(left < right) {
                if(key < array[mid]) {
                    ret = binarySearch(array, left, mid-1, key);
                } else if(key > array[mid]) {
                    ret = binarySearch(array, mid+1, right, key);
                } else
                    ret = true;
            } else if(left == right)
                ret = array[left] == key;
        }
        return ret;
    }

    // 1 2 3
    // 2 3 1
    // 1
    public static int findMinIndex(int[] array, int left, int right) {
        if(array != null) {
            if(array[left] < array[right])
                return left;
            else {
                int mid = (left + right)/2;
                if(array[mid] < array[right])
                    return findMinIndex(array, left, mid);
                else if(array[mid] > array[right])
                    return findMinIndex(array, mid+1, right);
                else if(array[mid] == array[right])
                    return mid;
            }
        }
        return -1;
    }
    // 1 2 3
    // 2 3 1
    // 3 1
    //
    // 3 1 2

    public static int findMaxIndex2(int[] array, int left, int right) {
        if( array != null) {
            //no rotation
            // {2}
            // {2, 3}
            if(array[left] < array[right])
                return right;
            else {
                //One rotation at least
                int mid = (left + right)/2;
                if(array[left] < array[mid])
                    return findMaxIndex2(array, mid, right);
                else if(array[left] > array[mid])
                    return findMaxIndex2(array, left, mid);
                else if(array[left] == array[mid])
                    return mid;
            }
        }
        return -1;
    }

    //No duplicated elements in the array
    public static boolean findKeyRotateArray(int[] array, int left, int right, int key) {
        boolean ret = false;
        if(array != null) {
            int len = right - left + 1;
            if(len == 1) {
                if(key == array[left])
                    ret = true;
            } else if (len > 1) {
                int mid = (left + right)/2;
                if(array[left] < array[mid]) {
                    if(key > array[mid])
                        ret = findKey(array, mid+1, right, key);
                    else if(key < array[mid]) {
                        if(array[left] < key)
                            ret = findKey(array, left, mid-1, key);
                        else if(array[left] > key)
                            ret = findKey(array, mid+1, right, key);
                        else
                            ret = true;
                    } else
                        ret = true;
                } else if(array[left] > array[mid]) {
                    if(key < array[mid])
                        ret = findKey(array, left, mid-1, key);
                    else if(key > array[mid]) {
                        if(key < array[left]) {
                            ret = findKey(array, mid+1, right, key);
                        } else if(key > array[left]) {
                            ret = findKey(array, left, mid-1, key);
                        } else
                            ret = true;
                    } else
                        ret = true;
                } else {
                    ret = array[left] == key || array[right] == key? true : false;
                }
            }
        }
        return ret;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
    public Node parent;
	public int data;
    boolean isVisited;
	public Node(int n)
	{ data = n; left = right = parent = null; isVisited = false;}
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ 
                        cur.left = new Node(n); end = true; 
                        cur.left.parent = cur;
                    }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ 
                        cur.right = new Node(n); end = true; 
                        cur.right.parent = cur;
                    }
					else
						cur = cur.right;
				}
			}
		}
	}

	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
	public Node getRoot()
	{ return root;}
}
class FindKthNeighbour 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);

		Node r = b1.getRoot();
		Inorder(r);
        //
		int[] Arr = new int[100];
		int len=0;
        Node initNode = r;

        List<Node> list = new LinkedList<Node>();
        Node randNode = GetRandomNode(r, initNode, list); 
        System.out.println("randNode["+randNode.data+"]");
        PrintAllKthNeighbour(randNode, 3);
	}
	
    public static Node GetRandomNode(Node node, Node initNode, List<Node> list)
    {
        if(node != null)
        {
            GetRandomNode(node.left, initNode, list);
            list.add(node);
            GetRandomNode(node.right, initNode, list);
            Random rand = new Random();
            if(initNode == node)
            {
                int index = rand.nextInt(list.size()); 
		        System.out.println("rand=["+index+"] list=["+list.size()+"]");
                return list.get(index);
            }
        }
        return null;
    }
    public static void PrintAllKthNeighbour(Node node, int k)
    {
        if(node != null && !node.isVisited)
        {
            node.isVisited = true;
            if(k == 0)
            {
		        System.out.println("Neighbour["+node.data+"]");
            }
            else
            {
                k--;
                PrintAllKthNeighbour(node.left, k);
                PrintAllKthNeighbour(node.right, k);
                PrintAllKthNeighbour(node.parent, k);
            }
        }
    }
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
public class FindMaxRotateArray 
{
				public static void main(String[] args)
				{
                    System.out.println("Find the max element in a sorted and rotated array");
                    int[] array = {1, 2, 4};
                    int left = 0;
                    int right = array.length - 1;
                    int max = findMax(array, left, right);
                    int key = 2;
                    boolean ret = findKey(array, left, right, key);
                    System.out.println("max="+max);
                    System.out.println("key="+ret);
				}
                public static int findMax(int[] array, int left, int right)
                {
                    int ret = 0; 
                    int len = right - left + 1;
                    if( len == 1)
                        ret = array[left];
                    else if( len == 2)
                        ret = array[left] > array[right]? array[left]:array[right];
                    else if(len > 2)
                    {
                        int mid = (left + right)/2;
                        if(array[left] < array[mid])
                            ret = findMax(array, mid, right);
                        else 
                            ret = findMax(array, left, mid);
                    }
                    return ret;
                }
                //No duplicated elements in the array
                public static boolean findKey(int[] array, int left, int right, int key)
                {
                    boolean ret = false;    
                    if(array != null)
                    {
                        int len = right - left + 1; 
                        if(len == 1)
                        {
                            if(key == array[left])
                                ret = true;
                        }
                        else if (len > 1)
                        {
                            int mid = (left + right)/2;    
                            if(array[left] < array[mid])
                            {
                                if(key > array[mid])
                                    ret = findKey(array, mid+1, right, key);
                                else if(key < array[mid])
                                {
                                    if(array[left] < key)
                                        ret = findKey(array, left, mid-1, key);
                                    else if(array[left] > key)
                                        ret = findKey(array, mid+1, right, key);
                                    else 
                                        ret = true;
                                }
                                else
                                    ret = true;
                            }
                            else if(array[left] > array[mid])
                            {
                                if(key < array[mid])
                                    ret = findKey(array, left, mid-1, key);
                                else if(key > array[mid])
                                {
                                    if(key < array[left])
                                    {
                                        ret = findKey(array, mid+1, right, key);
                                    }
                                    else if(key > array[left])
                                    {
                                        ret = findKey(array, left, mid-1, key);
                                    }
                                    else
                                        ret = true;
                                }
                                else
                                    ret = true;
                            }
                            else
                            {
                                ret = array[left] == key || array[right] == key? true : false;
                            }
                        }
                    }
                    return ret;
                }
}
import java.util.*;

public class FindMedianLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Find the median of linkedlist");
        SLL s1 = new SLL();
        s1.append(2);
        s1.append(20);
        s1.append(30);
        s1.append(40);
        s1.append(50);

        Node node = median(s1.getHead());
        System.out.println("median["+node.data+"]");
    }

    public static void show(Node curr)
    {
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }
    
    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class FindNegative2DMat 
{
	public static void main(String args[])
	{
			int[][] Arr = new int[3][4];
			gen2D(Arr);
			int s = FindNegative(Arr);
			System.out.println("s=" + s);
	}

	public static void gen2D(int[][] Arr)
	{
		int row, col;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;
			Arr[0][0] = -2;
			Random r = new Random();
			for(int i=0; i<row; i++)
			{
				int ran = r.nextInt(3); 
				for(int j=0; j<col; j++)
				{
					if(i-1>=0 && j-1>=0)
					Arr[i][j] = Arr[i-1][j]+ Arr[i][j-1]+ran + 5;
					else if(j-1>=0)
						Arr[i][j] = Arr[i][j-1]+ran;
					else if(i-1>=0)
						Arr[i][j] = Arr[i-1][j]+ran;

					System.out.print(String.format("%10s", Arr[i][j]));
				}
				System.out.println();
			}
		}
	}
	public static int FindNegative(int[][] Arr)
	{
		int sum=0;
		if(Arr != null)
		{
			int nRow = Arr.length;
			int nCol = Arr[0].length; 

			int down = 0;
			int left = nCol-1;

			while(down < nRow && left >=0)
			{
				if(Arr[down][left] < 0)
				{
					sum = sum + left + 1;
					down++;
				}
				else 
					left--;
			}
		}
		return sum;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class FindNode 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
        
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        

        System.out.println("Before Swap");
        inorder(b1.getRoot());

        System.out.println("============");
        System.out.println("After Swap");

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        swap(199, 16, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
        System.out.println("============");
        findNode(b1.getRoot(), 199);
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static boolean findNode(Node node, int k)
    {
        if(node != null)
        {
            if(findNode(node.left, k))
            {
                System.out.println(node.data);
                return true;
            }

            if(node.data == k)
            {
                System.out.println(k);
                return true;
            }

            if(findNode(node.right, k))
            {
                System.out.println(node.data);
                return true;
            }
        }
        return false;
    }
    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }
}
import java.util.*;

class Node {
    char ch;
    public Node(char ch) {
        this.ch = ch;
    }
}

// get first non duplicated char from a stream
// use HashMap and Double LinkedList
public class FirstOccurCharFromStream {
    public static void main(String[] args) {
        System.out.println("Find the first occurrence character from a stream");
        String str = "kkc";
        char ch = FirstOccurrence(str);
        System.out.println("ch=["+ch+"]");
    }
    public static char FirstOccurrence(String str) {
        char ret = 0;
        List<Node> list = new LinkedList<Node>();
        if(str != null) {
            Map<Integer, Node> map = new HashMap<Integer, Node>();
            int len = str.length();
            for(int i=0; i<len; i++) {
                char ch = str.charAt(i);
                if(map.containsKey((int)ch)) {
                    Node node = map.get((int)ch);
                    if(node != null) {
                        list.remove(node);
                        map.put((int)ch, null);
                    }
                } else {
                    Node node = new Node(ch);
                    map.put((int)ch, node);
                    list.add(node);
                }
            }
        }
        if(list.size() > 0)
            ret = list.get(0).ch;
        return ret;
    }
}
import java.util.*;


//single linked list
class Node 
{
	Node next;
	int data;
	public Node(int n)
	{ next = null; data = n;}
}

class SLL
{
	Node head;
	public SLL()
	{ head = null;}
	public void append(int n)
    {
        Node cur = head;
		if(head == null)
			head = new Node(n);
		else
		{
			while(cur.next != null)
			{ 
                cur = cur.next; 
            }
			cur.next = new Node(n);
		}

    }
	public void append(Node no)
	{
		Node cur = head;
		if(head == null)
			head = no;
		else
		{
			while(cur.next != null)
			{ cur = cur.next; }
			cur.next = no;
		}
	}

	//recursive 
	static Node next=null;
	public void Reverse(Node cur)
	{
		if(cur != null)
		{
			Reverse(cur.next);
			if(next != null)
				next.next = cur;	
			else 
				head = cur;
			next = cur;
			cur.next = null;
		}
	}
	//iteration
	public void Reverse1(Node cur)
	{
		if(head != null)
		{
			Node prev = null;
			Node next = cur.next;

			while(cur != null)
			{
				cur.next = prev;
				prev = cur;
				cur = next;
				if(next != null)
					next = next.next;
			}
			head = prev;
			
		}
	}
	public Node getHead()
	{ return head;}

    public Node getTail()
	{ 
        Node curr = head;
        while(curr != null && curr.next != null)
        {
            curr = curr.next;
        }
        return curr;
    }

	public void Remove(Node no)
	{
		if(no != null && head != null)
		{
			Node cur = head;	
			Node prev = null;
			while(cur != no)
			{
				prev = cur;
				cur = cur.next;
			}
			if(prev != null && no.next != null)
			{ prev.next = no.next; no.next = null; }
			else if(prev == null && no.next != null)
			{ head = no.next; no.next = null; }
			else if(prev != null && no.next == null)
			{ prev.next = null; }
			else 
			{ no = null; head = null;}
		}	
	}
	public void show()
	{
		Node cur=head;
		while(cur != null)
	 	{ System.out.println("cur.data=" + cur.data); cur=cur.next;}
	}
}

public class FixSortedLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test1()
    {
        SLL s1 = new SLL();
        s1.append(1);
        s1.append(2);
        s1.append(4);
        s1.append(3);
        s1.append(5);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test2()
    {
        SLL s1 = new SLL();
        s1.append(3);
        s1.append(2);
        s1.append(1);
        s1.append(4);
        s1.append(5);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test3()
    {
        SLL s1 = new SLL();
        s1.append(3);
        s1.append(2);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test4()
    {
        SLL s1 = new SLL();
        s1.append(3);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    public static void test5()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MIN_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test6()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MAX_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }
    public static void test7()
    {
        SLL s1 = new SLL();
        s1.append(Integer.MAX_VALUE);
        s1.append(Integer.MIN_VALUE);
        show(s1.getHead());
        System.out.println("-----------------------------");
        Fix(s1.getHead());
        show(s1.getHead());
        System.out.println("-----------------------------");
    }

    // Fix reversed sublist in a single linkedlist
    // Input: 1->2->3->5->4->6  (5->4) reverse
    // output:1->2->3->4->5->6
    public static void Fix(Node head)
    {
        Stack<Integer> stack = new Stack<Integer>();
        Node curr = head;

        Node minNode = new Node(Integer.MIN_VALUE);
        minNode.next = curr;
        curr = head = minNode;
        while(curr != null && curr.next != null)
        {
            curr = curr.next; 
        }
        Node prev = curr;
        curr.next = new Node(Integer.MAX_VALUE);
        Node start = null;
        curr = head;
        while(curr != null)
        {
            Node next = curr.next;
            if(next != null)
            {
                if(curr.data > next.data)
                {
                    stack.push(curr.data);
                    if(start == null)
                        start = curr;
                }
                else if(start != null)
                {
                    stack.push(curr.data);
                    break;
                }
            }
            curr = next;
        }
        while(start != null && !stack.empty())
        {
            start.data = stack.pop();
            System.out.println("start.data["+start.data+"]");
            start = start.next;
        }
        head = head.next;
        prev.next = null;

    }

    public static void show(Node head)
    {
        Node curr = head;
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }

}
import classfile.*;

public class FlapBST {
    public static void main(String[] args) {
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(20);
        bst.insert(1);
        //Aron.binImage(bst.root);
        Aron.inorder(bst.root);
        flap(bst.root);
        Ut.l();
        Aron.inorder(bst.root);
        Aron.binImage(bst.root);
        
    }
    public static void flap(Node root) {
        if(root != null) {
            flap(root.left);
            flap(root.right);
            Node tmp = root.left;
            root.left = root.right;
            root.right = tmp;
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class FormatExample{
    public static void main (String[] args)
	{
		String sendID = "AABB";
        String output = String.format("%0"+(10-sendID.length())+"d%s", 0, sendID);
        System.out.println(output);
	}
} 

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	
    public Node getRoot()
	{ return root;}
}
class GeneBinaryTree
{
	public static void main(String args[])
	{
		BST b1 = new BST();

		b1.Insert(15);
		b1.Insert(12);
		
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		b1.Insert(20);
		b1.Insert(18);

		Node r = b1.getRoot();

		System.out.println("digraph G{");
        int level = 0;
        Inorder(r, level);
		System.out.println("}");
	}
    	
	public static void Inorder(Node root, int level) {
		if(root != null) {
			//System.out.println("" + root.data + "[label=" + root.data +"];");
			System.out.println(root.data);
            if(root.left != null){
			    System.out.print("" + root.data + "->");
            }
			Inorder(root.left, level+1);

            if(root.right != null){
			    System.out.print("" + root.data + "->");
            }
			Inorder(root.right, level+1);
		}
	}
}
import java.util.ArrayList;
import java.util.List;
class Node
{
    Map<String, Node> map = new HashMap<String, Node>();
}

class Tree
{
    Node root;
    public Tree()
    {
    }
}

public class GeneralTree 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

/**
* Generate Java simple template code
*/ 
public class GenerateProgram{
    final static String fName = "/Users/cat/myfile/github/java/text/program.txt";
    public static void main(String[] args) {
        printInfo();
        Print.p("Argument len=" + args.length);

        for(String s : args){
            Print.p("args:" + s);
        }
        if(args.length > 0)
            generateCode(args[0]);
        else
            Print.p("No Class Name is provided");
    }

    public static void printInfo(){
        Print.pb(fName);
    }
    /**
    * Generate Java file from a class name(e.g. MyClass => MyClass.java)
    */ 
    public static void generateCode(String pName){
        Aron.beg();
        List<String> list = Aron.readFile(fName);

        for(int i=0; i<list.size(); i++){ 
            String s = list.get(i);
            String newStr  = s.replace("Program", pName);
            Print.p(newStr);
            list.set(i, newStr);
        }
        Aron.line();

        List<String> list2 = new ArrayList<String>(); 
        for(int i=0; i<list.size(); i++){ 
            String s = list.get(i);
            Print.p(s);
            list2.add(s + "\n");
        }

        String newName = "/Users/cat/myfile/github/java/" + pName + ".java";
        Aron.writeFile(newName, list2);

        Aron.end();
    }
} 
import java.io.*;
import java.lang.String;
import java.util.*;
import java.lang.reflect.*;

import classfile.*;

// get all methods, all method, method signature
public class GetAllMethods{
    public static void main(String[] args) {
        //Method method = Test.getClass().getMethod();
        //Parameter para = new CachingParameter();

//        Class<String> clz = String.class;
//        for (Method m : clz.getDeclaredMethods()) {
//           System.err.println(m.getName());
//           for (Parameter p : m.getParameters()) {
//              System.err.println("  " + p.getName());
//           }
//        }

        Class<GetAllMethods> clz = GetAllMethods.class;
        for (Method m : clz.getDeclaredMethods()) {
           System.err.println(m.getName());
           for (Parameter p : m.getParameters()) {
              System.err.println("  " + p.getName());
           }
        }

        for(Method m : GetAllMethods.class.getMethods()) {
            Class<?>[] parameterTypes = m.getParameterTypes();
            for(Class<?> t : parameterTypes){
              System.out.println("type:" + t.getName());
            }
            Class<?> returnType = m.getReturnType();
            // funny stuff goes here
        }
    }
    static void print(String str1, int num){
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.io.*;
class GetCurrentPath 
{
	public static void main(String args[])
	{
					File currentPath = new File(new File(".").getAbsolutePath());
					System.out.println("absoluatepath="+currentPath.getAbsolutePath());
					try{
					System.out.println("canonicalpath="+currentPath.getCanonicalPath());
					}catch(IOException e)
					{
					}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.lang.reflect.*;

class GetMethod{
    public void foo() { }
    public String baz() {
        return "";
    }
    //[ file=getmethod.html title=""
    public static void main(String args[]) {
        try {
            Class c = GetMethod.class;
            Method[] m = c.getDeclaredMethods();
            for (int i = 0; i < m.length; i++)
                System.out.println(m[i].toString());
        } catch (Throwable e) {
            System.err.println(e);
        }
    }
    //]
}

import java.io.*;
import java.util.*;
class GivenSumPair 
{
	public static void main(String args[])
	{
		int[] Arr = {7, 5, 6, 7, -10, 1};
		Pair(Arr, -9);

	}

	public static void Pair(int[] Arr, int sum)
	{
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		
		for(int i=0; i<Arr.length; i++)
		{
			if(map.containsKey(new Integer(Arr[i])))
			{
				Integer v = map.get(new Integer(Arr[i]));
				int n = v.intValue(); n++;
				map.put(new Integer(Arr[i]), new Integer(n));
			}
			else
			{
				map.put(new Integer(Arr[i]), new Integer(1));
			}
		}

		for(int i=0; i<Arr.length; i++)
		{
			int diff = sum - Arr[i];
			if(map.containsKey(new Integer(diff)))
			{
				Integer v = map.get(new Integer(diff));
				int n = v.intValue();
				if(n > 0)
				{ System.out.println(diff + " " + Arr[i]);
					n--;
					map.put(new Integer(diff), new Integer(n));
				}
				Integer v1 = map.get(new Integer(Arr[i]));
				int n1 = v1.intValue();
				if(n1 > 0)
				{ n1--;
					map.put(new Integer(Arr[i]), new Integer(n1));
				}
			}
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

// leftPad()
import org.apache.commons.lang3.StringUtils;

public class GraphExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        int level = 0;
        Node root = createGeneralTree();
        preorderGraph(root);
        Aron.prettyPrintGeneral(root, level);
        Aron.line();
        postorderGraph(root);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(7);
        b1.insert(15);
        b1.insert(1);
        b1.insert(5); 
        b1.insert(0); 

        b1.print();
        Aron.line();
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(51);
        b1.insert(16);
        b1.insert(35);
        b1.insert(45);
        b1.insert(15);
        b1.insert(1);
        b1.insert(95);
        b1.insert(7); 

        int level = 0;
        b1.print();
        Aron.line();
        Aron.prettyPrint(b1.root, level);
        Aron.line();
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root);

        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        Node root = createGeneralTree();

        Aron.end();
    } 

    // create generate tree and pretty print 
    public static Node createGeneralTree(){
        Aron.beg();
        Node root = new Node(1);
        Node n1 = new Node(2);
        Node n2 = new Node(3);
        Node n3 = new Node(4);

        root.list.add(n1);
        root.list.add(n2);
        root.list.add(n3);

        Node nn1 = new Node(22);
        Node nn2 = new Node(33);
        Node nn3 = new Node(44);

        Node nn11= new Node(222);
        Node nn22 = new Node(333);
        Node nn33 = new Node(444);

        n1.list.add(nn1);
        n1.list.add(nn2);
        n1.list.add(nn3);

        n2.list.add(nn11);
        n2.list.add(nn22);
        n2.list.add(nn33);

        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        return root;
    }

    public static void preorderGraph(Node curr){
        if(curr != null){
            Print.pbl(curr.data);
            for(Node n : curr.list){
                preorderGraph(n);
            }
        }
    }

    public static void postorderGraph(Node curr){
        if(curr != null){
            for(Node n : curr.list){
                postorderGraph(n);
            }
            Print.pbl(curr.data);
        }
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class GraphLoopPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
    }
    static void test0(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);
        map.put(n2, n1);

        System.out.println("n1, n4=[" + isAPath(n1, n4, map, set) + "]"); 
        System.out.println("n2, n3=[" + isAPath(n2, n3, map, set) + "]"); 
        System.out.println("n1, n2=[" + isAPath(n1, n2, map, set) + "]"); 

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);
        map.put(n2, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n4);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);

        map.put(n1, n2);
        map.put(n2, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();

        Set<Node> set = new HashSet<Node>();

        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);

        n2.next = n3;

        map.put(n1, n2);
        map.put(n3, n1);

        System.out.println("isLoop[" + isLoop(n1, map, set) + "]"); 

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        System.out.println("True[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 1;
        System.out.println("True[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test7(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 1, 0},
            {0, 0, 0, 1},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 1;
        int destination = 2;
        System.out.println("False[" + isPathMatrix(source, destination, arr2d, height, width) + "]"); 

        Aron.end();
    }

    static void test8(){
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        List<Integer> list = new ArrayList<Integer>(); 

        int[][] arr2d = {
            {0, 2, 7, 0},
            {0, 0, 0, 4},
            {0, 0, 0, 1},
            {0, 0, 0, 0},
        }; 
        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        int min = Integer.MAX_VALUE;
        System.out.println("min path[" + minPathMatrix(source, destination, list, min, arr2d, height, width) + "]"); 

        Aron.end();
    }
    static void test9(){
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); 
        List<Integer> list = new ArrayList<Integer>(); 

        int[][] arr2d = {
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},

            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 0, 0, 0, 0, 0, 0},
        }; 

        int height = arr2d.length;
        int width = arr2d[0].length;
        int source = 0;
        int destination = 3;
        int min = Integer.MAX_VALUE;
        System.out.println("min path[" + minPathMatrix(source, destination, list, min, arr2d, height, width) + "]"); 

        Aron.end();
    }

    //[ file=pathloop.html title=""
    //1, 1
    //
    //1, 4 
    //<1, 2->3>
    //<2, 4>
    //<3, 4>
    //<2, 1>
    //              1 
    //         2        3     
    //              4
    static boolean isAPath(Node sNode, Node dNode, Map<Node, Node> map, Set<Node> set){
        if(sNode != null && dNode != null){
            if(set.contains(sNode)){
                return false;
            }else{
                set.add(sNode);
            }
            if(sNode.data == dNode.data)
                return true;
            else{
                Node curr = map.get(sNode);
                while(curr != null){
                    if(curr.data == dNode.data){
                        return true;
                    }else{
                        return isAPath(curr.next, dNode, map, set);
                    }
                }
            }
        }
        return false;
    }

    static boolean isLoop(Node curr, Map<Node, Node> map, Set<Node> set){
        if(curr != null){
            if(set.contains(curr)){
                return true;
            }else{
                set.add(curr);
                Node child = map.get(curr);
                while(child != null){
                    if(isLoop(child, map, set))
                        return true; 
                    child = child.next;
                }
                set.remove(curr);
            }
        }
        return false;
    }

    static boolean isPathMatrix(int s, int d, int[][] arr, int height, int width){
        if(arr != null && s < height){
            if(s == d)
                return true;
            else{
                for(int i=0; i< width; i++){
                    if(arr[s][i] == 1){
                        return isPathMatrix(i, d, arr, height, width); 
                    }
                }
            }
        }
        return false;
    }

    static int maxSumBin(Node root, int sum, int max){
        if(root != null){
            if(root.left == null && root.right == null){
                return Math.max(sum + root.data, max);
            }else{
                int lmax = maxSumBin(root.left, sum + root.data);
                int rmax = maxSumBin(root.right, sum + root.data);

                return Math.max(lmin, rmin);
            }
        }
        return 0;
    }

    static int maxSumBin2(Node root){
        if(root != null){
            return Math.max(maxSumBin2(root.left), maxSumBin2(root.right)) + root.data;
        }
        return 0;
    }

    static int minPathMatrix(int s, int d, List<Integer> list, int min, int[][] arr, int height, int width){
        if(arr != null && s < height){
            if(s == d){
                int sum = 0;
                for(Integer n : list)
                    sum += n;
                min = Math.min(sum, min);
            }
            else{
                for(int i=0; i< width; i++){
                    if(arr[s][i] > 0){
                        list.add(arr[s][i]);
                        min = minPathMatrix(i, d, list, min, arr, height, width); 

                        if(list.size() > 0)
                            list.remove(list.size()-1);
                    }

                }
            }
        }
        return min;
    }
    //]
} 
interface HashMapInterface
{
    Object put(Object key, Object value);
    Object get(Object key);
    Object remove(Object key);
}

class Node
{
    Object key;
    Object value;
    Node next;
    public Node(Object key, Object value)
    {
        this.next = null;
        this.key = key;
        this.value= value;
    }
}
class HashMapClass implements HashMapInterface
{
    Node[] nodeArray;
    int size;
    public HashMapClass(int size)
    {
        this.size = size;
        nodeArray = new Node[size];
    }
    public Object put(Object key, Object value)
    {
        boolean done = false;
        Object ret = null;
        Node curr = nodeArray[key.hashCode() % this.size];
        while(curr != null && !done)
        {
            if(key != curr.key)
            {
                curr = curr.next;
            }
            else
            {
                ret = curr.value;
                done = true;
            }
        }
        return ret;
    }
    public Object get(Object key)
    {
        Object ret = null;
        if(key != null)
        {
            boolean done = false;
            Node curr = nodeArray[key.hashCode() % this.size];
            while(curr != null && !done)
            {
                if(key != curr.key)
                {
                    curr = curr.next;
                }
                else
                {
                    ret = curr.value;
                    done = true;
                }
            }
        }
        return ret;
    }
    public Object remove(Object key)
    {
        Object ret = null;
        if(key != null)
        {
            boolean done = false;
            Node curr = nodeArray[key.hashCode() % this.size];
            Node prev = curr;
            while(curr != null && !done)
            {
                if(key != curr.key)
                {
                    prev = curr;
                    curr = curr.next;
                }
                else
                {
                    ret = curr.value;
                    if(prev == curr)
                    {
                        prev = curr = null;
                    }
                    else
                    {
                        prev.next = curr.next;
                        done = true;
                    }
                }
            }
        }
        return ret;
    }
}

public class HashMapImple 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class HashMapIterate  
{
	public static void main(String args[])
	{
		Map<String, String> hashmap = new HashMap<String, String>();
		hashmap.put("key0", "str0");	
		hashmap.put("key1", "str1");	
		hashmap.put("key2", "str2");	
		hashmap.put("key3", "str3");	

		for(String key : hashmap.keySet())
		{
			String value = hashmap.get(key);
			System.out.println("hashmap["+key+","+value+"]");	
		}
	}
}
public class Haversine {
    public static final double R = 6372.8; // In kilometers
    public static double haversine(double lat1, double lon1, double lat2, double lon2) {
        double dLat = Math.toRadians(lat2 - lat1);
        double dLon = Math.toRadians(lon2 - lon1);
        lat1 = Math.toRadians(lat1);
        lat2 = Math.toRadians(lat2);
 
        double a = Math.pow(Math.sin(dLat / 2),2) + Math.pow(Math.sin(dLon / 2),2) * Math.cos(lat1) * Math.cos(lat2);
        double c = 2 * Math.asin(Math.sqrt(a));
        return R * c;
    }
    public static void main(String[] args) {
        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

class Interval implements Comparable<Interval> {
    public int begin;
    public int end;
    public Interval(int begin, int end) {
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter) {
        if(this.begin > inter.begin)
            return 1;
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString() {
        return "[" + begin + " " + end + "]";
    }
}

public class Hello {
    public static void main(String[] args) {
        test0();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test00();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    static void test00() {
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};

        for(int i=0; i<arr1.length; i++) {
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0) {
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()) {
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else {
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()) {
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }

        Aron.end();
    }

    static void test0() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(5);
        sll.append(4);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = cloneLinkedList(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test2() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test3() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test4() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test5() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }

    static void test6() {
        System.out.println("\n--------------------------------------------------------------------------------");
        Aron.name();
        SingleLinkedList sll = new SingleLinkedList();
        Aron.printSLL(sll.head);
        Node newHead = reversePair(sll.head);
        Aron.printSLL(newHead);
        System.out.println("\n--------------------------------------------------------------------------------");
    }
    static void test7() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseLinkedList(sll.head);
        Aron.printSLL(nhead);

        Aron.end();
    }

    static void test8() {
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        Aron.printSLL(sll.head);

        Node nhead = reverseIte(sll.head);
        Aron.printSLL(nhead);
        Aron.end();
    }

    static void test9() {
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        SingleLinkedList sll2 = new SingleLinkedList();
        sll2.append(1);
        sll2.append(2);
        sll2.append(3);


        Node curr = sll.head;
        Node head = sll.head;

        while(curr != null && curr.next != null) {
            curr = curr.next;
        }
        curr.next = head;

        boolean circular = isCircular(sll.head);
        System.out.println("isCircular[" + circular + "]");

        boolean circular2 = isCircular(sll2.head);
        System.out.println("isCircular2[" + circular2 + "]");

        Aron.end();
    }
    static void test10(){
        Aron.beg();
        String str = "";
        System.out.println("empty str " + str + "[" + isBalance(str) + "]");

        str = "()";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "(]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "([)]";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        str = "()([])";
        System.out.println("" + str + "[" + isBalance(str) + "]");
        Aron.end();
    }
    
    static void test11(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node h = insertNodeToSortedList(ssl.head, 3);
        h = insertNodeToSortedList(ssl.head, 5);
        Aron.printSLL(h);
        Aron.end();
    }

    static void test13(){
        Aron.beg();
        SingleLinkedList ssl = new SingleLinkedList();
        ssl.append(4);
        ssl.append(7);
        ssl.append(9);
        Aron.printSLL(ssl.head);
        Node newHead = insertNodeToSortedList(ssl.head, 15);
        Aron.printSLL(newHead);
        Aron.end();
    }

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=nextnext.html title=""
    public static Node reverseIte(Node curr) {
        Node prev = null;
        Node next = null;
        while(curr != null) {
            next = curr.next;
            curr.next = prev;

            prev = curr;
            curr = next;
        }
        return prev;
    }

    public static Node reverseLinkedList(Node curr) {
        if(curr == null || curr.next == null)
            return curr;

        Node head = reverseLinkedList(curr.next);
        curr.next.next = curr;
        curr.next = null;

        return head;
    }

    public static Node reversePair(Node head) {
        Node curr = head;
        while(curr != null && curr.next != null) {
            int tmp = curr.data;
            curr.data = curr.next.data;
            curr.next.data = tmp;

            curr = curr.next.next;
        }
        return head;
    }

    public static boolean isCircular(Node curr) {
        if(curr == null)
            return false;
        else {
            Node next = curr.next;
            if(curr == next)
                return true;

            while(next != null) {
                if(curr == next)
                    return true;

                curr = curr.next;

                next = next.next;
                if(next != null)
                    next = next.next;
            }
        }
        return false;
    }
    //]


    static Node cloneLinkedList(Node head) {
        Node newHead = null;
        Node newCurr = null;
        Node curr = head;

        if(curr != null) {
            newCurr = newHead = new Node(head.data);

            while(curr.next != null) {
                newCurr.next = new Node(curr.next.data);
                newCurr = newCurr.next;
                curr = curr.next;
            }
        }
        return newHead;
    }

//    static boolean isBal(String str, int index){
//        if(str != null && index < str.length()){
//            if(!isBal(str, index + 1))
//                return false;
//
//            if(str.charAt(index) == '(' || str.charAt(index) == '[')
//                return isBal(str, index + 1);
//            else
//                return false;
//
//            else if(str.charAt(index) == ')'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '(') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }else if(str.charAt(index) == ']'){
//               if(index - 1 >= 0 && str.charAt(index - 1) == '[') 
//                   return isBal(str, index + 1);
//               else
//                   return false;
//            }
//        }
//        return true;
//    }

    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }

    static Node insertNodeToSortedList(Node head, int num){
       Node curr = head; 
       Node prev = null;

       while(curr != null){
           if(curr.data < num){
               prev = curr;
               if(curr.next == null){
                   prev.next = new Node(num);
                   return head;
               }
           }else{
               if(prev != null){
                   prev.next = new Node(num);
                   prev.next.next = curr;
                   return head;
               }else{
                   // first node
                   Node node = new Node(num);
                   node.next = curr;
                   head = node;
                   return head;
               }
           }
           curr = curr.next;
       }
       return head;

    }

    static boolean isBalance(String str) {
        Stack<String> stack = new Stack<String>();
        if(str != null) {
            for(int i=0; i<str.length(); i++) {
                String s = str.charAt(i) + "";
                if(s.equals("(") || s.equals("[")) {
                    stack.push(s);
                } else {
                    if(s.equals(")")) {
                    if(!stack.empty() && stack.peek().equals("(")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else if(s.equals("]")) {
                    if(!stack.empty() && stack.peek().equals("[")) {
                            stack.pop();
                        } else {
                            return false;
                        }
                    } else {
                        System.out.println("Error");
                        return false;
                    }

                }
            }
        }
        return stack.empty();
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.List;
import java.util.*;
import java.lang.Math;
import java.io.*;

import classfile.*;

class MyNode{
    public int data;
    public List<MyNode> list;
    public MyNode(int data){
        this.data = data;
        list = new ArrayList<MyNode>();
    }
}

class MyTree{
    public MyNode root;

    public MyTree(){
    }

    public void create(){
        root = new MyNode(1);
        root.list.add(new MyNode(2));
        root.list.add(new MyNode(3));

        MyNode branch = new MyNode(10);
        branch.list.add(new MyNode(11));
        branch.list.add(new MyNode(12));
        root.list.add(branch);

        MyNode branch1 = new MyNode(20);
        branch1.list.add(new MyNode(21));
        branch1.list.add(new MyNode(22));
        root.list.add(branch1);
    }
    public void printTree(MyNode node, int level, BufferedWriter bw){
        //Aron.beg();

        try{
            if(node != null){
                String format;

                if(level == 0)
                    format = "%1$1s";
                else
                    format = "%1$" + (level*10) + "s";

                //System.out.println(String.format(format, "[" + node.data));
                System.out.print(" [ " + node.data + " ");
                bw.write(" [ " + node.data + " ");
                for(MyNode n : node.list){
                    printTree(n, level+1, bw);
                }
                System.out.print(" ] " + " ");
                bw.write(" ] " + " ");
                //System.out.println(String.format(format, "]"));
            }
        }catch(IOException e){
        }

        //Aron.end();
    }
}

public class Hello1{
    public static void main(String[] args){
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
    }
    public static int height(Node root){
        return root == null ? -1 : Math.max(height(root.left), height(root.right)) + 1;
    }

    public static void printTree(MyNode node, int level){
        if(node != null){
            String format;
            if(level == 0)
                format = "%1$1s";
            else
                format = "%1$" + (level*10) + "s";

            System.out.println(String.format(format, "[" + node.data));
            for(MyNode n : node.list){
                printTree(n, level+1);
            }
            System.out.println(String.format(format, "]"));
        }
    }

    public static void test0(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");

        Aron.end();
    }

    public static void test1(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(1);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        System.out.println("[" + height(bst.root) + "]");

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(20);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(20);
        bst.insert(30);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);

        Aron.end();
    }
    
    static void test5(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);
        System.out.println("\n---------------------------------"); 

        Node curr = bst.root;
        while(curr != null){
            System.out.println("[" + curr.data + "]");
            curr = curr.next;
        }

        Aron.end();
    }
    static void test6(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        bst.insert(3);
        bst.insert(7);
        Aron.inorder(bst.root);
        System.out.println("\n---------------------------------"); 
        print(bst.root);
        System.out.println("\n---------------------------------"); 

        Node curr = bst.root;
        while(curr != null){
            System.out.println("[" + curr.data + "]");
            curr = curr.next;
        }

        Aron.end();
    }

    public static int BinaryTreeLevel(Node root){
        return root == null ? 0 : Math.max(BinaryTreeLevel(root.left), BinaryTreeLevel(root.right)) + 1;
    }

    static Node prev = null;
    public static void printLevel(Node curr, int level){
        if(curr != null){
            if(level == 1 ){
                System.out.println("[" + curr.data + "]");
                if(prev != null){
                    prev.next = curr;
                    prev = curr;
                }else{
                    prev = curr;
                }
            }else{
                printLevel(curr.left, level - 1);
                printLevel(curr.right, level - 1);
            }
        } 
    }
    public static void print(Node curr){
        for(int i = 1; i<= BinaryTreeLevel(curr); i++){
            printLevel(curr, i);
        }
    }
    
    static void test7(){
        Aron.beg();
        Map<Node, Node> map = new HashMap<Node, Node>();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        Node n4 = new Node(4);
        Node n5 = new Node(5);

        n2.next = n3;
        map.put(n1, n2);
        map.put(n2, n4);
        map.put(n3, n5);
        map.put(n5, n4);

        for(Map.Entry<Node, Node> entry: map.entrySet()){
            Node curr = entry.getValue();
            while(curr != null){
                System.out.println("[" + entry.getKey().data + " " + curr.data + "]");
                curr = curr.next;
            }
        }
        List<Node> list = new ArrayList<Node>();
        list.add(n1);
        getAllPaths(n1, map, 4, list);

        Aron.end();
    }
    
    static void test8(){
        Aron.beg();
        int[] arr = {2, -5, 8, -2, 3};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test9(){
        Aron.beg();
        int[] arr = {-1, -5, 8, -4, 5, -2, 3, -2};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test10(){
        Aron.beg();
        int[] arr = {-1, -5, 8};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void test11(){
        Aron.beg();
        int[] arr = {6, -5, 8};
        System.out.println("[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void buildMap(Node r, int key, Map<Integer, Integer> map){
        if(r != null){
            System.out.println("[" + r.data + "][" + key + "]");
            map.put(key, r.data);
            buildMap(r.left, 2*key + 1, map);
            buildMap(r.right, 2*key + 2, map);
        }
    }
    // index = 0
    static Node buildTree(Map<Integer, Integer> map, int index){
        Integer n = map.get(index);
        if(n != null){
            Node root = new Node(n);
            root.left = buildTree(map, 2*index+1);
            root.right = buildTree(map, 2*index+2);
            return root;
        }
        return null;
    }
    static void getAllPaths(Node n, Map<Node, Node> map, int num, List<Node> list){
        if(n.data == num){
            for(Node node : list){
                System.out.println("[" + node.data + "]");
            }
            System.out.println("\n---------------------------------"); 
        }else{
                Node curr = map.get(n);
                while(curr != null){
                    list.add(curr);
                    getAllPaths(curr, map, num, list);

                    if(list.size() > 0)
                        list.remove(list.size()-1);

                    curr = curr.next;
                }
        }
    }
    static int maxList(int[] arr){
        int max = -1;
        int first = 0;
        int second = 0;
        if(arr != null && arr.length > 0){
            max = arr[0];
            int sum = arr[0];
            for(int i=1; i<arr.length; i++){
                    sum += arr[i];
                    System.out.println("sum[" + sum + "]");
                    System.out.println("arr[" + i + "]=" + arr[i]);
                    if(sum < 0){
                        sum = 0;
                        if(i + 1 < arr.length)
                            first = i + 1;
                    }

                    if( max < Math.max(sum, arr[i])){
                        max = Math.max(sum, arr[i]);
                        second = i;
                    }
            }
            System.out.println("f[" + first + "]");
            System.out.println("s[" + second + "]");
        }
        return max;
    }

    static void test12(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 0, 1, 1},
            {1, 0, 1, 1},
            {0, 0, 0, 1},
            {0, 0, 1, 0},
            {0, 1, 1, 0},
        }; 

//[0][0]=0[0][1]=0[0][2]=5[0][3]=0
//[1][0]=1[1][1]=0[1][2]=0[1][3]=0
//[2][0]=0[2][1]=0[2][2]=0[2][3]=0
//[3][0]=0[3][1]=0[3][2]=3[3][3]=0
//[4][0]=0[4][1]=0[4][2]=0[4][3]=0


        int h = 0;
        int w = 0;
        int height = arr2d.length;
        if(height > 0){
            int width = arr2d[0].length;

            System.out.println("h[" + height + "]");
            System.out.println("w[" + width + "]");
            for(int i=0; i< height; i++){
                for(int j=0; j< width; j++){
                    int count = maxCount(arr2d, i, j, height, width);
                    System.out.print("[" + i + "][" + j + "]=" + count);
                }
                System.out.println("");
            } 
            
        }
        
        Aron.end();
    }

    static int maxCount(int[][] arr2d, int h, int w, int height, int width){
        if(arr2d != null){
            if(arr2d[h][w] == 1){
                arr2d[h][w] = 2;
                int n1 = 0;
                int n2 = 0;
                int n3 = 0;
                int n4 = 0;
                if(h + 1 < height)
                    n1 = maxCount(arr2d, h + 1, w, height, width);
                if(h - 1 >= 0)
                    n2 = maxCount(arr2d, h - 1, w, height, width);
                if(w + 1 < width)
                    n3 = maxCount(arr2d, h, w + 1, height, width);
                if(w - 1 >= 0)
                    n4 = maxCount(arr2d, h, w - 1, height, width);

                return n1 + n2 + n3 + n4 + 1;
            }
        }
        return 0;
    }
    
    static void test13(){
        Aron.beg();

        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter("file3.txt"));
            int level = 0; 
            MyTree t = new MyTree();
            t.create();
            t.printTree(t.root, level, bw);

            bw.close();

            BufferedReader br = new BufferedReader(new FileReader("file3.txt"));
            String line;
            while((line = br.readLine()) != null){
                //System.out.println("inside[" + line + "]");
                break;
            }
            System.out.println("\n---------------------------------"); 

            String[] arr = line.split("\\s+");

            List<String> list = new ArrayList<String>(); 
            for(String s : arr){
                System.out.print("<<" + s + ">>"); 
                if(s.trim().length() > 0)
                    list.add(s);
            }

            br.close();
            level = 0;
            MyNode r = null;
            System.out.println("\n buildTree2---------------------------------"); 
            MyNode root = buildTree2(r, list.iterator());

//            System.out.println("\n---------------------------------"); 
//            for(String s : arr){
//                System.out.print("(" + s + ")"); 
//            }
            printTree(root, level);
            System.out.println("\n---------------------------------"); 

        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        Aron.end();
    }

    static MyNode buildTree2(MyNode root, Iterator<String> ite){
        if(ite.hasNext()){
            String token = ite.next();

            if(token.equals("[")){
                if(root == null)
                    return buildTree2(root, ite);
                else{
                    root.list.add(buildTree2(root, ite));
                    return root;
                }
            }else if(token.equals("]")){
            }
            else{
                MyNode nn = new MyNode(Integer.parseInt(token));
                if(root != null){
                    root.list.add(nn);
                    return buildTree2(root, ite);
                }else{
                    root = new MyNode(Integer.parseInt(token));
                    root.list.add(buildTree2(root, ite)); 
                }
            }
            return root;
        }
        return null;
    }

    static void test14(){
        Aron.beg();
        String file = "file.txt";
        try(BufferedReader br = new BufferedReader(new FileReader(file))){
            for(String line; (line = br.readLine()) != null;){
                System.out.println("[" + line + "]");
            }
        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        String file1 = "file1.txt";
        try(BufferedWriter bw = new BufferedWriter(new FileWriter(file1))){
            bw.write("dog\n");
            bw.write("God");
        }catch(IOException e){
            System.out.println("[" + e.getMessage() + "]");
        }

        Aron.end();
    }
    static void test15(){
        Aron.beg();
        
        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20); 
        int n = 0;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        buildMap(bt.root, n, map);
        for(Map.Entry<Integer, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " " + entry.getValue() +"]");
        }
        int index = 0;
        Node root = buildTree(map, index);
        Aron.inorder(root);
                 
        Aron.end();
    }
    
    static void test16(){
        Aron.beg();

        System.out.println(String.format("[%1$-1s]" , "123"));
//        System.out.println(String.format("[%1$05d]" , "123"));

        Aron.end();
    }

    static void test17(){
        Aron.beg();
        String str = "[1 [2][3][10[11][12]][20[21][22]]]";
        String[] arr = str.split("\\d+");
        for(String s : arr){
            System.out.println("{" + s + "}");
        }
        Aron.end();
    }
    static void test18(){
        Aron.beg();
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(1);
        list.add(2);
        list.add(3);

        Iterator<Integer> ite = list.iterator();
        while(ite.hasNext()){
            System.out.println("[" + ite.next() + "]"); 
        }
        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node {
    public Node left;
    public Node right;
    public int data;
    public Node(int n) {
        data = n;
        left = null;
        right = null;
    }
    public Node getLeft() {
        return left;
    }
    public Node getRight() {
        return right;
    }
    public void setLeft(Node l) {
        left = l;
    }
    public void setRight(Node r) {
        right = r;
    }
}

class BST {
    Node root;
    public BST() {
        root = null;
    };
    public void Insert(int n) {
        if(root == null) {
            root = new Node(n);
        } else {
            Node curr = root;
            boolean end = false;
            while(curr != null && !end) {
                if(n < curr.data) {
                    if(curr.left == null) {
                        curr.left = new Node(n);
                        end = true;
                    } else
                        curr = curr.left;
                } else {
                    if(curr.right == null) {
                        curr.right = new Node(n);
                        end = true;
                    } else
                        curr = curr.right;
                }
            }
        }
    }
    public void Inorder(Node curr) {
        if(curr != null) {
            Inorder(curr.left);
            System.out.print(curr.data + " ");
            Inorder(curr.right);
        }
    }
    public Node getRoot() {
        return root;
    }
}
class InorderIteration {

    public static Node prev = null;
    public static void main(String args[]) {
        BST b1 = new BST();
        b1.Insert(15);
        b1.Insert(12);
        /*
        b1.Insert(14);
        b1.Insert(17);
        b1.Insert(19);
        b1.Insert(130);
        b1.Insert(16);
        b1.Insert(10);
        */

        PostorderIteration(b1.getRoot());
        System.out.println();
        Postorder(b1.getRoot());
        Node node = ConvertBSTToCircileDoubleLinkedList(b1.getRoot());
        int count = 0;
        while(node != null && count < 20) {
            System.out.println("<"+node.data+">");
            node = node.right;
            count++;
        }
        //Inorder(b1.getRoot());
    }

    // in order traversal using iteration
    // inorder iteration
    public static void InorderIteration(Node curr) {
        Stack<Node> st = new Stack<Node>();
        while(curr != null || !st.isEmpty()) {
            if(curr != null) {
                st.push(curr);
                curr = curr.left;
            } else {
                Node no = st.pop();
                System.out.println("[" + no.data + "]");
                curr = no.right;
            }
        }
    }

    //Convert bst binary search tree to circular double linked list
    public static Node ConvertBSTToCircileDoubleLinkedList(Node curr) {
        Stack<Node> st = new Stack<Node>();
        Node currNode = null;
        Node first = null;
        Node prev = null;
        while(curr != null || !st.isEmpty()) {
            if(curr != null) {
                st.push(curr);
                curr = curr.left;
            } else {
                prev = currNode;
                currNode = curr = st.pop();
                if(prev != null) {
                    prev.right = currNode;
                    currNode.left = prev;
                } else {
                    first = currNode;
                }
                //System.out.println(currNode.data);
                curr = curr.right;
            }
        }
        if(first != null) {
            first.left = currNode;
            currNode.right = first;
        }
        return first;
    }
    public static void PostorderIteration(Node curr) {
        /*
        Stack<Node> st = new Stack<Node>();
        Node prev = null;
        while(curr != null || !st.isEmpty())
        {
            if(curr != null)
            {
                st.push(curr);
                prev = curr.left;
                curr = curr.left;
            }
            else
            {
                curr = st.pop();
                if(prev == curr.right)
                    System.out.println("curr.data=" + curr.data);
                prev = curr.right;
                curr = curr.right;
            }
        }
        */
    }
    public static void Inorder(Node root) {
        if(root != null) {
            Inorder(root.left);
            System.out.println("data=" + root.data);
            Inorder(root.right);
        }
    }
    public static void Postorder(Node myroot) {
        if(myroot != null) {
            System.out.println("post=" + myroot.data);
            Postorder(myroot.left);
            Postorder(myroot.right);
        }
    }
}
class Node
{
    int data;
    Node next;
    public Node(int data)
    {
        this.data = data;
        next = null;
    }
}
class CircularLinkedList
{
    Node first;
    public CircularLinkedList()
    {
        first = null;
    }
    public void print()
    {
        Node tmpFirst = first;
        if( tmpFirst != null)
        {
            Node curr = tmpFirst.next;
            System.out.println("["+tmpFirst.data+"]");
            while(tmpFirst != curr)
            {
                System.out.println("["+curr.data+"]");
                curr = curr.next;
            }
        }
    }
    public void print(Node first)
    {
        this.first = first;
        print();
    }
    public void setFirst(Node first)
    {
        this.first = first;
    }
    public void insert(Node node)
    {
        if(node != null)
        {
            if(first == null) //zero node
            {
                first = node;
                node.next = first;
            }
            else
            {
                Node curr = first;
                Node next = curr.next;
                if(next == null) //one node
                {
                    first.next = node;
                    node.next = first;
                }
                else //two or more nodes
                {
                    boolean done = false;
                    while(!done)
                    {
                        if(curr.data < next.data)
                        {
                           if(curr.data < node.data && node.data < next.data) 
                           {
                                curr.next = node;
                                node.next = next;
                                done = true;
                           }
                        }
                        else
                        {
                            if(node.data > curr.data || node.data < next.data)
                            {
                                curr.next = node;
                                node.next = next;
                                done = true;
                            }
                        }
                        curr = curr.next;
                        next = next.next;
                    }
                }
            }
        }
    }
}
public class InsertCircularLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Insert node to sorted circular linked list!");
        CircularLinkedList cll = new CircularLinkedList();
        Node node1 = new Node(10);
        Node node2 = new Node(6);
        Node node3 = new Node(20);
        Node node4 = new Node(1);
        Node node5 = new Node(7);
        
        cll.insert(node1);
        cll.insert(node2);
        cll.insert(node3);
        cll.setFirst(node2);

        cll.insert(node4);
        cll.insert(node5);
        cll.print();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

// sorted linkedlist, sorted linked list
// gf SortedLinkedList.java
public class InsertSortedList{
    public static void main(String[] args) {
        test10();
        test11();
        test12();
        test13();
    }
    
    static void test10(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();

        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        sll.append(4);
        sll.append(7);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test11_thread(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        sll.append(4);
        sll.append(7);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }

    static void test11(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(1);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }

    static void test12(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        sll.append(4);
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test13(){
        Aron.beg();
        SortedLinkedList sortll = new SortedLinkedList();
        SingleLinkedList sll = new SingleLinkedList();        
        Aron.printSLL(sll.head);
        Aron.line();  

        Node head = sortll.insert(sll.head, 3);
        Aron.printSLL(head);

        Aron.end();
    }
}
class Node
{
    Node next;
    int data;
    public Node(int data)
    {this.data = data;}
}

class InsertToList
{
    Node head;
    public InsertToList()
    {head = null; }
    public void insert(Integer data)
    {
        if(head == null)
            head = new Node(data);
        else
        {
            Node curr = head;
            Node next = curr.next;
            if(next == null) //One node only
            {
                Node node = new Node(data);
                if(data > curr.data)
                    curr.next = node;
                else
                {
                    node.next = curr;
                    head = node;
                }
            }
            else            //More than one node
            {
                //Insert node before the head
                if(data < curr.data)
                {
                    Node node = new Node(data);
                    node.next = curr;
                    head = node;
                }
                else 
                {
                    //Insert node between curr and next 
                    while(next != null)
                    {
                        if(curr.data < data && data < next.data)
                        {
                            curr.next = new Node(data);
                            curr.next.next = next;
                            break;
                        }
                        curr = next;
                        next = next.next;
                    }
                    if(next == null) //Insert to the last node
                    {
                        curr.next = new Node(data);
                    }
                }
            }
        }
    }
    public void printList()
    {
        Node curr = head;
        while(curr != null)
        {
            System.out.print("["+curr.data+"]");
            curr = curr.next;
        } 
    }
}

public class InsertToOrderList 
{
    public static void main(String[] args)
    {
        System.out.println("Insert an integer to order list");
        InsertToList orderList = new InsertToList();        
        orderList.insert(1);
        orderList.insert(0);
        orderList.printList();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class  InterTwoSortArr
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr1 = {1, 4, 8, 10};
		int[] Arr2 = {2, 8, 10, 16};
		int[] A = InterTwoSortedArr(Arr1, Arr2);
		for(int i=0; i<A.length; i++)
			System.out.println("A["+i+"]="+A[i]);
	}
	

	public static int[] InterTwoSortedArr(int[] Arr1, int[] Arr2)
	{
		int[] A = null;
		int[] retArr = null;
		int i=0, j=0, c=0;
		if( Arr1 != null && Arr2 != null)
		{
			int len1 = Arr1.length;
			int len2 = Arr2.length;

			A = new int[len1>len2?len1:len2];
			while(i < len1 && j < len2)
			{ if(Arr1[i]<Arr2[j])
					i++; 
				else if(Arr1[i]>Arr2[j])
					j++; 
				else 
				{ A[c]=Arr1[i];
					i++; j++;
					c++;
				}
			}
			
		}
		retArr = new int[c];
		for(i=0; i<c; i++)
			retArr[i]=A[i];
		return retArr;
	}
}
import java.io.*;

interface myinter 
{
	public void face();
	public void print();
}

class myclass implements myinter 
{
	public void face()
	{
		System.out.println("face");
	}
	public void print()
	{
		System.out.println("print");
	}
}


class Interface 
{
	public static void main(String args[])
	{
		myclass a = new myclass();
		a.face();
		a.print();
	}
}
import java.util.*;

public class IntersectionList {
    public static void main(String[] args) {
        test0();
        test1();
    }

    static  void test0() {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        lists.add(Arrays.asList(1, 4, 4, 3, 2));
        lists.add(Arrays.asList(1, 3, 1, 9, 4));
        lists.add(Arrays.asList(1, 6, 3, 2, 2));
        List<Integer> retList = intersection(lists);

        for(Integer n : retList) {
            System.out.println(n);
        }
    }

    static  void test1() {
        List<List<Integer>> lists = new ArrayList<List<Integer>>();
        lists.add(Arrays.asList(1, 4, 4, 3, 2));
        lists.add(Arrays.asList(6));
        lists.add(Arrays.asList(1, 6, 3, 2, 2));
        List<Integer> retList = intersection(lists);

        for(Integer n : retList) {
            System.out.println(n);
        }
    }

    //[ file=intersectionlist.html title=""
    public static List<Integer> intersection(List<List<Integer>> lists) {
        List<Integer> retList = new ArrayList<Integer>();
        if(lists != null) {
            Map<Integer, Set<Integer>> map = new HashMap<Integer, Set<Integer>>();

            for (int i = 0; i < lists.size(); i++) {
                List<Integer> list = lists.get(i);

                for (Integer n : list) {
                    Set<Integer> set = map.get(n);
                    if (set != null) {
                        set.add(i);
                        map.put(n, set);
                    } else {
                        Set<Integer> nSet = new HashSet<Integer>();
                        nSet.add(i);
                        map.put(n, nSet);
                    }
                }
            }
            for (Map.Entry<Integer, Set<Integer>> entry : map.entrySet()) {
                Integer n = entry.getKey();
                Set<Integer> set = map.get(n);
                if (set.size() == lists.size())
                    retList.add(n);
            }
        }
        return retList;
    }
    //]
}
import java.util.*;
import java.io.*;
import classfile.*;

class Entry{
    public String key;
    public Object value;
    public Entry next;
    public Entry(String key, Object value){
        this.key = key;
        this.value = value;
    }
}

class Hash{
    public Entry[] arr;
    public int max;
    public int count = 0;
    public Hash(int max){
        this.max = max;
        arr = new Entry[max];
    }

    public Node get(String key){
        int hash = key.hashCode() % max;
        return (Node)arr[hash].value;
    }
    public void delete(String key){
        if(key != null){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr != null){
                Entry prev = null;
                while(curr != null){
                    if(curr.key == key)
                        break;
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(prev == null){
                    arr[hash] = curr.next;
                    count--;
                }else{
                    if(curr != null){
                        prev.next = curr.next;
                        count--;
                    }
                }
            }
        }
    }
    public void put(String key, Node node){
        if(count < max){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr == null){
                arr[hash] = new Entry(key, node);
                count++;
            }
            else{
                Entry prev = null;
                while(curr != null){
                    if(curr.key.equals(key)){
                        // Replace with new value
                        curr.value = node;
                        break;
                    }
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                // No key is found
                if(curr == null){
                    prev.next = new Entry(key, node);
                    count++;
                }
            }
        }
        
    }
}


class Interval implements Comparable<Interval> {
    int startTime;
    int endTime;
    public Interval(int startTime, int endTime) {
        this.startTime = startTime;
        this.endTime = endTime;
    }
    public int compareTo(Interval v) {
        return startTime - v.startTime;
    }
}


//[ file=inorderiterator.html title=""     
class InorderIterator {
    Node curr;
    Stack<Node> stack = new Stack<Node>();
    public InorderIterator(Node r) {
        this.curr = r;
    }
    public boolean hasNext() {
        if(curr != null || stack.size() > 0)
            return true;
        else
            return false;
    }
    public int next() {
        while(hasNext()) {
            if(curr != null) {
                stack.push(curr);
                curr = curr.left;
            } else {
                Node node = stack.pop();
                curr = node.right;
                return node.data;
            }
        }
        return -1;
    }
}
//]

public class IntervalExample {
    public static void main(String[] args) {
        test0_InorderIterator();
        test1_InorderIterator();
        test2_InorderIterator();
        test3_InorderIterator();
        test00_hash();
        test01_hash();
        test02_hash();
        test03_hash();
        test04_hash();
        test05_hash();
        test06_hash();
        test07_hash();
        test08_hash();
        test09_hash();
        test010_hash();
        test011_hash();
        test012_hash();
    }
    static void test0_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
//        bst.insert(5);
//        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test1_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test2_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    static void test3_InorderIterator(){
        Aron.beg();
        BST bst = new BST();
        bst.insert(10);
        bst.insert(5);
        bst.insert(1);
        bst.insert(15);
        InorderIterator ite = new InorderIterator(bst.root);
        while(ite.hasNext()){
            Print.p(ite.next());
        }

        Aron.end();
    }
    // 4:17
    static int[] multiple(int[] arr) {
        int[] tmpArray = null;
        if(arr != null) {
            int len = arr.length;
            tmpArray = new int[len];
            for(int i=0; i<len; i++) {
                int m = 1;
                for(int j=0; j<len; j++) {
                    if(i != j) {
                        m *= arr[j];
                    }
                }
                tmpArray[i] = m;
            }
        }
        return tmpArray;
    }
    // prefix and suffix
    // abc = [a, bc], [ab, c], [abc, ""]
    static List<String> prefixSuffix(String str) {
        List<String> list = new ArrayList<String>();
        if(str != null) {
            int len = str.length();
            for(int i=0; i<len; i++) {
                String prefix = str.substring(0, i+1);
                String suffix = str.substring(i+1, len);
                list.add(prefix);
                list.add(suffix);
            }

        }
        return list;
    }
    static void test2() {
        Aron.beg();
        String str = "abc";
        prefixSuffix(str);
        Aron.end();
    }
    //  4:14 - 5:20
    static void inorder(Node r) {
        if(r != null) {
            inorder(r.left);
            Print.p(r.data);
            inorder(r.right);
        }
    }
    static void inorderIterator(Node r) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = r;
        while(curr != null || stack.size() > 0) {
            if(curr != null) {
                stack.push(r);
                curr = r.left;
            } else {
                Node p = stack.pop();
                Print.p(p.data);
                curr = p.right;
            }
        }
    }
    // 5:20 - 5:34
    static void preorder(Node r) {
        if(r != null) {
            Print.p(r.data);
            preorder(r.left);
            preorder(r.right);
        }
    }
    static void preorderIterator(Node r) {
        Stack<Node> stack = new Stack<Node>();
        Node curr = r;
        while(curr != null || stack.size() > 0) {
            if(curr != null) {
                Print.p(curr.data);
                stack.push(curr);
                curr = curr.left;
            } else {
                Node p = stack.pop();
                curr = p.right;
            }
        }
    }
    // 5:35 - 5:42
    static void postorder(Node r) {
        if( r != null) {
            postorder(r.left);
            postorder(r.right);
            Print.p(r.data);
        }
    }
    // use two stacks
    static void postorderIterator(Node r) {
        Stack<Node> stack1 = new Stack<Node>();
        Stack<Node> stack2 = new Stack<Node>();
        if(r != null) {
            stack1.push(r);
            while(stack1.size() > 0) {
                Node node = stack1.pop();
                if(node.left != null)
                    stack1.push(node.left);

                if(node.right != null)
                    stack1.push(node.right);

                stack2.push(node);
            }
            while(stack2.size() > 0) {
                Print.p(stack2.pop().data);
            }
        }
    }

    static void test1() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int[] array = multiple(arr);
        Aron.printArray(arr);
        Aron.printArray(array);

        Aron.end();
    }


    // test1 [1]
    // test2 [1, 2]
    // test3 [2, 1]
    // test4 [3, 1, 2]
    // test5 [2, 3, 1]
    public static int findMaxIndex(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] < arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;
                if(arr[lo] < arr[mid])
                    return findMaxIndex(arr, mid, hi);
                else
                    return findMaxIndex(arr, lo, mid);
            }
        }
        return -1;
    }
    
    static void test00_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        Node node = (Node)hash.get("a");

        Test.f(node, null);
        Test.f(node, new Node(3));
        Test.t(node, new Node(1));

        Aron.end();
    }
    static void test01_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("a", new Node(2));
        Node node = (Node)hash.get("a");
        Test.t(node, new Node(2));

        Aron.end();
    }
    static void test02_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test03_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        hash.put("e", new Node(5));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test04_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.delete("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
        }

        Aron.end();
    }
    static void test05_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.delete("a");
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test06_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test07_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 1);

        Aron.end();
    }
    static void test08_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 0);

        Aron.end();
    }
    static void test09_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        Test.t(hash.count, 2);

        Aron.end();
    }
    static void test010_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        Test.t(hash.count, 1);

        Aron.end();
    }
    static void test011_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
    static void test012_hash(){
        Aron.beg();
        Hash hash = new Hash(3);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

public class InvertBinTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    
    public static Node invert(Node root){
        if(root != null){
            Node right = invert(root.left);
            Node left  = invert(root.right);
            root.right = right;
            root.left  = left;
            return root;
        }
        return null;
    }
    public static void test0(){
       BST bst = new BST(); 
       bst.insert(10);
       bst.insert(5);
       bst.insert(15);
       bst.insert(7);
       Ut.l();
       Aron.inorder(bst.getRoot());
       Ut.l();
       Node r = invert(bst.getRoot());
       Aron.inorder(r);
    }
    public static void test1(){
       BST bst = new BST(); 
       bst.insert(10);
       bst.insert(5);
       bst.insert(7);
       bst.insert(15);
       bst.insert(12);
       bst.insert(18);
       Ut.l();
       Aron.inorder(bst.getRoot());
       Ut.l();
       Node r = invert(bst.getRoot());
       Aron.binImage(r);
       Aron.inorder(r);
    }
}
public class IsLeapYear 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int isLeapYear(int month, int year)
    {

    }
}
import java.lang.Integer;
import java.lang.String;
import java.util.*;
import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.LinkedBlockingDeque;
import java.util.concurrent.ConcurrentLinkedDeque;
import java.util.stream.Stream;

import classfile.*;

public class JavaDataStructure {
    public static void main(String[] args) {
        System.out.println("Java Data Structure");

        //[file=data-structure.html title=""
        // map, list, linkedlist, HashMap, HashTable, queue, stack
        //
        int[] array     = {1, 2, 3};
        int[][]  array2 = {{1, 2, 3},
            {4, 5, 6}
        };
        // ArrayList
        ArrayList<String> alist = new ArrayList<String>();
        alist.add("dog");
        alist.add("cat");

        // list of list, ArrayList 2D
        ArrayList<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        list2d.add(alist);

        // List
        List<String> list = new ArrayList<String>();
        list.add("eloberate");
        list.add("continue");
        list.add("continuous");

        // Vector is old data structure in Java, use List instead
        // Vector is not synchronized
        Vector<String> vector = new Vector<String>();
        vector.add("jobs");
        vector.add("career");
        vector.add("motivation");
        vector.add("ambition");

        // LinkedList
        LinkedList<Integer> linkedList = new LinkedList<Integer>();
        linkedList.add(1);
        linkedList.add(2);

        // Queue
        Queue<Integer> queue = new LinkedList<Integer>();
        queue.add(1);
        queue.add(2);
        queue.remove();
        if(queue.peek() == 2)
            System.out.println("top element is :" + 2);

        // LinkedBlockingDeque
        // blocking, use lock in the implementation
        Deque<String> blockingDeque = new LinkedBlockingDeque<String>();
        blockingDeque.addFirst("first");
        blockingDeque.addLast("last");

        // non-blocking, non blocking, nonblocking queue
        // ConcurrentLinkedDeque, concurrent queue concurrentqueue
        Deque<String> concurrentDeque = new ConcurrentLinkedDeque<String>();
        concurrentDeque.addFirst("first");
        concurrentDeque.addLast("last");

        // HashMap can have null for [k, v]
        Map<String, Integer> map = new HashMap<String, Integer>();
        map.put("cat", 1);
        map.put("dog", 2);

        String key = "cat";
        Integer value = map.get(key);
        if(value != null) {
            value = map.get(key);
            System.out.println("key=" + key + " value=" + value);
        }

        if(map.containsKey(key))
            System.out.println("map contains key=" + key);

        // java, init list, java initialize list, List as Value in HashMap
        Map<String, List<String>> mapList = new HashMap<String, List<String>>();
        mapList.put("1", Arrays.asList("dog", "cat", "cow"));
        mapList.put("2", Arrays.asList("C++", "Java", "Haskell"));
        mapList.put("3", Arrays.asList("Scala", "Python", "Ruby"));

        for(Map.Entry<String, List<String>> entry: mapList.entrySet()) {
            String myKey = entry.getKey();
            List<String> myList = entry.getValue();
            for(String elem: myList) {
                System.out.println("myKey=" + myKey + " list=" + elem);
            }
        }

        if(mapList.containsKey("key")) {
            System.out.println("contains key");
        }

        // HashTable can't have [k, v] to be null
        Map<String, String> table = new Hashtable<String, String>();
        table.put("key", "value");
        table.put("nonull", "nonull");
        for(Map.Entry<String, String> entry : table.entrySet()) {
            System.out.println("[" + entry.getKey() + " " + entry.getValue() + "]");
        }

        List<String> mylist = mapList.get("dog");
        int size = mapList.size();
        if(mapList.containsValue("1")) {
            System.out.println("contains value");
        }

        for(String str : mylist) {
            System.out.println("str=" + str);
        }

        // iterate set, for set, for hashset, loop set,   HashSet
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2));
        Integer item = 1;
        if(set.contains(item))
            System.out.println("set contains element:" + 1);


        for(Integer n : set) {
            System.out.println("n=:" + n);
        }

        set.remove(item);
        int size1 = set.size();
        System.out.println("size1 =" + set.size());

        // iterate set
        for(Integer elem: set) {
            System.out.println("for elem:=" + elem);
        }

        // set to array
        Integer[] array1 = (Integer[]) set.toArray(new Integer[set.size()]);
        for(Integer n: array1) {
            System.out.println("n=:" + n);
        }

        List<Integer> list4 = new ArrayList<>(); 
        Integer[] array4 = (Integer[]) list4.toArray();

        Integer[] arr5 = {1, 2, 3};
        List<Integer> list5 = Arrays.asList(arr5);

        // list to iterator
        List<Integer> list8 = new ArrayList<Integer>();
        list8.add(1);
        list8.add(2);
        Iterator<Integer> ite = list8.iterator();
        while(ite.hasNext()) {
            System.out.println("[" + ite.next() + "]");
        }

        // double ended queue, deck
        Deque<Node> queue1 = new ArrayDeque<Node>();
        queue1.add(new Node(1));
        queue1.add(new Node(2));
        System.out.println("size[" + queue1.size() + "]");
        queue1.poll();
        System.out.println("size[" + queue1.size() + "]");

        List<String> list1 = new ArrayList<String>();
        List<String> list2 = new LinkedList<String>();
        List<String> list3 = new Stack<String>();
        List<String> list6 = new Vector<String>();
        Queue<String> queue2 = new LinkedList<String>();
        Queue<String> queue3 = new PriorityQueue<String>();
        Map<String, String> mymap = new HashMap<String, String>();
        Map<String, String> mymap1 = new Hashtable<String, String>();
        Map<String, String> mymap2 = new LinkedHashMap<String, String>();

        //]
    }
}
import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.stream.*;
import java.util.*;
import java.io.*;
import classfile.*;

// *j_json* *json* *json_array* *json_Serializable* *json_class* *j_json_example*
class Item implements Serializable {
    @SerializedName("_OrderDetails")
    private OrderDetails[] mOrderDetails;

    @SerializedName("Id")
    private String mId;
    public String getId(){
        return mId;
    }

    public OrderDetails[] getMOrderDetails(){ 
        return mOrderDetails;
    }

    @SerializedName("OrderData")
    private String mOrderDate;

    @SerializedName("Number")
    private String mNumber;

    @SerializedName("CustomerName")
    private String mCustomerName;

    @SerializedName("Note")
    private String mNote;

    // Add setters and getters

    public static class OrderDetails implements Serializable {
        @SerializedName("ProductName")
        private String mProductName;
        String getMProductName(){
            return mProductName;
        }

        @SerializedName("TotalAfterDiscount_Lc")
        private String mTotalAfterDiscount;

        @SerializedName("MeasureUnitName")
        private String mMeasureUnitName;

        @SerializedName("TotalPrice_Lc")
        private String mTotalPrice;

        @SerializedName("PricePerUnit_Lc")
        private String mPricePerUnit;

        @SerializedName("Quantity")
        private String mQuantity;

        // Add setters and getters
    }
}

public class JsonArray {
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0() {
        Aron.beg();
        String responseJSON = "[\n" +
                              "  {\n" +
                              "    \"_OrderDetails\": [\n" +
                              "      {\n" +
                              "         \"ProductName\": \"FUCHS SUPER GT SAE 10W30 6X5 / FP10100010102\",\n" +
                              "        \"TotalAfterDiscount_Lc\": \"7500\",\n" +
                              "        \"MeasureUnitName\": \"كرتونة\",\n" +
                              "        \"TotalPrice_Lc\": \"7500\",\n" +
                              "        \"PricePerUnit_Lc\": \"75\",\n" +
                              "        \"Quantity\": \"100\"\n" +
                              "      }\n" +
                              "    ],\n" +
                              "    \"Id\": \"274\",\n" +
                              "    \"OrderDate\": \"4/10/2014 12:00:00 AM\",\n" +
                              "    \"Number\": \"16\",\n" +
                              "    \"CustomerName\": \"الأسد\",\n" +
                              "    \"Note\": \"\"\n" +
                              "  }\n" +
                              "]";

        Item[] placelist;
        Gson gson = new Gson();
        placelist = gson.fromJson(responseJSON, Item[].class);
        System.out.println(Arrays.toString(placelist));
        for(Item m : placelist){
            Print.pbl(m.getId());
            for(Item.OrderDetails order : m.getMOrderDetails()){
                Print.pbl(order.getMProductName());
            }
        }

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        Aron.end();
    }
}


import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import java.util.Iterator;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;
import classfile.*;

/*
gx https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple/1.1
<!-- https://mvnrepository.com/artifact/com.googlecode.json-simple/json-simple -->
<dependency>
    <groupId>com.googlecode.json-simple</groupId>
    <artifactId>json-simple</artifactId>
    <version>1.1</version>
</dependency>
*/


// *j-json-example-array-object*   *json-example*
public class JsonArrayExample{
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        test0();
        Ut.l();
        test1();
        Ut.l();
        test2();
        Ut.l();
        test3();
        Ut.l();
        test4();
    }
    static void test0(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            // *j-json-read-file*
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/file1.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("Name");
            String author = (String) jsonObject.get("Author");
            JSONArray companyList = (JSONArray) jsonObject.get("Company List");
 
            System.out.println("Name: " + name);
            System.out.println("Author: " + author);
            System.out.println("\nCompany List:");
            Iterator<String> iterator = companyList.iterator();
            while (iterator.hasNext()) {
                System.out.println(iterator.next());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonobj.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("name");
            Print.pbl("name=" + name);
            JSONObject jsonObj = (JSONObject)jsonObject.get("obj");
            String age = (String)jsonObj.get("age");
            Print.pbl(age);
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    }

    static void test2(){
        Aron.beg();

        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonArray.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
 
            String name = (String) jsonObject.get("name");
            Print.pbl("name=" + name);
            JSONObject jsonObj = (JSONObject)jsonObject.get("product");
            String age = (String)jsonObj.get("age");
            Print.pbl(age);
            JSONArray jsonArray = (JSONArray)jsonObject.get("array"); 

            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                Print.pbl(iterator.next().get("id"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/jsonObjObj.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
            JSONArray jsonArray = (JSONArray)jsonObject.get("product"); 
            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                Print.pbl(iterator.next().get("id"));
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        Aron.end();
    } 

    static void test4(){
        Aron.beg();
        listAllCategories();
        Aron.end();
    } 

    public static void listAllCategories(){
        JSONParser parser = new JSONParser();
        try {
            Object obj = parser.parse(new FileReader("/Users/cat/myfile/github/java/text/json_product.txt")); 
 
            JSONObject jsonObject = (JSONObject) obj;
            JSONArray jsonArray = (JSONArray)jsonObject.get("products"); 
            Iterator<JSONObject> iterator = jsonArray.iterator();
            while (iterator.hasNext()) {
                JSONObject currJson = iterator.next(); 
                Print.pbl(currJson.get("id"));
                Print.pbl(currJson.get("name"));
                Print.pbl(currJson.get("category"));
                Ut.l();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}

import classfile.*;
import java.util.*;

class CharacterIterator implements Iterator<Character>{
    String str;
    int index = 0;
    public CharacterIterator(String str){
        this.str = str;
    }
    public boolean hasNext(){
        return index < str.length();
    }
    public Character next(){
        Character ch = str.charAt(index);
        index++;
        return ch;
    }
}

class MyJSon{
    public Map<String, Object> map = new HashMap<String, Object>();
}

// Json parser
class JObj{
    public String value;
    Map<String, JObj> map = new HashMap<String, JObj>();
    Map<String, ArrayList<JObj>> mapList = new HashMap<String, ArrayList<JObj>>();
    public JObj(String value){
        this.value = value;
    }
}

interface Json{
}

class Value implements Json{
    String str;
    public Value(String str){
        this.str = str;
    }
}
class JObject implements Json{
    JObject obj;
}

class JList implements Json{
    List<Json> list = new ArrayList<Json>();
}


public class JsonParser{
    public static void main(String[] args) {
        //test0();
        // this will affect the [static index]
        //test1(); 

    }
    public static void test00() {
        Aron.beg();
        MyJSon son = new MyJSon();
        List<MyJSon> list = new ArrayList<MyJSon>(); 
        son.map.put("a", "b");
        son.map.put("k", new MyJSon());
        son.map.put("k", list);

        Aron.end();
    }
    public static void test0() {
        Aron.beg();
        String str = "\"do\"";
        char[] arr = str.toCharArray();
        String name = parseName(arr);
        Print.pb(name);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        String str = "{\"a\":\"b\"}";
        CharacterIterator ite = str.iterator(); 

        JObj obj = jsonParser(ite);
        print(obj);
        Aron.end();
    }
    public static void print(JObj obj){
        if(obj != null){
            Print.pb(obj.value);
            for(Map.Entry<String, JObj> entry : obj.map.entrySet()){
                Print.pb(entry.getKey());
                print(entry.getValue());
            }
        }
    }

    // {"dog":"cat"}
    // {"dog":{"cat":"rat"}}
    // {"dog":{"cat":"rat","pig":"cow"}}
    // {"dog":[{"cat":"rat"},{"pig":"cow"}]}
    // k->o1
    // k->{01}
    // k->[{o1, o2}]
    // k->[{01}]
    /**
     * {"dog":"cat"}
     * {"dog":"cat", "cow":"rat"}
     * {"dog":{"cat":"rat"}}
     * {"dog":{"cat":"rat", "cow":"pig"}}
     * {"dog":[{"cat":"rat"}, {"cow":"pig"}]
     * dog->{<cat, rat>, <cow, pig>}
     * dog->[<cat, rat>, <cow, pig>]
     */
    static int index = 0;
    public static JObj jsonParser(Iterator<Character> ite){

        return null;
    }

    static String parseValue(char[] arr){
        return parseName(arr);
    }
    // "ab"
    // ""
    static String parseName(char[] arr){
        String str = "";
        int c = 0;
        while(index < arr.length){
            if(arr[index] != '"')
                str += arr[index];
            else{
                c++;
                if(c == 2)
                 break;
            }

            index++;
        }
        return c == 2? str : null;
    }
}
import java.util.*;

// priority heap compareto compareTo heapify heap
//[ file=kclosest.html title=""
// Compile: javac KClosestPoint.java and java KClosestPoint
// Runtime: (n*logk)
class Point{
    double x;
    double y;
    public Point(double x, double y){
        this.x = x;
        this.y = y;
    }
}

class Distance implements Comparable<Distance>{
    Point ref;
    Point point;
    public Distance(Point ref, Point point){
        this.ref = ref;
        this.point = point;
    }

    private double norm(){
        double normRef = (point.x - ref.x)*(point.x - ref.x) +  
                         (point.y - ref.y)*(point.y - ref.y);
        return normRef;
    }
    public int compareTo(Distance d){
        if(this.norm() > d.norm())
            return 1;
        else if(this.norm() == d.norm() )
            return 0;
        else 
            return -1;

    }
    public String toString(){
        return "["+ point.x +"]["+ point.y +"]";
    }
}

public class KClosestPoint {
    public static void main(String[] args) {
        test1();
    }
    public static void test1() {

        Point ref = new Point(1, 1);
        Set<Point> set = new HashSet<Point>(); 
        set.add(new Point(20, 20));
        set.add(new Point(2, 2));
        set.add(new Point(10, 10));
        set.add(new Point(2, 4));

        PriorityQueue<Distance> queue = new PriorityQueue<Distance>();
        for(Point pt : set){
            queue.add(new Distance(ref, pt)); 
        }
        int k = 3;
        while(k > 0){
            System.out.println(queue.remove().toString());
            k--;
        }
    }
}
//]

//Find a sequence of moves of a Knight on a chessboard such that the Knight visits each square only once 
public class KnightTour 
{
    public static void main(String[] args)
    {
        test1();
    }
    public static void test1()
    {
        int[][] board = new int[8][8];
        int count = 0;
        int c = 0;
        int r = 0;
        findPath(board, count, c, r);
    }
    public static void findPath(int[][] board, int count, int c, int r)
    {
        if(board != null)
        {
            if(count == 64)
            {
                Aron.printArray2D(board);
                System.exit(0);
            }
            else
            {
                board[c][r] = count+1;
                System.out.println("["+c+"]["+r+"] count="+count);

                if(c + 1 < 8 && r + 2 < 8 && board[c+1][r+2] == 0)
                    findPath(board, count+1, c+1, r+2);

                if(c + 2 < 8 && r + 1 < 8 && board[c+2][r+1] == 0)
                    findPath(board, count+1, c+2, r+1);

                if(c + 2 < 8 && r - 1 >= 0 && board[c+2][r-1] == 0)
                    findPath(board, count+1, c+2, r-1);

                if(c + 1 < 8 && r - 2 >= 0 && board[c+1][r-2] == 0)
                    findPath(board, count+1, c+1, r-2);

                if(c - 1 >= 0 && r - 2 >= 8 && board[c-1][r-2] == 0)
                    findPath(board, count+1, c-1, r-2);

                if(c - 2 >= 0 && r - 1 >= 0 && board[c-2][r-1] == 0)
                    findPath(board, count+1, c-2, r-1);

                if(c - 2 >= 0 && r + 1 < 8 && board[c-2][r+1] == 0)
                    findPath(board, count+1, c-2, r+1);

                if(c - 1 >= 0 && r + 2 < 8 && board[c-1][r+2] == 0)
                    findPath(board, count+1, c-1, r+2);

                board[c][r] = 0;
            }
        }
    }
}
public class KthMedian 
{
    public static void main(String[] args)
    {
       test1(); 
       test2(); 
       test3(); 
       test4(); 
    }
    public static void test1()
    {
        System.out.println("test1");
        int[] array = {1, 4, 2, 5, 6};
        int lo = 0, hi = array.length-1;
        int k=5;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 6);
    } 
    public static void test2()
    {
        System.out.println("test2");
        int[] array = {1, 4};
        int lo = 0, hi = array.length-1;
        int k=1;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 
    public static void test3()
    {
        System.out.println("test3");
        int[] array = {1};
        int lo = 0, hi = array.length-1;
        int k=1;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 
    public static void test4()
    {
        System.out.println("test4");
        int[] array = {2, 0, 1};
        int lo = 0, hi = array.length-1;
        int k=2;
        int median = modifiedQuickSort(array, lo, hi, k);
        System.out.println("median=["+median+"]");
        System.out.println(array[median] == 1);
    } 

    //Find the kth median element in a unsorted array
    //Return index for the kth smaller element
    //Otherwise return -1
    public static int modifiedQuickSort(int[] array, int lo, int hi, int k)
    {
        if(k <= hi - lo + 1) 
        {
            if(hi == lo && k == 1)
                return lo;
            else{
                int pindex = partition(array, lo, hi);
                int leftLen = pindex - lo;
                int rightLen = hi - pindex;
                if(pindex + 1 > k) 
                    return modifiedQuickSort(array, lo, pindex-1, k);
                else if(pindex + 1 < k)
                    return modifiedQuickSort(array, pindex+1, hi, k - (leftLen+1));
                else 
                    return pindex;
            }
        }
        return -1;
    }

    //use modified quicksort algorithm to find the kth median element
    //partition an array to two parts: left_array < pivot < right_array
    public static int partition(int[] array, int lo, int hi)
    {
        int top = lo;
        if(array != null)
        {
            int pivot = array[hi];
            for(int i=lo; i<=hi; i++)
            {
                if(array[i] < pivot)
                {
                    swap(array, i, top);
                    top++;
                }
            }
            swap(array, top, hi); 
        }
        return top;
    } 
    public static void swap(int[] array, int i, int j)
    {
        int tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
}
public class LCS 
{
    /**
     * 0               if i ==0 || j == 0
     * 
     *                  LCS(A[i-1], B[j-1]) + 1  if A[i]==B[j]
     * LCS(A[i], B[j] 
     *                  Max(LCS(A[i-1], B[j]), LCS(A[i], B[j-1]) if A[i] != B[j]
     *
     */
    public static void main(String[] args)
    {
                    System.out.println("Hello World!");
                    char[] A = {'a', 'b', 'c', 'd'}; 
                    char[] B = {'a', 'c'}; 
                    char[] Arr = new char[10];
                    int i = A.length;
                    int j = B.length;
                    int k = 0;
                    LCS(A, i, B, j, Arr, k); 
                    for(int x=0; x<2; x++)
                    {
                        System.out.println("Arr["+x+"]="+Arr[x]);
                    }
    }
    static int LCS(char[] A, int i, char[] B, int j, char[] Arr, int k)
    {
        if(i == 0 || j == 0)
        {
            return 0;
        }
        else if(A[i-1] == B[j-1])
        {
            Arr[k]=A[i-1];
            return LCS(A, i-1, B, j-1, Arr, k+1)+1;
        }
        else
        {
            return LCS(A, i-1, B, j, Arr, k)>LCS(A, i, B, j-1, Arr, k)?LCS(A, i-1, B, j, Arr, k):LCS(A, i, B, j-1, Arr, k);
        }
    }
}
import java.util.*;
import classfile.*; 

// LRU cache
// least recent used cache
// lru cache  
class Node<T> {
    Node next;
    Node prev;
    String key;
    T data;
    public Node(String key, T data) {
        next = prev = null;
        this.key = key;
        this.data = data;
    }
}

class LRU {
    Node least;
    Node most;
    int maxSize;
    int count;
    Map<String, Node<String>> map = new HashMap<String, Node<String>>();
    public LRU(int size) {
        least = most = null;
        maxSize = size;
        count = 0;
    }

    Node get(String key) {
        Node<String> node = map.get(key);
        if( node != null) {
            if(node != most) {
                remove(node.key);
                append(key, node.data);
            }
        }
        return node;
    }
    void insert(String key, String data) {
        if(!map.containsKey(key)) {
            append(key, data);
        } else {
            Node node = map.get(key);
            remove(key);
            append(key, data);
        }
    }
    void remove(String key) {
        Node curr = map.get(key);
        if( curr != null) {
            Node prev = curr.prev;
            Node next = curr.next;
            if(prev == null && next == null) {
                least = most = null;
                curr.next = curr.prev = null;
            } else if(prev != null && next == null) {
                most = prev;
                most.next = null;
                curr.next = curr.prev = null;
            } else if(prev == null && next != null) {
                least = next;
                next.prev = null;
                curr.next = curr.prev = null;
            } else {
                prev.next = next;
                next.prev = prev;
                curr.next = curr.prev = null;
            }
            map.remove(key);
            count--;
        }
    }
    void append(String key, String data) {
        if(least == null && count < maxSize) {
            Node<String> node = new Node<String>(key, data);
            least = most = node;
            map.put(key, node);
            count++;
        } else {
            if(count < maxSize) {
                Node<String> node = new Node<String>(key, data);
                most.next = node;
                node.prev = most;
                most = node;
                map.put(key, node);
                count++;
            } else {
                Node next = least.next;
                least.next = null;
                if(next != null)
                    next.prev = null;
                else
                    least = most = null;
                least = next;
                count--;
                append(key, data);
            }
        }
    }
    void print() {
        Node curr = least;
        while(curr != null) {
            System.out.println("<"+curr.key+","+curr.data+">");
            curr = curr.next;
        }
    }
}

public class LRUCache {
    public static void main(String[] args) {
        test0();
    }
    
    static void test0(){
        Aron.beg();

        System.out.println("Least Recent Used Cache");
        LRU  lru = new LRU(4);

        lru.insert("key", "mydata");
        lru.insert("key1", "mydata1");
        lru.insert("key2", "mydata2");
        lru.insert("key3", "mydata3");
        lru.insert("key4", "mydata4");
        lru.insert("key5", "mydata5");
        lru.get("key2");
        lru.insert("key3", "mydatakey3");
        lru.print();
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;


// gx /Library/WebServer/Documents/zsurface/image/lrucache.png
// LRU cache, least recent used cache, lru cache new
// In memory catche.
// e.g. memcache 
//
//
// insert - if the key is in the map, remove the node from the list
//          update the map with new node, append the node to the list
// 
//          if the list is full, remove the oldest node, and append
//          the new node to the list, and update the map with new node
//  
//          update the map with new key/node
//          update the map with new key/node
// 
class RNode{
    String key;
    String data;
    public RNode(String key, String data){
        this.key = key;
        this.data = data;
    }
}
class LRUCacheNew {
    int max;
    int count;
    List<RNode> list = new ArrayList<RNode>(); 
    Map<String, RNode> map = new HashMap<String, RNode>(); 
    public LRUCacheNew(int max){
        this.max = max;
        count = 0;
    }
    public  RNode get(String key){
        RNode node = map.get(key);
        if(node != null){
            list.remove(node);
            list.add(node);
        }
        return node;
    }

    // gx /Library/WebServer/Documents/zsurface/image/lrucache.png
    public void insert(String key, RNode node){
        RNode vnode = map.get(key);
        if(vnode != null){
            // vnode is in the list
            map.remove(vnode.key);
            list.remove(vnode);
            map.put(key, node);
            list.add(node);
        }else{
            // vnode is not in the list
            if(count < max){
                map.put(key, node);
                list.add(node);
                count++;
            }else{
                if(max > 0){
                    list.remove(0);
                    map.put(key, node);
                    list.add(node);
                }
            }
        }
    }
    public void print(){
        for(RNode node : list){
            Print.pb(node.key + " " + node.data);
        }
    }
}

public class LRUCache2{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        LRUCacheNew lru = new LRUCacheNew(3);
        RNode n1 = new RNode("k1", "data1");
        RNode n2 = new RNode("k2", "data2");
        RNode n3 = new RNode("k3", "data3");
        RNode n4 = new RNode("k4", "data4");

        lru.insert(n1.key, n1);
        lru.insert(n2.key, n2);
        lru.insert(n3.key, n3);

        lru.print();

        Ut.l();
        lru.insert(n4.key, n4);

        lru.print();
        
        Aron.end();
    }
    public static void test1(){
        Aron.beg();

        LRUCacheNew lru = new LRUCacheNew(3);
        RNode n1 = new RNode("k1", "data1");
        RNode n2 = new RNode("k2", "data2");
        RNode n3 = new RNode("k3", "data3");
        RNode n4 = new RNode("k2", "data4");
        RNode n5 = new RNode("k1", "data5");

        lru.insert(n1.key, n1);
        lru.insert(n2.key, n2);
        lru.insert(n3.key, n3);

        
        lru.print();

        Ut.l();
        lru.insert(n4.key, n4);
        Print.pb("insert k2  data4");
        lru.print();
        Ut.l();
        lru.insert(n5.key, n5);
        Print.pb("insert k1  data5");
        lru.print();

        Aron.end();
    }
} 

public class LeastDiff 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] arr = {1, 2, 3, 20, 30};
        int lo = 0;
        int hi = arr.length-1;
        int key = 5;
        int[] m = new int[1];
        m[0] = Integer.MAX_VALUE;
        LeastDiff(arr, lo, hi, key, m);
        System.out.println("m="+m[0]);
    }
    public static boolean LeastDiff(int[] arr, int lo, int hi, int key, int[] m)
    {
        if(lo <= hi)
        {
            int mid = (lo+hi)/2;
            if(key < arr[mid])
            {
                m[0] = Math.min(m[0], Math.abs(key - arr[mid]));
                return LeastDiff(arr, lo, mid-1, key, m);
            }
            else if(key > arr[mid])
            {
                m[0] = Math.min(m[0], Math.abs(key - arr[mid]));
                return LeastDiff(arr, mid+1, hi, key, m);
            }
            else
            {
                m[0] = 0;
                return true;  
            }
        }
        return false;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

class LevelOrder {
    public static Node prev = null;
    public static void main(String args[]) {
        test0();    
        test1();    
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);

        Node r = b1.getRoot();
        Queue<Node> q = new LinkedList<Node>();
        q.offer(b1.getRoot());
        LevelOrderRecursion(q);
        System.out.println("");
        LevelOrder(b1.getRoot());
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);
        LevelOrder(b1.root);
        LevelOrderOneQueue(b1.root);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Aron.end();
    } 

    //level order recursion levelorder recursion
    public static void LevelOrderRecursion(Queue<Node> q) {
        Queue<Node> q1 = new LinkedList<Node>();
        while(q.peek() != null) {
            Node node = q.poll();
            Print.pb(node.data);
            if(node.left != null)
                q1.offer(node.left);
            if(node.right != null)
                q1.offer(node.right);
        }
        System.out.println();
        if(q1.peek() != null)
            LevelOrderRecursion(q1);
    }

    // level order with one queue
    public static void LevelOrderOneQueue(Node root) {
        if(root != null){
            Queue<Node> queue = new LinkedList<Node>();
            queue.offer(root);
            while(queue.peek() != null){
                Node curr = queue.remove();
                Print.pb(curr.data);
                if(curr.left != null)
                    queue.offer(curr.left);
                if(curr.right != null)
                    queue.offer(curr.right);

            }
        }
    }

    //level order with two queues
    public static void LevelOrder(Node cur) {
        Queue<Node> Q1 = new LinkedList<Node>();
        Queue<Node> Q2 = new LinkedList<Node>();
        Q1.offer(cur);
        while(Q1.peek() != null || Q2.peek() != null) {
            while(Q1.peek() != null) {
                Node top = Q1.poll();
                System.out.print(top.data + " ");
                if(top.left != null)
                    Q2.offer(top.left);
                if(top.right != null)
                    Q2.offer(top.right);
            }
            System.out.println();
            while(Q2.peek() != null) {
                Node top = Q2.poll();

                System.out.print(top.data + " ");
                if(top.left != null)
                    Q1.offer(top.left);
                if(top.right != null)
                    Q1.offer(top.right);
            }
            System.out.println();
        }
    }
}
import java.util.*;

public class LexicographicOrder 
{
    public static void main(String[] args)
    {
        System.out.println("Try it");
        test1();
        System.out.println("===========");
        printLexico(5);
        System.out.println("===========");
        printLexico(10);
        System.out.println("===========");
        printLexico(100);
        System.out.println("===========");
        printLexico(105);
        System.out.println("===========");
        printLexico(1234);
        System.out.println("===========");
    }
    public static void printLexico(int n)
    {
        System.out.println("n=["+n+"]");
        for(int down = 1; down <10; down++)
        {
            int base = down;
            while(base <= n)
            {
                System.out.print("["+base+"] ");
                base *= 10;
            }

            base /=10;
            while(base >=10 && base <= n)
            {
                int sum = base;
                for(int i=1; i<10 && base+i <=n; i++)
                {
                    sum = base + i;
                    System.out.print("["+sum+"] ");
                }
                base = sum/10 + 1;
                if(base*10 <= n)
                    base *=10;
            }
        }
    }
    public static void test1()
    {
        String s = "abc";
        for(int i=0; i<s.length(); i++)
        {
            String str = s.substring(0, i+1);
            System.out.println("str="+str);
        }
    }
}
import java.util.List;
import java.util.ArrayList;
class Node
{
    int data;
    Node root;
    Node left;
    Node right;
    public Node(int data)
    {
        this.data = data;
        this.root = null;
        this.left = null;
        this.right = null;
    }
    public Node(Node root)
    {
        this.root = root;
    }
}
class SLinkedList
{
    Node head;
    public SLinkedList()
    {
        head = null;
    }
    public void addBST(Node root)
    {
        if(head == null)
            head = new Node(root);
        else
        {
            Node curr = head;
            while(curr.right != null)
            {
                curr = curr.right;
            }
            curr.right = new Node(root);
        }
    }
    public void add(int data)
    {
        if(head == null)
        {
            head = new Node(data);
        }
        else
        {
            Node curr = head;
            while(curr.right != null)
            {
                curr = curr.right; 
            }
            curr.right = new Node(data);
        }
    }
    public void show()
    {
        Node curr = head;
        while(curr != null)
        {
            System.out.print("["+curr.data+"]");
            curr = curr.right;
        }
    }
    public void inorder(Node r)
    {
        if( r != null)
        {
            inorder(r.left);
            System.out.print("["+r.data+"]");
            inorder(r.right);
        }
    }
    public void showBST()
    {
        Node curr = head;
        while(curr != null)
        {
            Node tmp = curr;
            inorder(tmp.root);    
            curr = curr.right;
            System.out.println("=========");
        }
    }
}

class BST
{
    Node root;
    public BST()
    {
        root = null;
    }
    public void insert(int data)
    {
        if(root == null)
        {
            root = new Node(data);
        }
        else
        {
            Node curr = root;
            boolean done = false;
            while(!done)
            {
                if(data < curr.data)
                {
                    if(curr.left != null)
                    {
                        curr = curr.left;
                    }
                    else
                    {
                        curr.left = new Node(data);
                        done = true;
                    }
                }    
                else
                {
                    if(curr.right != null)
                    {
                        curr = curr.right;
                    }
                    else
                    {
                        curr.right = new Node(data);
                        done = true;
                    }
                }
            }
        }
    }
}


public class LinkedListBST 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SLinkedList sll = new SLinkedList();
        //sll.add(1);
        //sll.add(2);
        //sll.add(3);
        //sll.add(4);
        //sll.show();

        BST bst1 = new BST();
        BST bst2 = new BST();
        BST bst3 = new BST();
        System.out.println("=========");
        bst1.insert(10); 
        bst1.insert(5); 
        bst1.insert(15); 
        bst1.insert(7); 
        bst1.insert(30); 
        bst1.insert(12); 
        bst1.insert(1); 
        bst1.insert(2); 
        bst1.insert(0); 
        inorder(bst1.root);

        System.out.println("=========");
        bst2.insert(100); 
        bst2.insert(50); 
        bst2.insert(15); 
        bst2.insert(70); 
        bst2.insert(200); 
        bst2.insert(140); 
        bst2.insert(300); 
        inorder(bst2.root);

        System.out.println("=========");
        bst3.insert(30); 
        bst3.insert(60); 
        bst3.insert(105); 
        bst3.insert(9); 
        bst3.insert(50); 
        bst3.insert(10); 
        bst3.insert(1); 
        inorder(bst3.root);


        System.out.println("=========");
        sll.addBST(bst1.root);
        sll.addBST(bst2.root);
        sll.addBST(bst3.root);
        System.out.println("=========");
        sll.showBST();

        System.out.println("----------");
        List<List<Integer>> listList = new ArrayList<List<Integer>>();
        List<Integer> list = new ArrayList<Integer>(); 
        DFS(sll.head, sll.head.root, list, listList);
    }
    public static void DFS(Node curr, Node root, List<Integer> list, List<List<Integer>> listList)
    {
        if(curr != null)
        {
            if(root != null)
            {
                DFS(curr, root.left, list, listList);
                DFS(curr, root.right, list, listList);
                if(root.left == null && root.right == null)
                {
                    //System.out.print("{"+root.data+"}");
                    list.add(root.data);
                }
                if(list.size() > 1 || (list.size() > 0 && curr.root == root))
                {
                    System.out.println("");
                    List<Integer> tmpList = new ArrayList<Integer>(list);
                    listList.add(tmpList);
                    list.clear();
                    if(curr.right != null)
                    {
                        DFS(curr.right, curr.right.root, list, listList);
                        list.clear();
                        if(listList.size() > 0)
                            listList.remove(listList.size()-1);
                    }
                    else
                    {
                        for(List<Integer> mylist : listList)
                        {
                            for(Integer num : mylist)
                            {
                                System.out.print("["+num+"]");
                            }
                            System.out.println();
                        }
                        if(listList.size() > 0)
                            listList.remove(listList.size()-1);
                    }
                }
            }
        }
    }
    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
            System.out.print("["+node.data+"]");
            inorder(node.right);
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class LinkedListToBST{
    public static void main(String[] args) {
        //test0_buildTree();
        test01_buildTree();
        test2_middleLinkedList();
        test3_middleLinkedList();
        test4_buildTree2();
        test0_buildTree3();
        test0_buildTree4();
    }
    static void test0_buildTree() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int lo = 0;
        int hi = arr.length-1;
        Node root = buildTree(arr, lo, hi);
        Aron.levelOrder(root);
        Aron.inorder(root);
        Aron.binImage(root);

        Aron.end();
    }

    static void test01_buildTree() {
        Aron.beg();
        int[] arr = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14};
        int lo = 0;
        int hi = arr.length-1;
        Node root = buildTree(arr, lo, hi);
        Aron.levelOrder(root);
        Aron.inorder(root);
        Aron.binImage(root);

        Aron.end();
    }
    public static Node buildTree(int[] arr, int lo, int hi) {
        if(lo <= hi) {
            int mid = 0;
            if ((lo + hi)%2 == 1)
                mid = (lo + hi)/2 + 1;
            else
                mid = (lo + hi)/2;
            Node parent = new Node(arr[mid]);
            parent.left = buildTree(arr, lo, mid-1);
            parent.right = buildTree(arr, mid+1, hi);
            return parent;
        }
        return null;
    }
    static int index = 0;
    public static Node buildTree2(int[] arr, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree2(arr, count/2);
            Node parent = new Node(arr[index]);
            parent.left = left;

            index++;
            parent.right = buildTree2(arr, count - count/2 - 1);
            return parent;
        }
    }

    public static Node buildTree3(Iterator<Integer> ite, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree3(ite, count/2);
            Node parent = new Node(ite.next());
            parent.left = left;

            parent.right = buildTree3(ite, count - count/2 - 1);
            return parent;
        }
    }

    static void test0_buildTree3(){
        Aron.beg();
        Integer[] arr = {1, 2, 3, 4}; 
        final Iterator<Integer> ite = Arrays.asList(arr).iterator();
        int count = arr.length;
        Node parent = buildTree3(ite, count);
        Aron.inorder(parent);
        Aron.line();
        Aron.preorder(parent);

        Aron.end();
    }

    static void test0_buildTree4(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);

        int count = 3;
        Node parent = buildTree4(sll.head, count);

        Aron.inorder(parent);
        Ut.l();
        Aron.preorder(parent);

        Aron.end();
    }
    public static Node buildTree4(Node curr, int count){
        if(count == 0)
            return null;
        else{
            Node left = buildTree4(curr, count/2);
            Node parent = new Node(curr.data);
            parent.left = left;
            parent.right = buildTree4(curr.next, count - count/2 - 1);
            return parent;
        }
    }

    public static Node middleLinkedList(Node head){
        int steps = 2;
        int count = 0;

        Node first = head;
        if(first != null) {
            Node second = first.next;
            while(second != null && second.next != null) {
                first = first.next;
                while(count < steps && second != null) {
                   second = second.next;
                    count++;
                }
                steps++;
                count = 0;
            }
        }
        return first;
    }

    static void test2_middleLinkedList(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        sll.append(3);
        sll.append(4);
        Aron.printSLL(sll.head);
        Node node = middleLinkedList(sll.head);
        Test.t(node.data, 2);

        Aron.end();
    } 
    static void test3_middleLinkedList(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        sll.append(1);
        sll.append(2);
        Aron.printSLL(sll.head);
        Node node = middleLinkedList(sll.head);
        Test.t(node.data, 1);

        Aron.end();
    } 
    
    static void test4_buildTree2(){
        Aron.beg();
        SingleLinkedList sll = new SingleLinkedList();
        
        
        int[] arr = {1, 2, 3, 4}; 
        int index = 0;
        int count = arr.length;

        Node parent = buildTree2(arr, count);
        Aron.levelOrder(parent);
        Aron.inorder(parent);

        Aron.end();
    }
}

import classfile.*;

class LinkedListToBST2 {
    /* head node of link list */
    static LNode head;

    /* Link list Node */
    class LNode {
        int data;
        LNode next, prev;

        LNode(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* A Binary Tree Node */
    class TNode {
        int data;
        TNode left, right;

        TNode(int d) {
            data = d;
            left = right = null;
        }
    }

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    TNode sortedListToBST() {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --> No. of nodes in the Doubly Linked List */
    TNode sortedListToBSTRecur(int n) {
        /* Base Case */
        if (n <= 0)
            return null;

        /* Recursively construct the left subtree */
        TNode left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        TNode root = new TNode(head.data);

        // Set pointer to left subtree
        root.left = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.right = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(LNode head) {
        int count = 0;
        LNode temp = head;
        while (temp != null) {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        LNode new_node = new LNode(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList(LNode node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(TNode node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    /* Drier program to test above functions */
    public static void main(String[] args) {
        LinkedListToBST2 llist = new LinkedListToBST2();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7->6->5->4->3->2->1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList(head);

        /* Convert List to BST */
        TNode root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}

import classfile.*;

class LinkedListToBalancedBST {
    /* head node of link list */
    static LNode head;

    /* Link list Node */
    class LNode {
        int data;
        LNode next, prev;

        LNode(int d) {
            data = d;
            next = prev = null;
        }
    }

    /* A Binary Tree Node */
    class TNode {
        int data;
        TNode left, right;

        TNode(int d) {
            data = d;
            left = right = null;
        }
    }

    /* This function counts the number of nodes in Linked List
       and then calls sortedListToBSTRecur() to construct BST */
    TNode sortedListToBST() {
        /*Count the number of nodes in Linked List */
        int n = countNodes(head);

        /* Construct BST */
        return sortedListToBSTRecur(n);
    }

    /* The main function that constructs balanced BST and
       returns root of it.
       n  --> No. of nodes in the Doubly Linked List */
    TNode sortedListToBSTRecur(int n) {
        /* Base Case */
        if (n <= 0)
            return null;

        /* Recursively construct the left subtree */
        TNode left = sortedListToBSTRecur(n / 2);

        /* head_ref now refers to middle node,
           make middle node as root of BST*/
        TNode root = new TNode(head.data);

        // Set pointer to left subtree
        root.left = left;

        /* Change head pointer of Linked List for parent
           recursive calls */
        head = head.next;

        /* Recursively construct the right subtree and link it
           with root. The number of nodes in right subtree  is
           total nodes - nodes in left subtree - 1 (for root) */
        root.right = sortedListToBSTRecur(n - n / 2 - 1);

        return root;
    }

    /* UTILITY FUNCTIONS */
    /* A utility function that returns count of nodes in a
       given Linked List */
    int countNodes(LNode head) {
        int count = 0;
        LNode temp = head;
        while (temp != null) {
            temp = temp.next;
            count++;
        }
        return count;
    }

    /* Function to insert a node at the beginging of
       the Doubly Linked List */
    void push(int new_data) {
        /* allocate node */
        LNode new_node = new LNode(new_data);

        /* since we are adding at the begining,
           prev is always NULL */
        new_node.prev = null;

        /* link the old list off the new node */
        new_node.next = head;

        /* change prev of head node to new node */
        if (head != null)
            head.prev = new_node;

        /* move the head to point to the new node */
        head = new_node;
    }

    /* Function to print nodes in a given linked list */
    void printList(LNode node) {
        while (node != null) {
            System.out.print(node.data + " ");
            node = node.next;
        }
    }

    /* A utility function to print preorder traversal of BST */
    void preOrder(TNode node) {
        if (node == null)
            return;
        System.out.print(node.data + " ");
        preOrder(node.left);
        preOrder(node.right);
    }

    /* Drier program to test above functions */
    public static void main(String[] args) {
        LinkedListToBalancedBST llist = new LinkedListToBalancedBST();

        /* Let us create a sorted linked list to test the functions
           Created linked list will be 7->6->5->4->3->2->1 */
        llist.push(7);
        llist.push(6);
        llist.push(5);
        llist.push(4);
        llist.push(3);
        llist.push(2);
        llist.push(1);

        System.out.println("Given Linked List ");
        llist.printList(head);

        /* Convert List to BST */
        TNode root = llist.sortedListToBST();
        System.out.println("");
        System.out.println("Pre-Order Traversal of constructed BST ");
        llist.preOrder(root);
    }
}

// This code has been contributed by Mayank Jaiswal(mayank_24)
import java.util.*;

public class ListAndSet 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
        test3();
        test4();
    }
    public static Set<Integer> clone(Set<Integer> set)
    {
        Set<Integer> s = new LinkedHashSet<Integer>(); 
        for(Integer ele: set)
            s.add(ele);

        return s;
    }
    public static void test1()
    {
        System.out.println("test1"); 
        int[] list = {1, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2)); 
        System.out.println(match(list, set));

    } 
    public static void test2()
    {
        System.out.println("test2"); 
        int[] list = {1, 4, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2)); 
        System.out.println(match(list, set));

    } 
    public static void test3()
    {
        System.out.println("test3"); 
        int[] list = {2, 4, 3, 1, 2};
        Set<Integer> set = new HashSet<Integer>(Arrays.asList(1, 2, 3)); 
        System.out.println(match(list, set));
    } 
    public static void test4()
    {
        System.out.println("test4"); 
        int[] list = {2, 4, 3, 1, 2};
        Set<Integer> set = new HashSet<Integer>(); 
        System.out.println(match(list, set));
    } 
    public static boolean match(int[] list, Set<Integer> set)
    {
        Set<Integer> set1 = clone(set);
        if( list != null && set != null)
        {
            if(set1.isEmpty())
                return true;

            boolean start = false;
            for(int ele: list)
            {
                if(set1.contains(ele))
                {
                    set1.remove(ele);
                    start = true; 
                }
                else{
                    if(start)
                        set1 = clone(set);           
                    start = false;
                }

                if(set1.isEmpty())
                    return true;
            }
        }
        return false;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

//[ file=lock.html title=""
class MyLock{
    private boolean isLocked = false;

    public synchronized boolean lock(){
        if(!isLocked){
            isLocked = true;
            return isLocked;
        }
        return false;
    }
    public synchronized void unlock(){
        isLocked = false;
        notify();
    }
}
//]

public class LockExample{
    public static void main(String[] args) {
    }
    public static void print(){
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

import java.util.logging.Level;
import java.util.logging.FileHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;


// logger, logging example, logger example, java logger
public class LoggerExample{
    private final static Logger LOGGER = Logger.getLogger(LoggerExample.class.getName());
    static private FileHandler fileTxt;
    static private SimpleFormatter formatterTxt;

    public static void main(String[] args) {
        try{
            test0();
        }catch(IOException e){
        }
    }
    public static void test0() throws IOException {
        Aron.beg();

        fileTxt = new FileHandler("./text/Logging.txt");
        formatterTxt = new SimpleFormatter();
        LOGGER.setLevel(Level.INFO);
        fileTxt.setFormatter(formatterTxt);
        LOGGER.addHandler(fileTxt);

        LOGGER.info("Logging an INFO-level message {0}");
        

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

public class LongestContinuousSum 
{
    public static void main(String[] args)
    {
        test0(); 
        test1(); 
        test2(); 
        test3(); 
        test4(); 
        test5(); 
        test6(); 
        test7(); 
        test8(); 
    }
    public static int Sum(int[] array)
    {
        int max = 0;
        if(array != null)
        {
            int len = array.length;
            int[] result = new int[len];
            if(len > 0)
            {
                result[0] = array[0];
                for(int i=1; i<len; i++)
                {
                    result[i] = result[i-1] + array[i] > array[i] ? result[i-1] + array[i] : array[i];
                }
                for(int i=0; i<len; i++)
                {
                    if(max < result[i])      
                        max = result[i];
                }
            }
        }
        return max;
    }

    public static void test0()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 8, -5, 20, 3, -2}; 
        int max = Sum(array);
        System.out.println("max=" + max);
    }

    public static void test1()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{1, -5, 8, -2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test2()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{1, -5, 8, 4, -2, 3, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test3()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 1, -5, 8, 4, -2, 3, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test4()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 4, 2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test5()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2, 4, 2, -8}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test6()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{-2}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }

    public static void test7()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{8}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void test8()
    {
        System.out.println("Hello World!");
        int[] array =new int[]{8, -1}; 
        Aron.printArray(array);
        maxSumWithIndex(array);
        System.out.println();
    }
    public static void maxSumWithIndex(int[] array)
    {
        if(array != null && array.length > 0)
        {
            int len = array.length;
            int[] maxArr = new int[len];
            maxArr[0] = array[0]; 

            int first = 0;
            int second = 0;
            int max = array[0];
            for(int i=1; i < len; i++)
            {
                maxArr[i] = Math.max(maxArr[i-1] + array[i], array[i]);            
                if(maxArr[i] > max)
                {
                    if(i-1 >=0 && maxArr[i-1] < 0)
                        first = i;
                    second = i;
                    max = maxArr[i];
                }
            }

            /*
            max = maxArr[0];
            for(int i=1; i<len; i++)
                if(maxArr[i] > max)
                    max = maxArr[i];
            */
            System.out.println("max=" + max);
            System.out.println("first=" + first);
            System.out.println("second=" + second);
        }
    }
}
import java.io.*;

class LongestEmptyArray 
{
	public static void main(String args[])
	{
		// 0 means empty
		// 1 means non-empty 
		int[] Arr = {0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0}; 
		System.out.println("cool");
		int max = Longest(Arr);
		System.out.println("max=" + max);
	}
	// go right and go down
	public static int Longest(int[] Arr)
	{
		int max=0;
		if( Arr != null)
		{
			int len = Arr.length;
			int[] A = new int[len];

			if(Arr[0] == 0)
				A[0] = 1;
			else 
				A[0] = 0;

			for( int i=1; i<len; i++)
			{ if(Arr[i] == 0)
					A[i] = A[i-1]+1;	
			}
			
			for(int i=0; i<len; i++)
			{
				if(A[i] > max)
					max = A[i];
			}
		}		
		return max;
	}
}
import classfile.*;

public class LongestIncreasingSubsequence {
    public static void main(String[] args) {
        //test0();
        test1();
        test2();
        test3();
        test4();
    }

    static void test0() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        int m = LISDP(array);

        System.out.println();
        int recm = LISRecursion(array, len);
        int len2 = array.length;
        System.out.println("==========================");
        int recm2 = LISRecursion2(array, len2);
        System.out.println("max LIS=["+m+"]");
        System.out.println("max LISRecursion=["+recm+"]");
        System.out.println("max LISRecursion2=["+recm2+"]");
        System.out.println("==========================");
        LISTree(array, len2);

        Aron.end();
    }

    static void test1() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        Aron.printArray(array);
        int len = array.length;
        int max = LISRecursion(array, len);

        System.out.println("LISRecursion=["+ max +"]");
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        Integer[] array = {1, 0, 7, 2, 6};
        Aron.printArray(array);
        int len = array.length;
        int max = LISRecursion2(array, len);
        System.out.println("LISRecursion2=["+ max +"]");

        Aron.end();
    }

    static void test3() {
        Aron.beg();

        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        LISTree(array, len);

        Aron.end();
    }

    static void test4() {
        Aron.beg();

        Integer[] array = {1, 0, 7, 2, 6};
        int len = array.length;
        Aron.printArray(array);
        LISRecursion_debug(array, len);

        Aron.end();
    }

    //L[i] = 1 + Max(L[i-1]) where j < i && arr[j] < arr[i]
    public static int LISRecursion_debug(Integer[] array, int len) {
        if(len == 1)
            return 1;
        else {
            int max = 1;
            for(int i=1; i < len; i++) {
                int m = LISRecursion_debug(array, i);
                //System.out.print("array["+(i-1)+"]="+array[i-1]+" array["+(len-1)+"]="+array[len-1]+"\n");
                System.out.print("("+ array[i-1] + " , "+ array[len-1] + ")");
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
                //System.out.println("max=["+max+"]");
            }
            System.out.println();
            return max;
        }
    }


    //Find the longest increasing subsequence integers
    //{2, 4, 1, 5} => 2->4->5
    //{2, 4, 1, 2, 3} => 1->2->3
    //L[i] = 1 + Max(L[i-1]) where j < i && arr[j] < arr[i]
    public static int LISRecursion(Integer[] array, int len) {
        if(len == 1)
            return 1;
        else {
            int max = 1;
            for(int i=1; i < len; i++) {
                int m = LISRecursion(array, i);
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
            }
            System.out.println();
            return max;
        }
    }

    public static void LISTree(Integer[] array, int len) {
        if(len == 1) {
            //System.out.println("["+array[len-1]+"]");
        } else {
            for(int i=1; i<len; i++) {
                LISTree(array, i);
                System.out.println("["+array[i-1]+"]->["+array[len-1]+"]");
            }
        }
    }
    public static int LISRecursion2(Integer[] array, int len) {
        int max = 1;
        if(len == 1)
            return max;
        else {
            for(int i=1; i<len; i++) {
                int m = LISRecursion2(array, len-1);
                System.out.print("array["+(i-1)+"]="+array[i-1]+" array["+(len-1)+"]="+array[len-1]+"\n");
                if(array[i-1] < array[len-1])
                    max = Math.max(max, m+1);
            }
            System.out.println("-----------------------");
        }
        return max;
    }

    //Dynamic programming algorithm solves Longest Increasing Subsequence
    //with complexity O(n^2)
    public static int LISDP(Integer[] array) {
        int len = array.length;
        int[] maxlist = new int[len];
        for(int i=0; i<len; i++)
            maxlist[i] = 1;

        for(int i=1; i<len; i++) {
            for(int j=0; j<i; j++) {
                if(array[j] < array[i])
                    maxlist[i] = Math.max(1 + maxlist[j], maxlist[i]);
            }
        }

        int m = Integer.MIN_VALUE;
        for(int i=0; i<len; i++) {
            if(maxlist[i] > m)
                m = maxlist[i];
        }
        return m;
    }
}
    //Dynamic programming algorithm solves Longest Increasing Subsequence
    //with complexity O(n^2)
    public static int LISDP(int[] array)
    {
        int len = array.length;
        int[] maxlist = new int[len];
        for(int i=0; i<len; i++)
            maxlist[i] = 1;

        for(int i=1; i<len; i++)
        {
            for(int j=0; j<i; j++)
            {
                if(array[j] < array[i])            
                    maxlist[i] = Math.max(1 + maxlist[j], maxlist[i]);
            }            
        } 
        
        int m = Integer.MIN_VALUE;
        for(int i=0; i<len; i++)
        {
            if(maxlist[i] > m)
                m = maxlist[i];
        }
        return m;
    }
import java.io.*;
import java.lang.String;
import java.util.*;
class LongestPalindrome 
{
	public static void main(String args[])
	{
        longest("abc");
	}
    public static void longest(String str){
        int len = str.length();
        int newStr = "";
        for(int i=0; i<len-1; i++){
            newstr += str.charAt(i);
        }
        System.out.println(newStr);
    }

    //complexity O(N^2)
    public static String longest2(String str)
    {
        String palindrome = "";
        if(str != null)
        {
            String newStr = "#";
            for(int i=0; i<str.length(); i++)
            {
                newStr += str.charAt(i) + "#";
            }

            int len = newStr.length();
            int maxoffset = 0;
            for(int i=0; i<len; i++)
            {
                for(int offset=0; offset<len; offset++)
                {
                    if(i-offset >= 0 && i+offset<len && newStr.charAt(i-offset) == newStr.charAt(i+offset))
                    {
                        if(offset > maxoffset)
                        {
                            maxoffset = offset;
                            palindrome = newStr.substring(i-offset, i+offset+1);
                        }
                    }
                }
            }
            String tmpStr = "";
            for(int i=0; i<palindrome.length(); i++)
            {
                if(palindrome.charAt(i) != '#')
                    tmpStr += palindrome.charAt(i) + ""; 
            }
            palindrome = tmpStr;
        }
        return palindrome;
    }
    //complexity O(n)
    public static void logestPalindrome(String str)
    {
        if( str != null)
        {
            String newStr = "#";
            for(int i=0; i<str.length(); i++)
            {
                newStr += str.charAt(i) + "#"; 
            }
            int len = newStr.length();
            int[] p = new int[len];
            int c=1;
            int rightEdge = 0;
            for(int i=1; i<len; i++)
            {
                int j = c-(i-c);
                if(p[j] < rightEdge-c)
                   p[i] = p[j];
                else 
                   p[i] = rightEdge-c ;
                while(i-p[i] >= 0 && p[i-p[i]] == p[i+p[i]])
                {
                    p[i]++;
                }
                if(i+p[i] > rightEdge)
                {
                    rightEdge = i+p[i];
                    c = i;
                }
            }
            System.out.println("p="+p);
        }
    }

    public static void test1()
    {
        String s = "abbcc";
        int d = 0;
        int offset = 0;
        String[] maxArr = new String[1];
        longestPalindromeRecursion(s, d, offset, maxArr);
        System.out.println("s="+s);
        System.out.println("pal=" + maxArr[0]);
    }

    public static void test2()
    {
        String s = "abccb";
        int d = 0;
        int offset = 0;
        logestPalindrome(s);
        System.out.println("s="+s);
    }


    public static void longestPalindromeRecursion(String s, int d, int offset, String[] maxArr)
    {
        if(offset < s.length())
        {
            substring(s, d, offset, maxArr);
            longestPalindromeRecursion(s, d, offset+1, maxArr);
        }
    }
    public static void substring(String s, int d, int offset, String[] maxArr)
    {
        if(offset + d + 1 <= s.length())
        {
            String str = s.substring(offset, offset + d+1);
            if(isPalindrome(str, d))
            {
                if(maxArr[0] != null) 
                {
                    if(str.length() > maxArr[0].length())
                        maxArr[0] = str;
                }
                else
                    maxArr[0] = str;
                    
            }
            substring(s, d+1, offset, maxArr);
        }
    }
    public static boolean isPalindrome(String s, int i)
    {
        if(s.length() <= 1)
            return true;
        else if(s.charAt(i) != s.charAt(s.length()-1-i))
            return false;
        else
        {
            if(i+1 <s.length() && s.length() > 2)
                return isPalindrome(s.substring(i+1, s.length()-2), i+1);
            return true;
        }
    }
}
public class LongestPalindromeSubstringN2 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int maxlen = longestPalindromeSubstring("abkbc");
        System.out.println("maxlen="+maxlen);
    }
    public static int longestPalindromeSubstring(String str)
    {
        int maxlen = 0;
        if(str != null && str.length() > 1)
        {
            int len = str.length();
            maxlen = 1;
            for(int i=0; i<len; i++)
            {
                int currlen = 0;
                for(int j=0; j<len; j++)
                {
                    if(i+1 < len && str.charAt(i) == str.charAt(i+1))
                    {
                        if(i-j >=0 && i+1+j < len && str.charAt(i-j) == str.charAt(i+1+j))
                        {
                            if(j==0)
                                currlen +=1;
                            else 
                            {
                                if(currlen > maxlen)
                                    maxlen = currlen;
                            }
                        }
                    }
                    else 
                    {
                        if(i-j >= 0 && i+j < len && str.charAt(i-j) == str.charAt(i+j))
                        {
                            currlen += 2;
                            if(currlen > maxlen)
                                maxlen = currlen;
                        }
                    }
                }
            }
        }
        return maxlen;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*; 

class LowestCommonAncestor{
    public static Node prev = null;
    public static void main(String args[]) {
        test0_findNode();
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }
    public static void test0_findNode() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        Node r = findNode(b1.root, 17);
        Test.t(r.data, 17);

        Aron.end();
    }


    public static void test00() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(7);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);
        b1.insert(1);
        b1.insert(11);

        Node r = b1.getRoot();
        Node lca = LCABinTree(r, 12, 15);
        System.out.println("lca.data=" + lca.data);
        Aron.end();
    }

    public static void test0() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        Node lca = LCA2(b1.root, 1, 7);
        if(lca != null)
            Test.t(lca.data, 5);

        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7); 
        Node lca = LCA2(b1.root, 5, 7);
        Test.t(lca.data, 5);

        Aron.end();
    }

    public static void test2() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        b1.insert(15);
        b1.insert(18);
        b1.insert(19);
        b1.insert(35);
        Node lca = LCA2(b1.root, 15, 35);
        Test.t(lca.data, 15);
        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        b1.insert(15);
        Node lca = LCA2(b1.root, 12, 15);
        Test.t(lca.data, 12);
        //Aron.binImage(b1.root);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(12);
        Node lca = LCA2(b1.root, 10, 12);
        Test.t(lca.data, 10);

        Aron.end();
    }

    public static void test5() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(11);
        b1.insert(12);
        Node lca = LCA2(b1.root, 12, 10);
        Test.t(lca.data, 10);

        Aron.end();
    }


//    public static Node LCA(Node r, int value1, int value2) {
//        Node ret=null;
//        if(r != null) {
//            if((r.left != null && (value1 == r.left.data || value2 == r.left.data)) ||
//                    (r.right != null && (value1 == r.right.data || value2 == r.right.data)))
//                ret = r;
//            else if(value1 < r.data && value2 < r.data)
//                ret=LCA(r.left, value1, value2);
//            else if(value1 > r.data && value2 > r.data)
//                ret=LCA(r.right, value1, value2);
//            else
//                ret = r;
//        }
//        return ret;
//    }
//
    //[ file=findnode.html title=""
    public static Node findNode(Node root, int n){
        if(root != null){
            if( root.data == n)
                return root;
            Node l = findNode(root.left, n);
            Node r = findNode(root.right, n);
            if(l != null)
                return l;
            else if(r != null)
                return r;
        }
        return null;
    }
    //]

    //[ file=lcanew.html title=""
    public static Node LCA_BasedOnFindNode(Node r, int n1, int n2){
        if(r != null){
            if(r.data == n1 || r.data == n2)
                return r;

           Node left = LCA_BasedOnFindNode(r.left, n1, n2); 
           Node right = LCA_BasedOnFindNode(r.right, n1, n2);

           if(left != null && right != null)
               return r;
           else if(left != null)
               return left;
           else if(right != null)
               return right;
           
        }
        return null;
    }
    //]

    public static Node LCA(Node root, int n1, int n2){
        if(root != null){
            if( root.data == n1 || root.data == n2)
                return root;

            Node l = LCA(root.left, n1, n2);
            Node r = LCA(root.right, n1, n2);
            if(l != null && r != null)
                return root;
            else if(l != null)
                return l;
            else if(r != null)
                return r;
        }
        return null;
    }
    public static Node LCA2(Node r, Node n1, Node n2) {
        Node ret=null;
        if(r != null && n1 != null && n2 != null) {
            if( r.left != null && (r.left.data == n1.data || r.left.data == n2.data) ||
                    r.right != null && (r.right.data == n1.data || r.right.data == n2.data))
                ret = r;
            else if(n1.data < r.data && n2.data < r.data)
                ret=LCA2(r.left, n1, n2);
            else if(n1.data > r.data && n2.data > r.data)
                ret=LCA2(r.right, n1, n2);
            else
                ret=r;
        }
        return ret;
    }

    //LCA for Binary Tree
    public static Node LCABinTree(Node r, int value1, int value2) {
        if( r != null) {
            if( r.data == value1 || r.data == value2)
                return r;
            Node nl = LCABinTree(r.left, value1, value2);
            Node nr = LCABinTree(r.right, value1, value2);
            if( nl != null && nr != null)
                return r;
            else if( nl != null)
                return nl;
            else if( nr != null)
                return nr;

        }
        return null;
    }

    public static boolean equalBinaryTree(Node r1, Node r2) {
        if(r1==null && r2==null)
            return true;
        else if(r1 != null && r2 != null) {
            if(r1.data != r2.data)
                return false;
            if(!equalBinaryTree(r1.left, r2.left))
                return false;
            if(!equalBinaryTree(r1.right, r2.right))
                return false;
        } else
            return false;
        return true;
    }

    // lowest common ancestor, least common ancestor, lca, LCA
    public static Node LCA2(Node root, int n1, int n2) {
    if(root != null){
        if(root.data == n1 || root.data == n2)
            return root;

        Node l = LCA2(root.left, n1, n2);
        Node r = LCA2(root.right, n1, n2);
        if(l != null && r != null)
            return root;
        else if( l != null)
            return l;
        else if( r != null)
            return r;
    }
    return null;
    }

}
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.List;

public class  MagicSquareSolver{ 
 public static void main(String[] args) {
        System.out.println("Hello World!");
        MagicSquare mag = new MagicSquare();
        mag.test2();
    }
    static String remove(String str, int k){
        String s = "";
        for(int i=0; i<str.length(); i++){
            if(i != k)
                s += str.charAt(i) + "";
        }
        return s;
    }

    static void perm(String prefix, String str){
        if(str.length() == 0){
            System.out.println(prefix);
        }
        else{
            for(int i=0; i<str.length(); i++){
                perm(prefix + str.charAt(i), remove(str, i));
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Majority 
{
	public static void main(String args[])
	{
	  int[] A={2, 3, 2}; 
		System.out.println(majority(A));
	}
	public static boolean majority(int[] A)
	{
		boolean ret = false;
		if( A != null)
		{
			int len = A.length;
			if(len == 1)
				ret = true;
			else if(len > 1)
			{
				int c=1;
				int mj=0;
				for(int i=1; i<len; i++)
				{
					if(A[mj] == A[i])
					 c++; 
					else
					{ c--;
						if(c == 0)
						{ mj = i; c=1;}
					}
				}
				int count=0;
				for(int i=0; i<len; i++)
				{
					if(A[mj] == A[i])
						count++;
				}
				if(count > len/2)
					ret = true;
			}
		}
		return ret;
	}
}

import java.io.*;
import java.util.*;
public class ManhattanProblem {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        int[][] array2d = new int[3][2];

        System.out.println("array2.length="+array2d.length);
        System.out.println("array2[0].length="+array2d[0].length);

        for(int i=0; i<3; i++)
        {
            for(int j=0; j<2; j++)
                System.out.print("["+array2d[i][j]+"]");
            System.out.println();
        }

        test8();
        test9();
        test10();
        test11();
    }
    public static boolean man(int[][] arr, int c, int r, ){
    }
    
    public static int[][] readFile(){
        int[][] array2d = null;
        try {
            BufferedReader bufferReader = new BufferedReader(new InputStreamReader(System.in));
            int count =0;
            int numRow = 0;
            String line = null;
            int row = 0;
            while((line = bufferReader.readLine()) != null){
                String[] array = line.split(" ");
                if(count == 0){
                    if(array.length > 0){
                        numRow = Integer.parseInt(array[0]);
                        array2d  = new int[numRow][numRow];
                    }
                } 
                else{
                    if(numRow != array.length){
                        System.out.print("ERROR"); 
                        return null;
                    }else{
                        for(int i=0; i<array.length; i++){
                            array2d[row][i] = Integer.parseInt(array[i]);        
                        }
                    }
                    row++;
                }
                count++;
            }
        } catch (Exception e) {
        }
        return array2d;
    }

    public static void test8() {
        System.out.println("test8");
        int[][] arr = { 
            {1,3,3},
            {0,3,9},
            {0,3,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 3;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                ret = manhattan(arr, h, w, k, arr[h][w]); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    }

    public static void test11() {
        System.out.println("test11");
        int[][] arr = { 
            {0,3,1},
            {0,1,4},
            {7,1,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 4;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    }

    public static void test10() {
        System.out.println("test10");
        int[][] arr = { 
            {1,3,6},
            {0,4,4},
            {7,9,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 4;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    }

    public static void test9() {
        System.out.println("test9");
        int[][] arr = { 
            {1,3,6},
            {0,4,4},
            {7,9,1}
        };

        int height = arr.length;
        int width = arr[0].length;

        int k = 1;
        boolean ret = false; 
        for(int h=0; h<height && !ret; h++){ 
            for(int w=0; w<width && !ret; w++){
                int num = arr[h][w];
                ret = manhattan(arr, w, h, k, num); 
                System.out.println("ret =" + ret);
            }
        }
        System.out.println("--ret =" + ret);
    } 
    //[file=manhattan.html title=""
    public static boolean manhattan(int[][] arr, int h, int w, int k, int num){
        final int visited = -1000; 
        boolean ret0 = false;
        boolean ret1 = false;
        boolean ret2 = false;
        boolean ret3 = false;
        boolean ret4 = false;
        int height = arr.length;
        int width = arr[0].length;

        if( k == 0){
            ret0 = num == arr[h][w];
        }else if(arr[h][w] != visited){
            int tmp = arr[h][w];
            arr[h][w] =  visited;
            if(w + 1 < width){
                 arr[h][w] = visited;
                 ret1 = manhattan(arr, h, w+1,k-1, num);
                 arr[h][w] = tmp;
                 if(ret1)
                     return ret1;
             }

            if(w - 1 >= 0){
                 arr[h][w] = visited;
                 ret2 = manhattan(arr,  h, w-1,k-1, num);
                 arr[h][w] = tmp;
                 if(ret2)
                     return ret2;
             }

            if(h - 1 >= 0){
                 ret3 = manhattan(arr,  h-1, w, k-1, num);
                 arr[h][w] = tmp;
                 if(ret3)
                     return ret3;
             }

             if(h + 1 < height){
                 ret4 = manhattan(arr, h+1, w, k-1, num);
                 arr[h][w] = tmp;
                 if(ret4)
                     return ret4;
             }
        }
        return ret0 || ret1 || ret2 || ret3 || ret4;
    }
}
import java.io.*;
import java.util.*;
class Mapdemo
{
	public static void main(String args[])
	{
		Map ml = new HashMap();		
		ml.put("cool", "89");
		System.out.println(ml);

		if(ml.containsKey("cool"))
		{
			System.out.println("yup");
		}
		else
		{
			System.out.println("no");
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MatchNum{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
    }
    public static void test0(){
        Aron.beg();
        String str = "12";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String str = "1200";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        String str = "a";
        boolean isNum = isNumeric(str);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        String str = "0314";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);
        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        String str = "-123";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        String str = "0";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test8(){
        Aron.beg();
        String str = "+12";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == true);

        Aron.end();
    }
    public static void test9(){
        Aron.beg();
        String str = "+";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test10(){
        Aron.beg();
        String str = "-";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }
    public static void test11(){
        Aron.beg();
        String str = "+-";
        boolean isNum = isNumeric(str);
        Print.pbl("isNum=" + isNum);
        Test.t(isNum == false);

        Aron.end();
    }

    // is positive Integer from [-n -1 0 1 n] 
    public static boolean isNumeric(String str){
        //return str.matches("[1-9][0-9]+");
        return str.matches("[-+]?[1-9][0-9]*|0");
    }
} 

public class MatrixDiagonal {
    public static void main(String[] args) {
        int[][] array = { {1, 2, 3, 4},
            {2, 3, 4, 5},
            {6, 7, 9, 8},
            {3, 2, 1, 2}
        };
        int len = array.length;
        for(int i=0; i<len; i++) {
            for(int j=0; j<len; j++) {
                System.out.print("["+array[i][j]+"]");
            }
            System.out.println("");
        }

        System.out.println("Print all diagonals of matrix");
        printDiagonal(array);
    }
    //Given square matrix
    public static void printDiagonal(int[][] array) {
        if(array != null) {
            int len = array.length;
            for(int i=0; i<2*len-1; i++) {

                for(int j=0; j<len && j+i<len; j++) {
                    if(j == j+i) {
                        System.out.print("["+array[j][j]+"]");
                    }
                }
                if(i==0)
                    System.out.println("");
                for(int j=0; j<len && j+i < len; j++) {
                    if(j < j+i) {
                        System.out.print("["+array[j][j+i]+"]");
                    }
                }
                if(i != 0)
                    System.out.println("");
                for(int j=0; j<len && j+i<len; j++) {
                    if(j < j+i) {
                        System.out.print("["+array[j+i][j]+"]");
                    }
                }
                if(i != 0)
                    System.out.println("");
            }
        }
    }
}
public class MatrixMulti {
    public static void main(String[] args) {
        test0();
        test1();
    }

    // multiply matrix, mul matrix, mult matrix
    public static int[][] multiply(int[][] A, int[][] B) {
        int[][] C = null;
        if( A != null && B != null) {
            int alen = A.length;
            int blen = B.length;
            int clen = alen;
            C = new int[alen][alen];
            for(int c = 0; c < clen; c++) {
                for(int i = 0; i < alen; i++) {
                    int s = 0;
                    for(int j = 0; j < blen; j++) {
                        s += A[i][j]*B[j][c];
                    }
                    C[i][c] = s;
                }
            }
        }
        return C;
    }

    //[ file=matrixmul.html title=""
    // Better way to multiply matrix, mul matrix, mult matrix
    public static int[][] multiply2(int[][] arr1, int[][] arr2) {
        int[][] arr3 = null;
        if( arr1 != null && arr2 != null) {
            int height = arr1.length;
            int width = arr1[0].length;
            int len = height;
            arr3 = new int[height][height];
            for(int k = 0; k < len; k++) {
                for(int i = 0; i < height; i++) {
                    for(int j = 0; j < width; j++) {
                        arr3[i][j] += arr1[i][k]*arr2[k][j];
                    }
                }
            }
        }
        return arr3;
    }
    //]
    
    static void test0(){
        System.out.println("---------------------------------\n");
        int[][] A = {{1}};
        int[][] B = {{2}};
        int[][] C = multiply2(A, B);
        Aron.printArray2D(C);

        System.out.println("---------------------------------\n");
    }
    static void test1(){
        System.out.println("---------------------------------\n");
        int[][] A = {{1, 1},
                    {0, 1}
        };
        int[][] B = {{2, 0},
                    {0, 3}
        };
        int[][] C = multiply2(A, B);
        Aron.printArray2D(C);
        System.out.println("---------------------------------\n");
    }
}
public class MatrixMultiNew 
{
    public static void main(String[] args)
    {
        System.out.println("New Algorithm for Matrix Multiplication!");
        int[][] A = {{1, 2},
                     {3, 4}}; 
        int[][] B = {{2, 3},
                     {4, 5}}; 

        int[][] C = Multiply(A, B);
        for(int i=0; i<C.length; i++)
        {
            for(int j=0; j<C.length; j++)
            {
                System.out.print("["+C[i][j]+"]");
            }
            System.out.println();
        }
    }
    public static int[][] Multiply(int[][] A, int[][] B)
    {
        int[][] C = null;
        if(A != null && B != null)
        {
            C = new int[A.length][A.length];
            for(int i=0; i<A.length; i++)
            {
                for(int j=0; j<A.length; j++)
                {
                    for(int k=0; k<A.length; k++)
                    {
                        
                         C[k][j] += A[k][i]*B[i][j];
                    }
                }
            }
        }
        return C;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;


// max sum, max continuous sum, consecutive sum, max consecutive sum 
// maximum continuous sum, maximum consecutive sum, max array sum, max sum array
// max sum with index, 
// max sum index, first index, last index, first last index
// maxsum
public class MaxConsecutiveArray{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();

        test00();
        test11();
        test12();
        test_maxConsecutiveSum_1();
        test_maxConsecutiveSum_2();
        test_maxConsecutiveSum_3();
        test_maxConsecutiveSum_4();
        test_maxConsecutiveSum_5();
    }
    //[ file=consecutive.html title=""
    //  4, -5, 9, 7, -8, 3
    //--------------------------------------------------------------------------------
    // m = 0
    // max = 0
    //--------------------------------------------------------------------------------
    // m = max(m, m+3) = 3
    // max = 3
    //--------------------------------------------------------------------------------
    // m = max(m, m+-8) = -5 = 0
    // max = 3
    //--------------------------------------------------------------------------------
    // m = max(m, m+7) = 7
    // max = 7
    //--------------------------------------------------------------------------------
    // m = max(m, m+9) = 16
    // max = 16
    //--------------------------------------------------------------------------------
    // m = max(m, m -5) = 11
    // max = 16
    //--------------------------------------------------------------------------------
    // m = max(m, m + 4) = 15
    // max = 16
    //-------------------------------------------------------------------------------- 
    public static int maxConsecutive(int[] arr) {
        int m = 0, max = 0;
        int startIndex = 0;
        int endIndex   = 0;
        if(arr != null) {
            for(int i=0; i<arr.length; i++) {
                if(m + arr[i] > 0){
                    m = Math.max(m + arr[i], arr[i]);

                    if(m > max){
                        max = m;
                    }
                }
                else{
                    m = 0;
                }
            }
        }
        return max;
    }
    //]

    //[ file=maxsumnegative.html  title=""
    // wrong code
    public static int maxConsecutiveNegative(int[] arr) {
        int max_so_far = arr[0], currMax = arr[0];
        if(arr != null) {
            for(int i=1; i<arr.length; i++) {
                max_so_far = Math.max(arr[i], currMax + arr[i]);
                currMax = Math.max(currMax, max_so_far);
            }
        }
        return currMax;
    }
    //]

    // -4, 2 
    // 2, 
    // -4, 2, -1, 5
    // -4, 2, -3, 5
    // first and last index
    static int maxConsecutiveSum(int[] arr){
        int max = 0;
        if(arr != null){
            int len = arr.length;
            if(len > 0){
                max = arr[0];
                int sum = arr[0];
                int first = 0;
                int second = 0;
                int tmpFirst = 0;
                for(int i=1; i<len; i++){
                    if(sum < 0){
                        sum = 0;
                        tmpFirst = i;
                    }
                    sum += arr[i];
                    if(max < sum){
                        max = sum;
                        first = tmpFirst;
                        second = i;
                    }
                }
                Print.pb("first=" + first);
                Print.pb("second=" + second);
            }
        }
        return max;
    } 

    static void test0() {
        Aron.beg();
        int[] arr = {1, -2, 8, 9, -4, 5};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 18);
        Aron.end();
    }

    static void test1() {
        Aron.beg();
        int[] arr = {1};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 1);
        Aron.end();
    }
    static void test2() {
        Aron.beg();
        int[] arr = {1, -9};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 1);
        Aron.end();
    }
    static void test3() {
        Aron.beg();
        int[] arr = {4, 1, -9, 10};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 10);
        Aron.end();
    }
    static void test4() {
        Aron.beg();
        int[] arr = {4, 1, -9, 10, 4, -5, 7};
        int max = maxConsecutive(arr);
        Aron.printArray(arr);
        Test.t(max, 16);
        Aron.end();
    }
    public static void test5(){
        Aron.beg();
        int[] arr = {2, -3, -2, 4, -3, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test6(){
        Aron.beg();
        int[] arr = {2, -3, 2, -2, 5, -3, 2, 1}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test7(){
        Aron.beg();
        int[] arr = {-2, 0, 0, 7, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutive(arr);
        Test.t(max, 7);

        Aron.end();
    }
    public static void test8(){
        Aron.beg();
        int[] arr = {-2, -3, -1, -4, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, -1);

        Aron.end();
    }
    public static void test00(){
        Aron.beg();
        int[] arr = {-2, -3, -1, -4, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, -1);

        Aron.end();
    }
    public static void test11(){
        Aron.beg();
        int[] arr = {-2, 0, 0, 7, -8}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, 7);

        Aron.end();
    }
    public static void test12(){
        Aron.beg();
        int[] arr = {-3, 2, -4, 9}; 
        Aron.printArray(arr);
        int max = maxConsecutiveNegative(arr);
        Test.t(max, 9);

        Aron.end();
    }

    public static void test_maxConsecutiveSum_1(){
        Aron.beg();
        int[] arr = {-4, 2, -3, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 5);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_2(){
        Aron.beg();
        int[] arr = {-4, 2, -1, 5}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_3(){
        Aron.beg();
        int[] arr = {-4, 2}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 2);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_4(){
        Aron.beg();
        int[] arr = {2}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 2);

        Aron.end();
    }
    public static void test_maxConsecutiveSum_5(){
        Aron.beg();
        int[] arr = {2, 3}; 
        Aron.printArray(arr);
        int max = maxConsecutiveSum(arr);
        Aron.printArray(arr);
        Test.t(max, 5);

        Aron.end();
    }
}

public class MaxContinuous 
{
    public static void main(String[] args)
    {
        int[] array = {2, 4, 7, 1, 5, 8, 10, 11, 12, 13, 11, 14, 15, 16, 0, 1, 2, 3, 5, 6, 7};
        maxContinuous(array);
    }
    public static void maxContinuous(int[] array)
    {
        if(array != null)
        {
            int len = array.length;
            int[] arr = new int[len];
            for(int i=0; i<len; i++)
                arr[i] = 1;

            int maxIndex = 0;
            int max = arr[0];
            for(int i=1; i<len; i++)
            {
                if(array[i] > array[i-1])
                    arr[i] = arr[i-1] + 1;

                if(arr[i] > max)
                {
                    max = arr[i];
                    maxIndex = i;
                }
            }
            System.out.println("beginIndex=" + (maxIndex - max + 1));
            System.out.println("maxIndex=" + maxIndex);
            System.out.println("max=" + max);
        }
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Hashtable;
import java.util.HashSet;
import java.util.List;
import java.util.*;
import java.lang.Math;

import classfile.*;

public class MaxContinuousList {
    public static void main(String[] args) {
        test8();
        test9();
        test10();
        test11();
        test12();
        test13();
        test14();
        test15();
        test16();
        test17();
        test18();
    }
    static void test8() {
        Aron.beg();
        Integer[] arr = {2, -5, 8, -2, 3};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test9() {
        Aron.beg();
        Integer[] arr = {-1, -5, 8, -4, 5, -2, 3, -2};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test10() {
        Aron.beg();
        Integer[] arr = {-1, -5, 8};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }

    static void test11() {
        Aron.beg();
        Integer[] arr = {6, -5, 8};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test12() {
        Aron.beg();
        Integer[] arr = {3, -4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test13() {
        Aron.beg();
        Integer[] arr = {-4, 5};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test14() {
        Aron.beg();
        Integer[] arr = {-4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test15() {
        Aron.beg();
        Integer[] arr = {4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test16() {
        Aron.beg();
        Integer[] arr = {4, 0};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test17() {
        Aron.beg();
        Integer[] arr = {0, 4};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void test18() {
        Aron.beg();
        Integer[] arr = {-2, 4, 3, -8, 3};
        Aron.printArray(arr);
        System.out.println("max[" + maxList(arr)+ "]");
        Aron.end();
    }
    static void getAllPaths(Node n, Map<Node, Node> map, int num, List<Node> list) {
        if(n.data == num) {
            for(Node node : list) {
                System.out.println("[" + node.data + "]");
            }
            System.out.println("\n---------------------------------");
        } else {
            Node curr = map.get(n);
            while(curr != null) {
                list.add(curr);
                getAllPaths(curr, map, num, list);

                if(list.size() > 0)
                    list.remove(list.size()-1);

                curr = curr.next;
            }
        }
    }

    //[ file=maxlistindex.html title=""
    //
    // only work when not all elem are negative
    //
    // Sun Sep 25 18:03:40 PDT 2016
    // Fix bug: start gets the wrong index
    // start index, end index 
    static int maxList(Integer[] arr) {
        int tmp_start = 0;
        int end = 0;
        int start = 0;
        int max = 0;
        int sum = 0;
        for(int i=0; i<arr.length; i++) {
            if(sum == 0) {
                tmp_start = i;
            }

            if(sum + arr[i] > 0) {
                int m = Math.max(arr[i], sum + arr[i]);
                if(m > max) {
                    max = m;
                    start = tmp_start;
                    end = i;
                }
                sum += arr[i];
            } else {
                sum = 0;
            }
        }
        Print.p("start[" + start + "]");
        Print.p("end  [" + end + "]");
        return max;
    }
    //]
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class MaxDepthIteration 
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(10);
		
		b1.Insert(5);
		b1.Insert(1);
		b1.Insert(7);
		b1.Insert(9);
		
		
		
		
		int c = MaxDepthIteration(b1.getRoot());
		System.out.println("c=" + c);
	}
	//in order traversal using iteration
	public static int MaxDepthIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		int max=0;
		int c=0;
		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					st.push(cur);
					c++;
					if(c>max)
						max=c;
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					if(no.right == null) //last traversal node has to be the right node observation from the recursive Inorder traversal 
						c--;
					System.out.println("no.data=" + no.data);
					cur = no.right;
				}
			}
		}
		return max;
	}
	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MaxDiff{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0() {
        Aron.beg();
        int[] arr = {2, 4}; 
        int max = maxDiff(arr);
        Test.t(max, 2);
        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        int[] arr = {2, 4, 7, 1, 7, 2}; 
        int max = maxDiff(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();
        int[] arr = {4, 1, 7}; 
        int max = maxDiff(arr);
        Test.t(max, 6);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        int[] arr = {15, 10, 17, 1, 9}; 
        int max = maxDiff(arr);
        Test.t(max, 8);

        Aron.end();
    }

    //[file=maxdiff.html title=""
    // [2, 4, 7, 1, 7, 2]
    // [4, 2] => 0
    // [1, 3, 4]
    // [3, 1, 7]
    public static int maxDiff(int[] arr){
        int maxDiff = 0;
        if(arr != null && arr.length > 1){
            int len = arr.length;
            int min = arr[0];
            for(int i=1; i<len; i++){

                if(arr[i-1] < min)
                    min = arr[i-1];
                    
                if(arr[i] - min > maxDiff)
                    maxDiff = arr[i] - min;
            } 
        }
        return maxDiff;
    }
    //]
}

import java.io.*;
import java.lang.String;
import java.util.*;
class MaxDistance {
    public static void main(String args[]) {
        int[] Arr = {10, 11, 2, 1, 0, 4};
        int max = MaxDistance(Arr);
        System.out.println("max=" + max);
    }


    public static int MaxDistance(int[] Arr) {
        int max_d = 0;
        if( Arr != null) {
            int len = Arr.length;
            int[] InxArr = new int[len];

            if(len > 0) {
                InxArr[0] = 0;
                int c=1;
                for(int i=1; i<len; i++) {
                    if(Arr[i-1] > Arr[i]) {
                        InxArr[c] = i;
                        c++;
                    }
                }
                int k=0;
                for(int i=0; i<len; i++) {
                    for(int j=k; j<c; j++) {
                        int d = len-1-i - InxArr[c-1-j];
                        if(d > 0 && Arr[len-1-i] > Arr[InxArr[c-1-j]]) {
                            if(d > max_d) {
                                max_d = d;
                                k=j;
                            }
                        }
                    }
                }
            }
        }
        return max_d;
    }
}
public class MaxDistanceThreeSortIntegers
{
    public static void main(String[] args)
    {
        System.out.println("hello world!");
        int[] arr1 = {1, 4, 500, 600};
        int[] arr2 = {2, 5, 10, 500};
        int[] arr3 = {6, 20, 30, 500, 501};

        printArray(arr1);
        printArray(arr2);
        printArray(arr3);
        int min = findMaxAbsSum(arr1, arr2, arr3);
        System.out.println("min["+min+"]");
    }
    public static int findMaxAbsSum(int[] arr1, int[] arr2, int[] arr3)
    {
        int gmin = Integer.MAX_VALUE;
        if(arr1 != null && arr2 != null && arr3 != null)
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len3 = arr3.length;
            int inx1 =0, inx2 = 0, inx3 = 0;
            while(inx1 < len1  && inx2 < len2 && inx3 < len3)
            {
                int min = Math.min(Math.min(arr1[inx1], arr2[inx2]), arr3[inx3]);
                int max = Math.max(Math.max(arr1[inx1], arr2[inx2]), arr3[inx3]);
                int sum = 2*(max - min);
                if(sum == 0)
                    return 0;

                if(sum < gmin)
                    gmin = sum;

                if(min == arr1[inx1]) inx1++;
                if(min == arr2[inx2]) inx2++;
                if(min == arr3[inx3]) inx3++;
            }
        }    
        return gmin;
    }
    public static void printArray(int[] arr)
    {
        if(arr != null)
        {
            for(int i=0; i<arr.length; i++)
                System.out.println("arr["+i+"]["+arr[i]+"]");
        }
        System.out.println("===============");
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

// graph with weight
// maximum path in graph, max path in graph, max path tree, 
// maximum graph in tree, maxpath, path tree
//
// gx /Library/WebServer/Documents/zsurface/image/maxpath.png
public class MaxPath{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath.png
    public static void test0(){
        Aron.beg();
        
        int[][] arr2d = {
            {0, 1, 3, 0},
            {0, 0, 7, 3},
            {0, 0, 0, 6},
            {0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 3;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 14);
    
        Aron.end();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath2.png
    public static void test1(){
        Aron.beg();

        int[][] arr2d = {
            {0, 3, 7, 7, 0},
            {0, 0, 9, 2, 4},
            {0, 0, 0, 20,0},
            {0, 0, 0, 0, 9},
            {0, 0, 0, 0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 4;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 41);

        Aron.end();
    }

    public static void test2(){
        Aron.beg();

        int[][] arr2d = {
            {0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 0;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 0);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();

        int[][] arr2d = {
            {0, 3},
            {0, 0},
        };
        Aron.printArray2D(arr2d);
        int height = arr2d.length;
        int width = arr2d[0].length; 
        int n1 = 0; 
        int n2 = 1;
        int max = mathPathGraph(arr2d, n1, n2, width);
        Test.t(max == 3);

        Aron.end();
    }

    // gx /Library/WebServer/Documents/zsurface/image/maxpath.png
    public static int mathPathGraph(int[][] arr, int n1, int n2, int width){
        int max = 0;
        if(n1 != n2){
            for(int i=0; i<width; i++){
                if(n1 != i){
                    if(arr[n1][i] > 0){
                        int m = mathPathGraph(arr, i, n2, width) + arr[n1][i]; 
                        max = Math.max(max, m);
                    }
                }
            } 
        }
        return max;
    }

    // max path in tree, max path tree, maxpath binarytree
    public static int maxPathTree(Node r){
        if(r != null){
            int left = maxPathTree(r.left);
            int right = maxPathTree(r.right);
            return Math.max(left, right) + r.data;
        }
        return 0;
    }
} 

import java.io.*;
import java.lang.*;
import java.util.*;

class MaxRepeatingChar 
{
	public static void main(String args[])
	{
		int c = maxrepeating("aacc");
		System.out.println(c);
	}
	public static int maxrepeating(String str)
	{
		int max = 0;
		if( str != null && str.length() > 0)
		{
			int len=str.length();
			int c=1; max=1;
			if(len > 1)
			{
				for(int i=1; i<len; i++)
				{
					if(str.charAt(i-1) == str.charAt(i))
					{ c++; if(c > max) max = c; }
					else
						c=1;
				}
			}
		}
		return max;
	}
}

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}
class MaxSumPathBT 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        
        System.out.println("Before Swap");
        inorder(b1.getRoot());

        System.out.println("============");
        System.out.println("After Swap");

        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        //swap(199, 16, b1.getRoot(), first, second);
        
        System.out.println("Max Sum in a path=" + MaxSumPath(b1.getRoot()));
        inorder(b1.getRoot());
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }
    
    public static int MaxSumPath(Node node)
    {
        if(node != null)
        {
            int left = MaxSumPath(node.left) + node.data;
            int right = MaxSumPath(node.right) + node.data;
            if(left > right)
                return left;
            else
                return right;  
        }
        else
        {
            return 0;
        }
    }
}
public class MaxTupleInAscendingOrder 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    public static int[] findMax(int[] arr)
    {
        if( arr != null)
        {
            int[] tuple = new int[3];
            int count = 0;
            tuple[0] = arr[0];
            for(int i=1; i<arr.length; i++)
            {
                for(int j=0; j<=count; j++)
                {
                    if(tuple[j] < arr[i])    
                }
            }
        }
    }
}
public class MazeFindPath 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        /*
        int[][] maze = { {0,0, 4, 4},
                         {4,0, 0, 0},
                         {4,0, 4, 0},
                         {4,0, 0, 3}
                        }; 
        int row = 0;
        int col = 0;
        for(int i=0; i<maze.length; i++)
        {
            for(int j=0; j<maze.length; j++)
            {
                System.out.print("["+maze[i][j]+"]");
            }
            System.out.println();
        }

        int[] path = new int[50];
        int level = 0;
        //findAllPath(maze, row, col, path, level);
        //findPath(maze, row, col);
        int min=100;
        int[] minPath = new int[100];
        int m = findTheShortestPath(maze, col, row, path, minPath, level, min);
        for(int i=0; i<m; i++)
        {
            int c = minPath[i]/maze.length;
            int r = minPath[i]%maze.length;
            System.out.println("["+c+"]["+r+"]");
        }
        */

        test1();

    }

    public static boolean findPath(int[][] maze, int row, int col)
    {
        if(maze != null && row < maze.length && col < maze.length)
        {
               if(maze[row][col] == 3)
               {
                   System.out.println("["+row+"]["+col+"]");
                   return true;
               }
               if(maze[row][col] == 0)
               {
                    maze[row][col] = 2;
                    if(findPath(maze, row, col+1))
                    { 
                       System.out.println("["+row+"]["+col+"]");
                       return true;
                    }
                    if(findPath(maze, row+1, col))
                    {
                       System.out.println("["+row+"]["+col+"]");
                       return true;
                    }
               }
        }
        return false;
    }

    public static void findAllPath(int[][] maze, int row, int col, int[] path, int level)
    {
        if(maze != null && row < maze.length && col < maze.length)
        {
               if(maze[row][col] == 3)
               {
                   path[level] = row*maze.length+col;
                   for(int i=0; i<=level; i++){
                       int r = path[i]/maze.length;
                       int c = path[i]%maze.length; 
                       System.out.println("["+r+"]["+c+"]");
                   }
                   System.out.println("");
               }
               if(maze[row][col] == 0)
               {
                   path[level]=row*maze.length + col;
                    findAllPath(maze, row, col+1, path, level+1);
                    findAllPath(maze, row+1, col, path, level+1);
               }
        }
    } 
    public static int findTheShortestPath(int[][] maze, int col, int row, int[] path, int[] minPath, int level, int min)
    {
        if( maze != null)
        {
            if(maze[col][row] == 3)
            {
                path[level] = col*maze.length+row;
                System.out.println("{"+col+"}{"+row+"}");
                System.out.println("minPath["+level+"]="+path[level]);
                if(level < min)
                {
                    min = level;                    
                    for(int i=0; i<=level; i++)
                    {
                        minPath[i] = path[i];
                    }
                }
            }
            else if(maze[col][row] == 0)
            {
                path[level] = col*maze.length+row;
                System.out.println("{"+col+"}{"+row+"}");
                maze[col][row] = 2;
                int r = 100, d = 100, l = 100, u = 100;
                if(row+1 < maze.length)
                    r = findTheShortestPath(maze, col, row+1, path, minPath, level+1, min);
                if(col+1 < maze.length)
                    d = findTheShortestPath(maze, col+1, row, path, minPath, level+1, min);
                if(row-1 > 0)
                    l = findTheShortestPath(maze, col, row-1, path, minPath, level+1, min);
                if(col-1 > 0)
                    u = findTheShortestPath(maze, col-1, row, path, minPath, level+1, min);
                min = Math.min(Math.min(r, d), Math.min(l, u));
            }
        }
        return min;
    }
    public static void test1()
    {
        int[][] maze = { 
                         {0,0, 4, 4, 0, 0},
                         {0,0, 0, 0, 0, 0},
                         {0,4, 0, 4, 4, 0},
                         {0,4, 0, 4, 0, 0},
                         {0,0, 0, 0, 4, 0},
                         {0,4, 4, 0, 0, 3}
                        }; 
        int row = 0;
        int col = 0;
        for(int i=0; i<maze.length; i++)
        {
            for(int j=0; j<maze.length; j++)
            {
                System.out.print("["+maze[i][j]+"]");
            }
            System.out.println();
        }

        int[] path = new int[100];
        int[] minPath = new int[100];
        int level = 0;
        int min=100;

        int m = findTheShortestPath(maze, col, row, path, minPath, level, min);
        System.out.println("m["+m+"]");
        for(int i=0; i<=m; i++)
        {
            int c = minPath[i]/maze.length;
            int r = minPath[i]%maze.length;
            System.out.println("["+c+"]["+r+"]");
        }
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class MedianOfStream{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
    }
    public static void test0(){
        Aron.beg();
        Integer[] arr = {2, 1, 3, 4, 5, 0};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Integer[] arr = {2, 1};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        Integer[] arr = {1, 2};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        Integer[] arr = {2};
        int width = arr.length; 
        int lo = 0;
        int hi = arr.length - 1;
        Aron.printArray(arr);
        Ut.l();
        quickSort(arr, lo, hi);
        Aron.printArray(arr);
        Aron.end();
    }

    // test [2, 1] = > [1, 2], pivot = [0]
    public static void quickSort(Integer[] arr, int lo, int hi){
        if(lo < hi){
            int pivot = partition(arr, lo, hi);
            quickSort(arr, lo, pivot -1);
            quickSort(arr, pivot + 1, hi);
        }
    }

    public static int partition(Integer[] arr, int lo, int hi){
        int big = lo;
        int pivot = arr[hi];
        for(int i=lo; i<=hi; i++){
            if(arr[i] <= pivot){
                swap(arr, big, i);
                if(i < hi)
                    big++;
            }
        }
        return big;
    }
    public static void swap(Integer[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    
    public static void Median(int[] arr){
                    
    }
} 

import java.util.*;

public class MergeArrayLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("merge array and merge linkedlist");
    }

    public static int[] merge(int[] arr1, int[] arr2) {
        int[] arr = null; 
        if(arr1 == null)
            return arr2;
        else if(arr2 == null)
            return arr1;
        else {
            int len1 = arr1.length;
            int len2 = arr2.length;
            arr = new int[len1+len2];
            int inx1 = 0;
            int inx2 = 0;
            int k=0;

            while(inx1 < len1 || inx2 < len2) {
                if(inx1 >= len1) {
                    arr[k] = arr1[inx2];
                    inx2++;
                }
                else if(inx2 >= len2) {
                    arr[k] = arr2[inx1];
                    inx1++;
                }
                else {
                    if(arr1[inx1] < arr2[inx2]) {
                        arr[k] = arr1[inx1];
                        inx1++;
                    }
                    else if(arr1[index] == arr2[inx]){
                        arr[k] = arr1[inx1];
                        k++;
                        inx1++;
                        arr[k] = arr2[inx2];
                        k++;
                        inx2++;
                    }
                    else {
                        arr[k] = arr2[inx2];
                        inx2++;
                    }
                }
                k++;
            }
        }
        return arr;
    }
    public static Node mergeList(Node s1, Node s2)
    {
        Node curr = null;
        Node head = curr;
        while( s1 != null || s2 != null)
        {
            if(s1 == null)
            {
                if(curr == null)
                   head = curr = s2;
                else
                {
                    curr.next = s2;
                    curr = curr.next;
                }
                s2 = s2.next;
            }
            else if(s2 == null)
            {
                if(curr == null)
                    head = curr = s1;
                else
                {
                    curr.next = s1;
                    curr = curr.next;
                }
                s1 = s1.next;
            }
            else
            {
                if(s1.data < s2.data)
                {
                    if(curr == null)
                        head = curr = s1;
                    else
                    {
                        curr.next = s1;
                        curr = curr.next;
                    }
                    s1 = s1.next;
                }
                else
                {
                    if( curr == null)
                        head = curr = s2;
                    else
                    {
                        curr.next = s2;
                        curr = curr.next;
                    }
                    s2 = s2.next;
                }
            }
        }
        return head;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MergeExtraSpace{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    static void test0(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 7, 9, 0}; 
        Integer[] arr2 = {3}; 
        int len = 4;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test1(){
        Aron.beg();
        Integer[] arr1 = {4, 0}; 
        Integer[] arr2 = {3}; 
        int len = 1;



        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0}; 
        Integer[] arr2 = {3}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {3, 9}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {4, 5}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {4, 5}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge2(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        Integer[] arr1 = {1, 4, 4, 0, 0, 0}; 
        Integer[] arr2 = {2, 3}; 
        int len = 3;

        Aron.printArray(arr1);
        Aron.printArray(arr2);
        System.out.println("\n---------------------------------"); 

        merge2(arr1, len, arr2);
        Aron.printArray(arr1);

        Aron.end();
    }
    //[ file=mergespace.html title=""
    // 2, 4, [] []
    // [2] 3, {4}
    // [3]x
    public static void merge(Integer[] arr1, int len, Integer[] arr2){
        if(arr1 != null && arr2 != null){
            int len2 = arr2.length;
            for(int i=len-1; i>=0; i--){
                arr1[i+len2] = arr1[i];    
            }
            int p1 = len2;
            int p2 = 0; 
            int k = 0;

            while(p2 < len2 || p1 < len + len2){
                if(p2 >= len2){
                    arr1[k] = arr1[p1];
                    p1++;
                }else if(p1 >= len + len2){
                    arr1[k] = arr2[p2];
                    p2++;
                }else{
                    if(arr1[p1] < arr2[p2]){
                        arr1[k] = arr1[p1];
                        p1++;
                    }else{
                        arr1[k] = arr2[p2];
                        p2++;
                    }
                }
                k++;
            }
        }
    } 

    // [2][]
    // [3]
    public static void merge2(Integer[] arr1, int len1, Integer[] arr2){
        if(arr1 != null && arr2 != null){
            if(arr1.length > 0 || arr2.length > 0){
                int len2 = arr2.length;
                int k = len2 + len1 - 1;
                int p1 = len1 - 1;
                int p2 = len2 - 1;

                while(p1 >= 0 || p2 >= 0){ 
                    if(p1 < 0){
                        arr1[k] = arr2[p2];
                        p2--;
                    }else if(p2 < 0){
                        arr1[k] = arr1[p1];
                        p1--;
                    }else{
                        if(arr1[p1] > arr2[p2]){
                            arr1[k] = arr1[p1];
                            p1--;
                        }else{
                            arr1[k] = arr2[p2];
                            p2--;
                        }
                    }
                    k--;
                }
            }
        }
    }

    //]
} 
package classfile;

import java.io.*;
import java.lang.String;
import java.util.*;

class MergeHalfList{
    public static void main(String args[]) {
    }

    public static Node mergeHalf(Node head) {
        Node curr = head;
        Queue<Node> q0 = new LinkedList<Node>();
        Queue<Node> q1 = new LinkedList<Node>();
        int count = 0;
        while(curr != null) {
            System.out.println("curr[" + curr.data+"]");
            q1.add(new Node(curr.data));
            curr = curr.next;
        }

        int halfsize = q1.size()/2;
        int size = q1.size();
        System.out.println("q1size[" + q1.size()+"]");
        System.out.println("q1size/2[" + halfsize +"]");
        for(int i=0; i<= size/2; i++) {
            Node node = q1.remove();
            System.out.println("node[" + node.data+"] i=[" + i+"]");
            q0.add(new Node(node.data));
        }

        System.out.println("q0.size[" + q0.size()+"]");
        Node prevPair = null;
        Node currPair = null;
        Node newHead = null;
        while(q0.peek() != null) {
            Node n0 = q0.remove();
            Node n1 = null;
            if(q1.peek() != null) {
                n1 = q1.remove();
                System.out.println("q1[" + n1.data+"]");
            }

            n0.next = n1;
            currPair = n0;

            if(prevPair!= null)
                prevPair.next.next = currPair;
            else
                newHead = currPair;
            prevPair = currPair;
        }
        return newHead;
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

//[ file=mergeintervals.html title=""
class Interval implements Comparable<Interval>{
    public int begin;
    public int end;
    public Interval(int begin, int end){
        this.begin = begin;
        this.end = end;
    }
    public int compareTo(Interval inter){
        if(this.begin > inter.begin)
           return 1; 
        else if(this.begin == inter.begin)
            return 0;
        else
            return -1;
    }
    public String toString(){
        return "[" + begin + " " + end + "]";
    }
}

public class MergeIntervals{
    public static void main(String[] args) {
        test00();
    }
    static void test00(){
        Aron.beg();
        PriorityQueue<Interval> queue = new PriorityQueue<Interval>();
        Stack<Interval> stack = new Stack<Interval>();
        int[] arr1 = {4, 1, 2, 6, 9};
        int[] arr2 = {5, 1, 4, 9, 10};
        
        for(int i=0; i<arr1.length; i++){
            queue.add(new Interval(arr1[i], arr2[i]));
        }
        if(queue.size() > 0){
            stack.push(queue.remove());
        }
        while(!queue.isEmpty()){
            Interval top = stack.peek();
            Interval inter = queue.remove();
            if(top.end < inter.begin)
                stack.push(inter);
            else{
                stack.peek().end = Math.max(stack.peek().end, inter.end);
            }
        }
        while(!stack.empty()){
            System.out.println("[" + stack.peek().begin + " " + stack.peek().end + "]");
            stack.pop();
        }
        
        Aron.end();
    }
}
//]
public class MergeSortArray 
{
    public static void main(String[] args)
    {
        System.out.println("Merge Sort Array");
        test1();
        test2();
        test3();
        test4();
    }

    public static void test1()
    {
        int[] A = {3, 2, 1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test2()
    {
        int[] A = {2, 1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test3()
    {
        int[] A = {1};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }

    public static void test4()
    {
        int[] A = {10, 1, 9, 100, 6, 3, 3, 5};
        int len = A.length;
        int lo = 0;
        int hi = len-1;

        for(int i=0; i<A.length; i++)
            System.out.print("{"+A[i]+"}");

        System.out.println();

        mergeSort(A, lo, hi);
        for(int i=0; i<A.length; i++)
            System.out.print("["+A[i]+"]");

        System.out.println();
    }
    public static void merge(int[] A, int lo, int mid, int hi)
    {
        if( A != null)
        {
            int[] B = new int[hi-lo+1];

            int index1 = lo;
            int index2 = mid+1;
            int k=0;
            while(k < (hi-lo+1))
            {
                if(index1 > mid)
                {
                    B[k] = A[index2];
                    index2++;
                }
                else if(index2 > hi)
                {
                    B[k] = A[index1];
                    index1++;
                }
                else
                {
                    if(A[index1] < A[index2])
                    {
                        B[k] = A[index1]; index1++;
                    }
                    else
                    {
                        B[k] = A[index2]; index2++;
                    }
                }
                k++;
            }
            for(int i=0; i<B.length; i++)
                A[lo+i] = B[i];
        }
    }
    public static void mergeSort(int[] A, int lo, int hi)
    {
        if(lo<hi)
        {
            int mid = (lo+hi)/2;
            mergeSort(A, lo, mid);
            mergeSort(A, mid+1, hi);
            merge(A, lo, mid, hi);
        }
    }
}
class Node 
{
	Node next;
	int data;
	public Node(int n)
	{ next = null; data = n;}
}

class SLL
{
	Node head;
	public SLL()
	{ head = null;}

    public void append(int n)
    {
        Node cur = head;
		if(head == null)
			head = new Node(n);
		else
		{
			while(cur.next != null)
			{ 
                cur = cur.next; 
            }
			cur.next = new Node(n);
		}

    }

	public void append(Node no)
	{
		Node cur = head;
		if(head == null)
			head = no;
		else
		{
			while(cur.next != null)
			{ cur = cur.next; }
			cur.next = no;
		}
	}

	//recursive 
	static Node next=null;
	public void Reverse(Node cur)
	{
		if(cur != null)
		{
			Reverse(cur.next);
			if(next != null)
				next.next = cur;	
			else 
				head = cur;
			next = cur;
			cur.next = null;
		}
	}
	//iteration
	public void Reverse1(Node cur)
	{
		if(head != null)
		{
			Node prev = null;
			Node next = cur.next;

			while(cur != null)
			{
				cur.next = prev;
				prev = cur;
				cur = next;
				if(next != null)
					next = next.next;
			}
			head = prev;
			
		}
	}
	public Node getHead()
	{ return head;}
	public void Remove(Node no)
	{
		if(no != null && head != null)
		{
			Node cur = head;	
			Node prev = null;
			while(cur != no)
			{
				prev = cur;
				cur = cur.next;
			}
			if(prev != null && no.next != null)
			{ prev.next = no.next; no.next = null; }
			else if(prev == null && no.next != null)
			{ head = no.next; no.next = null; }
			else if(prev != null && no.next == null)
			{ prev.next = null; }
			else 
			{ no = null; head = null;}
		}	
	}
	public void show()
	{
		Node cur=head;
		while(cur != null)
	 	{ System.out.println("cur.data=" + cur.data); cur=cur.next;}
	}
    public Node getTail()
    {
        Node curr = head;
        while(curr != null && curr.next != null)
        {
            curr = curr.next;
        }
        return curr;
    } 
}

//Merge sort on single linkedlist
public class MergeSortLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Merge Sort linkedlist");
        test1();
        test2();
        test3();
        test4();

    }

    public static void test1()
    {
        System.out.println("Test1()");
        SLL s3 = new SLL();

        s3.append(2);
        s3.append(1);

        show(s3.getHead());
        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test1()=======================");

    }

    public static void test2()
    {
        System.out.println("Test2()");
        SLL s3 = new SLL();

        s3.append(1);
        s3.append(2);
        s3.append(3);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test2()=======================");
    }


    public static void test3()
    {
        System.out.println("Test3()");
        SLL s3 = new SLL();

        s3.append(6);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test3()=======================");
    }

    public static void test4()
    {
        System.out.println("Test4()");
        SLL s3 = new SLL();

        s3.append(6);
        s3.append(5);
        s3.append(3);
        s3.append(100);
        s3.append(1);

        show(s3.getHead());

        System.out.println("=======================");
        Node hi = s3.getHead();
        Node lo = s3.getTail();
        hi = mergeSortLinkedList(hi, lo);
        show(hi);
        System.out.println("end Test4()=======================");
    }
    public static void show(Node head)
    {
        Node curr = head;
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }
    public static Node getTail(Node head)
    {
        Node curr = head;
        while(curr != null && curr.next != null)
            curr = curr.next;
        return curr;
    }

    public static Node mergeSortLinkedList(Node lo, Node hi)
    {
        if(lo != null && lo != hi)
        {
            Node m = median(lo);
            Node m1 = m.next;
            m.next = null;

            Node left = mergeSortLinkedList(lo, m);
            Node right = mergeSortLinkedList(m1, hi);
            return mergeLinkedList(left, right);
        }
        else
            return lo;
    }

    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }

    public static Node mergeLinkedList(Node s1, Node s2)
    {
        Node curr1 = s1;
        Node curr2 = s2;
        Node curr = null;
        Node head = curr;
        if(curr1 == curr2)
            head = s1;
        else
        {
            while(curr1 != null || curr2 != null)
            {
                if(curr1 == null)
                {
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else
                    {
                        curr.next = new Node(curr2.data);
                        curr = curr.next;
                    }
                    curr2 = curr2.next;
                }
                else if(curr2 == null)
                {
                    if(curr == null)
                    {
                        head = curr = new Node(curr1.data);
                    }
                    else
                    {
                        curr.next = new Node(curr1.data);
                        curr = curr.next;
                    }
                    curr1 = curr1.next;
                }
                else 
                {
                    if(curr1.data < curr2.data)
                    {
                        if(curr == null)
                            head = curr = new Node(curr1.data);
                        else
                        {
                           curr.next = new Node(curr1.data); 
                           curr = curr.next;
                        }
                        curr1 = curr1.next;
                    }
                    else
                    {
                        if(curr == null)
                            head = curr = new Node(curr2.data);
                        else
                        {
                            curr.next = new Node(curr2.data);
                            curr = curr.next;
                        }
                        curr2 = curr2.next;
                    }
                }
            }
        }
        return head;
    }
}
import java.io.*;
import java.util.*;
class MergeSortedList 
{
	public static void main(String args[])
	{
		int[] Arr1 = new int[10]; 
		Arr1[0] = 5; 
		Arr1[1] = 6; 
		Arr1[2] = 7; 
		Arr1[3] = 8; 
		Arr1[4] = 9; 
		Arr1[5] = 10; 
		int[] Arr2 = {11, 20, 30, 40};
		int[] Arr = Merge(Arr1, Arr2);
		for(int i=0; i< Arr.length; i++)
			System.out.println(Arr[i]);
	}

	public static int[] Merge(int[] Arr1, int[] Arr2)
	{
		int[] ret=null;
		if(Arr1 !=null && Arr2 !=null) 
		{
			int i=Arr1.length-5, j=Arr2.length-1, k=Arr1.length-1;	
			while(j !=-1)
			{
				System.out.println("i=" + i + "  " + "j=" + j);
				if(i == -1)
				{
					Arr1[k] = Arr2[j]; j--;
				}
				else if(Arr1[i] > Arr2[j])
				{
					Arr1[k] = Arr1[i]; i--;
				}
				else 
				{
					Arr1[k] = Arr2[j]; j--;
				}
				k--;
					
			}
		}
		return Arr1;
	}
}
import java.io.*;
import java.util.*;
class MergeSortedListToArray {
    public static void main(String args[]) {
        int[] Arr1 = {1, 9, 12};
        int[] Arr2 = {2, 15};
        int[] Arr3 = {5, 7, 20};
        int[] Arr = Merge(Merge(Arr1, Arr2), Arr3);
        for(int i=0; i< Arr.length; i++)
            System.out.println(Arr[i]);
    }

    public static int[] Merge(int[] Arr1, int[] Arr2) {
        int[] A=null;
        if( Arr1 != null && Arr2 != null) {
            int len1 = Arr1.length;
            int len2 = Arr2.length;
            A = new int[len1+len2];
            int i=0, j=0, c=0;
            while(i<len1 || j<len2) {
                if(i == len1) {
                    A[c]=Arr2[j];
                    j++;
                } else if( j == len2) {
                    A[c]=Arr1[i];
                    i++;
                } else {
                    if(Arr1[i]<Arr2[j]) {
                        A[c] = Arr1[i];
                        i++;
                    } else {
                        A[c] = Arr2[j];
                        j++;
                    }
                }
                c++;
            }
        }
        return A;
    }
}
import java.util.*;
import java.io.*;
import java.lang.String;
import java.util.ArrayList;
import java.util.List;

import classfile.*;

public class MergeSortedSingleLinkedList{
    public static void main(String[] args) {
        test14();
        test15();
        test16();
        test17();
        test18();
        test19();
    }
    

    static void test14(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);
        s1.append(7);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        s2.append(6);
        s2.append(11);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test15(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(4);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test16(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(1);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test17(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    static void test18(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }
    static void test19(){
        Aron.beg();
        SingleLinkedList s1 = new SingleLinkedList();
        s1.append(1);
        s1.append(4);
        s1.append(9);

        Aron.printSLL(s1.head);
        System.out.println("---------------------------------\n"); 
        SingleLinkedList s2 = new SingleLinkedList();
        s2.append(4);
        
        Aron.printSLL(s2.head);
        System.out.println("---------------------------------\n"); 

        Node head = mergeSortedList(s1.head, s2.head);
        Aron.printSLL(head);
        Aron.end();
    }

    //[ file=mergesortedsll.html title=""
    static Node mergeSortedList(Node head1, Node head2){
        if(head1 == null)
            return head2;
        if(head2 == null)
            return head1;
        Node curr1 = head1;
        Node curr2 = head2;
        Node curr = null; 
        Node head = null;

        while(curr1 != null || curr2 != null){
            if(curr1 == null){
                if(curr != null)
                    curr.next = new Node(curr2.data);
                else
                    head = curr = new Node(curr2.data);

                curr2 = curr2.next;

            }else if(curr2 == null){
                if(curr != null)
                    curr.next = new Node(curr1.data);
                else
                    head = curr = new Node(curr1.data);

                curr1 = curr1.next;
            }else{
                if(curr1.data < curr2.data){
                    if(curr == null){
                        head = curr = new Node(curr1.data);
                    }else{
                        curr.next = new Node(curr1.data);
                    }

                    curr1 = curr1.next;
                }else{
                    if(curr == null)
                        head = curr = new Node(curr2.data);
                    else{
                        curr.next = new Node(curr2.data);
                    }

                    curr2 = curr2.next;
                }
            }

            if(curr.next != null)
                curr = curr.next;
        }
        return head;
    }
    //]
}
import classfile.*;

public class MergeThreeSortList 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        test1();
        test2();
    }
    public static void test1()
    {
        int[] arr1 = {1};
        int[] arr2 = {2, 8, 10, 40};
        int[] arr3 = {5};
        int[] arr = mergeThreeList(arr1, arr2, arr3);
        Aron.printArray(arr1);
        Aron.printArray(arr2);
        Aron.printArray(arr3);
        Aron.printArray(arr);
    }

    public static void test2()
    {
        int[] arr1 = {1, 9, 20, 30};
        int[] arr2 = {2, 8, 10, 40};
        int[] arr3 = {5, 18, 21, 29};
        int[] arr = mergeThreeList(arr1, arr2, arr3);
        Aron.printArray(arr1);
        Aron.printArray(arr2);
        Aron.printArray(arr3);
        Aron.printArray(arr);
    }
    public static int[] mergeThreeList(int[] arr1, int[] arr2, int[] arr3)
    {
        int[] arr = null;
        if(arr1 != null && arr2 != null && arr3 != null)
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            int len3 = arr3.length;
            int inx = 0;
            int inx1=0, inx2=0, inx3=0;
            arr = new int[len1+len2+len3];
            while(inx1 < len1 || inx2 < len2 || inx3 < len3)
            {
                if(inx1 >= len1 && (inx2 < len2 && inx3 < len3))
                {
                    arr[inx] = Math.min(arr2[inx2], arr3[inx3]);
                    if( arr[inx] == arr2[inx2]) inx2++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                else if(inx2 >= len2 && (inx1 < len1 && inx3 < len3))
                {    
                    arr[inx] = Math.min(arr1[inx1], arr3[inx3]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                else if(inx3 >= len3 && (inx1 < len1 && inx2 < len2))
                {    
                    arr[inx] = Math.min(arr1[inx1], arr2[inx2]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr2[inx2]) inx2++;
                }
                else if(inx1 >= len1 && inx2 >= len2 && inx3 < len3)
                {
                    arr[inx] = arr3[inx3]; inx3++;
                }
                else if(inx2 >= len2 && inx3 >= len3 && inx1 < len1)
                {
                    arr[inx] = arr1[inx1]; inx1++;
                }
                else if(inx1 >= len1 && inx3 >= len3 && inx2 < len2)
                {
                    arr[inx] = arr2[inx2]; inx2++;
                }
                else
                {
                    arr[inx] = Math.min(Math.min(arr1[inx1], arr2[inx2]), arr3[inx3]);
                    if( arr[inx] == arr1[inx1]) inx1++;
                    if( arr[inx] == arr2[inx2]) inx2++;
                    if( arr[inx] == arr3[inx3]) inx3++;
                }
                inx++;
            }
        }
        return arr;
    }
}
public class Min 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] str = {4};  
        int m  = min(str);
        System.out.println("m="+m);
    }
    public static int min(int[] array)
    {
        int min = Integer.MAX_VALUE;
        if(array != null)
        {
            int len = array.length;
            if(len > 0)
            {
                min = array[0];
                for(int i = 1; i<len; i++)
                {
                    if(min > array[i])
                        min = array[i];
                }
            }
        }
        return min;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class MinSumNum {
    public static void main(String[] args) {
        test0();
        test1();
        test11();
        test12();
//        test2();
//        test3();
//        test4();
        //test5();
        //test6();
    }

    public static int minSquareTermDY(int n, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(n == 0) {
//            for(Integer e : list) {
//                System.out.print("[" + e + "]");
//            }
//            System.out.println();
            return 0;
        } else if(n > 0) {
            int inx =(int)Math.sqrt(n) + 1;
            for(int i=1; i<= inx; i++) {

                list.add(i);
                Integer value = map.get(n-i*i);
                Integer m = value;
                if(value == null){
                    m = minSquareTermDY(n-(i*i), map, list);
                    if(m < Integer.MAX_VALUE)
                        m += 1;
                }
                min = Math.min(min, m);
                System.out.println("n-i*i=[" + (n-i*i) + "] min[" + min + "]"); 
                
                if(n - i*i < 0)
                    map.put(n-i*i, Integer.MAX_VALUE);
                else
                    map.put(n-i*i, min);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        } 
        return min;
    }
    public static int minSquareTerm(int n, Map<Integer, Integer> map, List<Integer> list) {
        int min = Integer.MAX_VALUE;
        if(n == 0) {
//            for(Integer e : list) {
//                System.out.print("[" + e + "]");
//            }
//            System.out.println();
            return 0;
        } else if(n > 0) {
            int inx =(int)Math.sqrt(n) + 1;
            for(int i=1; i<= inx; i++) {

                list.add(i);
                int m = minSquareTerm(n-(i*i), map, list);
                if(m < Integer.MAX_VALUE)
                    m += 1;

                min = Math.min(min, m);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        } 
        return min;
    }

    public static int minCoin(int s, Integer[] arr, Map<Integer, Integer> map) {
        int min = Integer.MAX_VALUE;
        if(s == 0)
            return 0;
        else if(s > 0) {
            if(arr != null) {
                for(Integer n : arr) {
                    Integer value = map.get(s-n);
                    Integer m = 0;
                    if(value == null){
                        m = minCoin(s-n, arr, map);
                        if(m < Integer.MAX_VALUE)
                            m += 1;
                    }else{
                       m = value;
                    }

                    min = Math.min(min, m);

                    map.put(s-n, min);
                }
            }
        }
        return min;
    }

    static void test0() {
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(4, map, list);
        System.out.println("min=[" + min + "]");
        Aron.end();
    }
    static void test1() {
        Aron.beg();
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(10, map, list);
        System.out.println("min=[" + min + "]");
        Aron.end();
    }
    static void test11() {
        Aron.beg();
        StopWatch sw = new StopWatch();
        sw.start();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTerm(50, map, list);
        //System.out.println("min=[" + min + "]");

        sw.printTime(); 

        Aron.end();
    }

    static void test12() {
        Aron.beg();
        StopWatch sw = new StopWatch();
        sw.start();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        List<Integer> list = new ArrayList<Integer>();
        int min = minSquareTermDY(50, map, list);
        //System.out.println("min=[" + min + "]");

        sw.printTime(); 

        Aron.end();
    }
    static void test2() {
        Aron.beg();
        Integer[] arr = {1, 2}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test3() {
        Aron.beg();
        Integer[] arr = {1}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test4() {
        Aron.beg();
        Integer[] arr = {3}; 
        int s = 3;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }

    static void test5() {
        Aron.beg();
        Integer[] arr = {2, 5}; 
        int s = 10;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }
    static void test6() {
        Aron.beg();
        Integer[] arr = {2, 5, 100}; 
        int s = 100;
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        int min = minCoin(s, arr, map);
        System.out.println("min[" + min + "]"); 
        Aron.end();
    }
}
public class MiniDiffSortedArray 
{
    public static void main(String[] args)
    {
        System.out.println("MiniDiffSortedArray");
        test1();
    }
    public static void test1()
    {
        int[] arr1 = {2, 4, 9, 20};
        int[] arr2 = {1, 14, 16, 80};
        int min = miniDiff(arr1, arr2);
        System.out.println("min=["+min+"]");
    }

    public static int miniDiff(int[] arr1, int[] arr2)
    {
        int diff = Integer.MAX_VALUE;
        if(arr1 != null && arr2 != null)
        {
            int inx1 = 0;
            int inx2 = 0;
            while(inx1 < arr1.length && inx2 < arr2.length)
            {
                diff = Math.min(diff, Math.abs(arr1[inx1] - arr2[inx2]));
                int min = Math.min(arr1[inx1], arr2[inx2]); 
                if(min == arr1[inx1]) inx1++;
                if(min == arr2[inx2]) inx2++;
            }
        }
        return diff;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

// Find the minimum distance between two given words
public class MinimumDistanceWord{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    static void test0(){
        Aron.beg();
        String[] arr = {"a", "b", "c", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "b";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        String[] arr = {"a", "b", "c", "e"}; 
        String word1 = "a";
        String word2 = "e";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 3);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "e";
        String word2 = "a";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "e";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 1);

        Aron.end();
    }
    static void test4(){
        Aron.beg();
        String[] arr = {"a", "b", "a", "e"}; 
        String word1 = "a";
        String word2 = "a";
        int dist = minimumDistance(arr, word1, word2);
        Test.t(dist == 0);

        Aron.end();
    }
    //[ file=minidistanceword.html title=""
    static int minimumDistance(String[] wordArray, String word1, String word2){
        int minDistance = Integer.MAX_VALUE;
        if(word1 != null && word2 != null){
            int index1 = -1;
            int index2 = -1;
            for(int i=0; i<wordArray.length; i++){
                if(word1.equals(wordArray[i]))
                    index1 = i; 
                
                if(word2.equals(wordArray[i]))
                    index2 = i;

                if(index1 != -1 && index2 != -1){
                    int dist = Math.abs(index1 - index2);
                    minDistance = Math.min(dist, minDistance);
                }
            }
        }
        return minDistance;
    }
    //]
} 
public class ModifyBinSearch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] array = {1, 2, 10, 4};
        int left = 0; int right = array.length-1;
        int max = max2(array, left, right);
        System.out.println("max="+max);
    }
    public static int max2(int[] array, int left, int right)
    {
        if(array != null)
        {
            int mid = (left + right)/2;
            if(mid < right)
            {
                if(array[mid] < array[mid + 1])
                {
                    return max2(array, mid+1, right);
                }
                else
                    return max2(array, left, mid);
            }
            else
                return array[mid];
        }
        return -1000;
    }
    public static int max(int[] array, int left, int right)
    {
        if(array != null)
        {
            if(array.length == 0)
            {
                return -1000;
            }
            else if(array.length == 1)
            {
                return array[0]; 
            }
            else //two or more elements 
            {
                int mid = (left + right)/2;
                if(right - left > 1)
                {
                    if(array[mid-1] < array[mid])
                        return max(array, mid, right);
                    else
                        return max(array, left, mid-1);
                }
                else
                {
                    return array[left] < array[right]? array[right]:array[left];
                }
            }
        }
        return -1000;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*; 

class MultiplyArrayInteger {
    public static void main(String args[]) {
        test00();
        test0();
        test1();
    }

    //[ file=multiply.html title=""
    /**
    * Multiple all the integers except the current one
    * No Division is allowed
    * Runtime is O(n)
    * [2, 3, 4] => [3*4, 2*4, 2*3] => [12, 8, 6]
    */ 
    public static int[] multiple(int[] arr){
        if (arr == null){
            throw new IllegalArgumentException("arr must not be null.");
        }else{
            int len = arr.length;
            int[] arr1 = new int[len];
            int[] arr2 = new int[len];
            if(len > 1){
                arr1[0] = arr2[len-1] = 1;
                for(int i=1; i<len; i++){
                    arr1[i] = arr[i-1]*arr1[i-1];
                    arr2[len-1 - i] = arr[len-i]*arr2[len-i];
                }
                for(int i=0; i<len; i++)
                arr1[i] = arr1[i]*arr2[i];
            }
            return arr1;
        }
    } 
    //]
    public static void test00() {
        Aron.beg();
        int[] arr1 = {2}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);

        Aron.end();
    }

    public static void test0() {
        Aron.beg();
        int[] arr1 = {2, 3}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();
        int[] arr1 = {2, 3, 4}; 
        int[] arr = multiple(arr1);
        Aron.printArray(arr);
        Aron.end();
    }

}
public class MultiplyBlockMatrix
{
    public static void main(String[] args)
    {
        System.out.println("Multiply Block Matrix!");
    }
    public static int[][] multiply(int[][] A, int col_lo_a, int col_hi_a, 
                                              int row_lo_a, int row_hi_a,
                                    int[][] B,int col_lo_b, int col_hi_b,
                                              int row_lo_b, int row_hi_b)
    {
        int[][] C = null;
        int col_mid_a = (col_lo_a + col_hi_a)/2;
        int row_mid_a = (row_lo_a + row_hi_a)/2;
        int col_mid_b = (col_lo_b + col_hi_b)/2;
        int row_mid_b = (row_lo_b + row_hi_b)/2;

        int[][] a11 = multiply(A, B, col_lo_a, col_mid_a, row_lo_a, row_mid_a,
                                     col_lo_b, col_mid_b, row_lo_b, row_mid_b);

        int[][] a12 = multiply(A, B, col_mid_a, col_hi_a, row_lo_a, row_mid_a, 
                                     col_mid_b, col_hi_b, row_lo_b, row_mid_b);
        int[][] a21 = multiply(A, B, col_lo_a,  col_mid_a,row_mid_a,row_hi_a,
                                     col_lo_b,  col_mid_b,row_mid_b,row_hi_b);
        int[][] a22 = multiply(A, B, col_mid_a, col_hi_a, row_mid_a,row_hi_a,
                                     col_mid_b, col_hi_b, row_mid_b,row_hi_b);
        return C;
    }
}
import java.io.*;
import classfile.*;

class MultiplyLongInt
{
	public static void main(String args[])
	{
        test1();
        test2();
        test3();
        test4();
        test5();
        test1_multiplynew();
        test2_multiplynew();
        test3_multiplynew();

	}
    //[file=multiplynew.html title=""     
    public static int[] multiplynew(int[] arr1, int[] arr2){
        int len1 = arr1.length;
        int len2 = arr2.length;
        int len = len1 + len2;
        int[][] arr = new int[len1][len1+len2];

        for(int i=len2-1; i >= 0; i--){
            int carry = 0;
            int j=0;
            for(j=len1-1; j >= 0; j--){
                int shiftLeft = i + 1;
                arr[i][j + shiftLeft] = (arr1[j]*arr2[i] + carry) %10;
                carry = (arr1[j]*arr2[i]+carry) / 10;
            }
            arr[i][(i+1)+j] = carry;
        }

        int[] total = new int[len];
        int carry = 0;
        for(int j=len-1; j >= 0; j--){
            int s=0;
            for(int i=0; i < len2; i++){
                s += arr[i][j];
            }
            total[j] = (s + carry) % 10;
            carry = (s + carry)/10;
        }
        return total;
    }
    //]

    //[file=multiplylong.html title="multiply long integer"
    public static int[] multiply(int[] arr1, int[] arr2) {
        if(arr1 != null && arr2 != null && arr1.length > 0 && arr2.length > 0) {
            int len1 = arr1.length;
            int len2 = arr2.length;
            Reverse(arr1);        
            Reverse(arr2);
            int[][] array = new int[len1][len1+len2];

            for(int i=0; i<len1; i++) {
                int carrying = 0;
                int j=0;
                for(j=0; j<len2; j++) {
                    int t = arr1[i]*arr2[j] + carrying;
                    array[i][j + i] = t % 10;
                    carrying = t / 10;
                }
                array[i][j + i] = carrying;
            }

            int[] total = new int[len1+len2];
            int carrying = 0;
            for(int i=0; i<len1 + len2; i++) {
                int s = 0;
                for(int j=0; j < len1; j++) {
                    s += array[j][i];
                }
                total[i] = (s + carrying) % 10; 
                carrying = (s + carrying) / 10;
            }
            Reverse(total);
            return total;
        }
        return null;
    }

    public static void Reverse(int[] A) {
        if(A != null) {
            int len = A.length;
            for(int i=0; i<len/2; i++) {
                int tmp = A[i];
                A[i] = A[len-1-i];
                A[len-1-i] = tmp;
            }
        }
    }
    //]
    

    static void test1(){
        Aron.beg();
		int[] A = {9, 9, 9};
		int[] B = {9, 0, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);
        Aron.end();
    }
    static void test2(){
        Aron.beg();
		int[] A = {9, 9, 9};
		int[] B = {9, 9, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    }
    static void test3(){
        Aron.beg();
		int[] A = {9};
		int[] B = {9, 9, 9};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    } 

    static void test4(){
        Aron.beg();
		int[] A = {9};
		int[] B = {1};
		int[] S = multiply(A, B);
        Aron.printArray(S);

        Aron.end();
    } 

    static void test5(){
        Aron.beg();
		int[] A = {9, 9};
		int[] B = {9};
		int[] S = multiply(A, B);
        Aron.printArray(S);
        Aron.end();
    } 

    static void test1_multiplynew(){
        Aron.beg();
        int[] A = {9, 9};
		int[] B = {9};
		int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }

    static void test2_multiplynew(){
        Aron.beg();
		int[] A = {1};
		int[] B = {9};
	    int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }

    static void test3_multiplynew(){
        Aron.beg();
		int[] A = {0};
		int[] B = {0};
	    int[] S = multiplynew(A, B);
        Aron.printArray(S);
        Print.p(0*0);

        Aron.end();
    }
    static void test4_multiplynew(){
        Aron.beg();
		int[] A = {9};
		int[] B = {9};
		int[] S = multiplynew(A, B);
        Aron.printArray(S);

        Aron.end();
    }
}
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

class Node
{
    int coeff;
    int power;
    String data;
    Node next;
    public Node(int coeff, int power, String data)
    {
        this.coeff = coeff;
        this.power = power;
        this.data = data;
        this.next = null;
    }
}

class SLinkedList
{
    Node head;
    public SLinkedList()
    {
        this.head = null;
    }
    public void add(Node node)
    {
        if(this.head == null)
        {
            this.head = node;
        }
        else
        {
            Node curr = this.head;
            while(curr.next != null)
            {
                curr = curr.next;
            }
            curr.next = node; 
        }
    }
    public void show()
    {
        Node curr = this.head;
        while(curr != null)
        {
            System.out.println("["+curr.coeff+"]["+curr.power+"]");
            curr = curr.next;
        }
    }
}

public class MultiplyPolynomial 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        SLinkedList poly1 = new SLinkedList();
        SLinkedList poly2 = new SLinkedList();
        poly1.add(new Node(1, 2, "x"));
        poly1.add(new Node(2, 3, "x"));
        poly2.add(new Node(4, 5, "x"));
        poly2.add(new Node(6, 7, "x"));
        poly1.show();
        System.out.println("================");
        poly2.show();
        System.out.println("================");
        multiply(poly1, poly2);
        System.out.println("================");
        add(poly1, poly2);
        System.out.println("================");
        TestPolyArray();
    }
    public static void TestPolyArray()
    {
        int[] p1 = {1, 2, 3};
        int[] p2 = {2, 0, 4, 5};
        int[] p = MultiplePolyArray(p1, p2);

        for(int i=0; i<p1.length; i++)
            System.out.print("p1["+p1[i]+"]");
        System.out.println();

        for(int i=0; i<p2.length; i++)
            System.out.print("p2["+p2[i]+"]");
        System.out.println();

        for(int i=0; i<p.length; i++)
            System.out.print("["+p[i]+"]");

        System.out.println();
    }
    public static SLinkedList add(SLinkedList poly1, SLinkedList poly2)
    {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        SLinkedList poly = new SLinkedList();
        if(poly1 != null && poly2 != null && poly1.head != null && poly2.head != null)
        {
            Node curr1 = poly1.head; 
            while(curr1 != null)
            {
                Integer coeff = (Integer)map.get(curr1.power);
                if(coeff != null)
                {
                    map.put(new Integer(curr1.coeff + coeff), new Integer(curr1.power));  
                }
                else
                {
                    map.put(new Integer(curr1.coeff), new Integer(curr1.power));
                }
                curr1 = curr1.next;
            }

            Node curr2 = poly2.head; 
            while(curr2 != null)
            {
                Integer coeff = (Integer)map.get(curr2.power);
                if(coeff != null)
                {
                    map.put(new Integer(curr2.coeff + coeff), new Integer(curr2.power));  
                }
                else
                {
                    map.put(new Integer(curr2.coeff), new Integer(curr2.power));
                }
                curr2 = curr2.next;
            }
            Set<Map.Entry<Integer, Integer>> set = map.entrySet();
            for(Map.Entry<Integer, Integer> entry : set)
            {
                Integer coeff = entry.getKey();
                Integer power = entry.getValue();
                poly.add(new Node(coeff, power, "x"));
            }
            poly.show();
        }
        return poly;
    }
    public static SLinkedList multiply(SLinkedList poly1, SLinkedList poly2)
    {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        SLinkedList poly = new SLinkedList();
        if(poly1 != null && poly2 != null && poly1.head != null && poly2.head != null)
        {
            Node curr1 = poly1.head; 
            Node curr2 = poly2.head;
            while(curr1 != null)
            {
                curr2 = poly2.head;
                while(curr2 != null)
                {
                    Node node = new Node(curr2.coeff*curr1.coeff, curr2.power+curr1.power, "x"); 
                    Integer coeff = (Integer)map.get(new Integer(node.power));
                    if(coeff != null)
                    {
                        map.put(new Integer(node.coeff + coeff), new Integer(node.power));  
                    }
                    else
                    {
                        map.put(new Integer(node.coeff), new Integer(node.power));
                    }
                    curr2 = curr2.next;
                }
                curr1 = curr1.next;
            }
        }
        Set<Map.Entry<Integer, Integer>> set = map.entrySet();
        for(Map.Entry<Integer, Integer> entry : set)
        {
            Integer coeff = entry.getKey();
            Integer power = entry.getValue();
            poly.add(new Node(coeff, power, "x"));
        }
        poly.show();
        return poly;
    }

    public static int[] MultiplePolyArray(int[] p1, int[] p2)
    {
        if(p1 != null && p2 != null)
        {
            int len1 = p1.length;
            int len2 = p2.length;
            if(len1 > 0 && len2 > 0)
            {
                int[][] p = new int[len1][len1+len2];
                for(int i=0; i<len1; i++)
                {
                   for(int j=0; j<len2; j++)
                   {
                       p[i][j+i] = p1[i]*p2[j];
                   } 
                }

                for(int j=0; j<len1+len2; j++)
                {
                    int s=0;
                    for(int i=0; i<len1; i++)
                    {
                        s += p[i][j];
                        if(i == len1-1)
                            p[i][j] = s;
                    }
                }
                return p[len1-1];
            }
        }
        return null;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;

public class MyDict{
    public static void main(String[] args) {
        //test0();
        Print.pbl("len=" + args.length);
        if(args.length > 0){
            Print.pbl("args[0]=" + args[0]);
            find(args[0]);
        }
        //test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "/Users/cat/myfile/github/java/text/mydict.txt";
        List<ArrayList<String>> list2d = Aron.readFileSaperater(file);
        Aron.printList2dArr(list2d);

        Aron.end();
    }

    public static void find(String word){
        String pattern = "\\w+";
        Pattern r = Pattern.compile(word, Pattern.CASE_INSENSITIVE);

        String file = "/Users/cat/myfile/github/java/text/mydict.txt";
        List<ArrayList<String>> list2d = Aron.readFileSaperater(file);
        for(ArrayList<String> list : list2d){
            String[] arr = list.get(0).split("\\s+");

            Matcher mat = r.matcher(arr[0]);
            if(mat.find()){
                Print.pbl("w=" + arr[0] + " " + list);
            }
        }
        //Aron.printList2dArr(list2d);
    } 
    public static void test1(){
        Aron.beg();
        find("abacus");
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

class GNode{
    int data;
    GNode next;
}

class Graph{
    private Map<GNode, GNode> map = new HashMap<GNode, GNode>();
    private Set<GNode> set = new HashSet<GNode>();
    public Graph(){
    }
    public void addNode(GNode node){
        set.add(node);
    }
    public void deleteNode(GNode node){
        set.remove(node);
        GNode curr = map.get(node);
        if(curr != null){
           map.put(curr, null);
        }
    }
    public void addEdge(GNode fromNode, GNode toNode){
        GNode curr = map.get(fromNode);        
        if(curr != null){
            while(curr.next != null ){
                curr = curr.next;
            }
            curr.next = toNode;
        }
    }

    public void removeEdge(){
    }

    public List<GNode> adjacentNode(GNode node){
        List<GNode> list = new ArrayList<GNode>(); 
        GNode curr = map.get(node);

        while(curr != null){
            list.add(curr);
            curr = curr.next;
        }
        return list; 
    }
}

public class MyGraph{
    public static void main(String[] args) {
    }
    static void test0(){
        Aron.beg();
        Aron.end();
    }
} 
import java.util.*;
import java.io.*;
import classfile.*;

//[ file=hashmap1.html title=""
class Entry{
    public String key;
    public Object value;
    public Entry next;
    public Entry(String key, Object value){
        this.key = key;
        this.value = value;
    }
}

class Hash{
    public Entry[] arr;
    public int max;
    public int count = 0;
    public Hash(int max){
        this.max = max;
        arr = new Entry[max];
    }

    public Node get(String key){
        int hash = key.hashCode() % max;
        return (Node)arr[hash].value;
    }
    public void delete(String key){
        if(key != null){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr != null){
                Entry prev = null;
                while(curr != null){
                    if(curr.key == key)
                        break;
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(prev == null){
                    arr[hash] = curr.next;
                    count--;
                }else{
                    if(curr != null){
                        prev.next = curr.next;
                        count--;
                    }
                }
            }
        }
    }
    public void put(String key, Node node){
        if(count < max){
            int hash = key.hashCode() % max;
            Entry curr = arr[hash];
            if(curr == null){
                arr[hash] = new Entry(key, node);
                count++;
            }
            else{
                Entry prev = null;
                while(curr != null){
                    if(curr.key.equals(key)){
                        // Replace with new value
                        curr.value = node;
                        break;
                    }
                    else{
                        prev = curr;
                        curr = curr.next;
                    }
                }
                // No key is found
                if(curr == null){
                    prev.next = new Entry(key, node);
                    count++;
                }
            }
        }
        
    }
}
//]


public class MyHash{
    public static void main(String[] args) {
        test00_hash();
        test01_hash();
        test02_hash();
        test03_hash();
        test04_hash();
        test05_hash();
        test06_hash();
        test07_hash();
        test08_hash();
        test09_hash();
        test010_hash();
        test011_hash();
        test012_hash();
    }
    
        
    static void test00_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        Node node = (Node)hash.get("a");

        Test.f(node, null);
        Test.f(node, new Node(3));
        Test.t(node, new Node(1));

        Aron.end();
    }
    static void test01_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("a", new Node(2));
        Node node = (Node)hash.get("a");
        Test.t(node, new Node(2));

        Aron.end();
    }
    static void test02_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test03_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.put("c", new Node(3));
        hash.put("e", new Node(4));
        hash.put("e", new Node(5));
        Node node = (Node)hash.get("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
            Aron.line();
        }

        Aron.end();
    }
    static void test04_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.delete("a");
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                curr = curr.next;
            }
        }

        Aron.end();
    }
    static void test05_hash(){
        Aron.beg();
        Hash hash = new Hash(4);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        hash.delete("a");
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test06_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 2);

        Aron.end();
    }
    static void test07_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 1);
        Test.t(list.get(0), 1);

        Aron.end();
    }
    static void test08_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("bba", new Node(2));
        List<Integer> list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        hash.delete("bba");
        hash.delete("a");

        list = new ArrayList<Integer>(); 
        for(Entry curr : hash.arr){
            while(curr != null){
                Node n = (Node)curr.value;
                Print.pb(n.data);
                list.add(n.data);
                curr = curr.next;
            }
        }
        Test.t(list.size(), 0);

        Aron.end();
    }
    static void test09_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(2));
        Test.t(hash.count, 2);

        Aron.end();
    }
    static void test010_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        Test.t(hash.count, 1);

        Aron.end();
    }
    static void test011_hash(){
        Aron.beg();
        Hash hash = new Hash(2);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
    static void test012_hash(){
        Aron.beg();
        Hash hash = new Hash(3);
        hash.put("a", new Node(1));
        hash.put("b", new Node(1));
        hash.put("c", new Node(1));
        Test.t(hash.count, 3);

        Aron.end();
    }
}
class MyNode
{
	public MyNode left;
	public MyNode right;
	public int data;
	public MyNode(int n)
	{ data = n; left = null; right = null; }
	public MyNode left()
	{ return left; }
	public MyNode right()
	{ return right; }
	public void setLeft(MyNode l)
	{ left = l;}
	public void setRight(MyNode r)
	{ right = r;}

    public MyNode prev()
	{ return left;}
    public MyNode next()
    { return right;}

    public void setPrev(MyNode p){
        left = p;
    }
    public void setNext(MyNode n){
        right = n;
    }
    public int data(){
        return data;
    }
}


import java.util.*;
import java.io.*;
import java.time.*;
import java.time.format.DateTimeFormatter;
import classfile.*;

enum Type{
    MOTORCYCLE,
    COMPACT,
    BUS,
}

class Ticket{
    int id;
    double price;
    
    LocalDateTime startTime;
    LocalDateTime endTime;
    public Ticket(int id, int price,  LocalDateTime startTime, LocalDateTime endTime){
        this.id = id;
        this.price = price;
        this.startTime = startTime;
        this.endTime = endTime;
    }
}

class Parking{
    public Vehicle vehicle;
    public Parking(Vehicle v){
        vehicle = v;
    }
}

interface Vehicle{
    public Type getType();
}

class Motorcycle implements Vehicle{
    public Type type;
    public Motorcycle(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class Compact implements Vehicle{
    public Type type;
    public Compact(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class Bus implements Vehicle{
    public Type type;
    public Bus(Type type){
        this.type = type;
    }
    public Type getType(){
        return type;
    }
}

class ParkingLot{
    double total;
    Map<Ticket, Parking>  parkMap = new HashMap<Ticket, Parking>();
    int compactMax;
    int compactCount;
    int motorcycleMax;
    int motocycleCount;
    int busMax;
    int busCount;

    public ParkingLot(int cm, int mm, int bm){
        total = 0;
        compactMax = cm;
        motorcycleMax = mm;
        busMax = bm;
    }

    public int getTicket(LocalDateTime st, LocalDateTime et){
        int count = 0;
        for(Map.Entry<Ticket, Parking> entry : parkMap.entrySet()){
            count++;
        }
        return count;
    }

    public double ticketPrice(){
        return 1;
    }
    public void add(Ticket t, Parking p){
        if(!isFull()){
            if(p.vehicle.getType() == Type.COMPACT && compactCount < compactMax)
                compactCount++;
            else if(p.vehicle.getType() == Type.MOTORCYCLE && motocycleCount < motorcycleMax)
                motocycleCount++;
            else if(p.vehicle.getType() == Type.BUS && busCount < busMax)
                busCount++;

            parkMap.put(t, p);
        }
    }
    public void remove(Ticket t){
        Parking p = parkMap.get(t);
        if(p != null){
            if(p.vehicle.getType() == Type.COMPACT)
                compactCount--;

            if(p.vehicle.getType() == Type.MOTORCYCLE)
                motocycleCount--;

            if(p.vehicle.getType() == Type.BUS)
                busCount--;
            
            parkMap.remove(t);

            t.endTime = LocalDateTime.now();
            parkMap.put(t, p);
        }
    }
    public boolean isFullCompact(){
        return compactCount < compactMax;
    }
    public boolean isFullMotorcycle(){
        return motocycleCount < motorcycleMax;
    }
    public boolean isFullBus(){
        return busCount < busMax;
    }
    public boolean isFull(){
        return (compactCount + motocycleCount + busCount) < (compactMax + motorcycleMax + busMax) ? false : true;
    }
}


public class MyParking{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();

        ParkingLot pl = new ParkingLot(4, 5, 6);
        LocalDateTime time1 = LocalDateTime.parse("2007-12-03T10:15:30", DateTimeFormatter.ISO_LOCAL_DATE_TIME);
        Ticket t1 = new Ticket(1, 100, time1, null);
        Parking park1 = new Parking(new Compact(Type.COMPACT));
        pl.add(t1, park1);
        System.out.println("compactCount[" + pl.compactCount + "]"); 
        System.out.println("motocycleCount[" + pl.motocycleCount+ "]"); 
        System.out.println("busCount[" + pl.busCount+ "]"); 
        
        pl.remove(t1);
        
        System.out.println("\n---------------------------------"); 

        System.out.println("compactCount[" + pl.compactCount + "]"); 
        System.out.println("motocycleCount[" + pl.motocycleCount+ "]"); 
        System.out.println("busCount[" + pl.busCount+ "]"); 

        Aron.end();
    }
} 
interface Shape
{
    public double getArea();
}

class Circle implements Shape
{
    double x;
    double y;
    double radial;
    public Circle(double x, double y, double radial)
    {
        this.x = x;
        this.y = y;
        this.radial = radial;
    }
    public double getArea()
    {
        return 3.14*radial*radial;
    }
}

class Rectangle implements Shape
{
    double topx;
    double topy;
    double bottomx;
    double bottomy;
    public Rectangle(double topx, double topy, double bottomx, double bottomy)
    {
        this.topx = topx;
        this.topy = topy;
        this.bottomx= bottomx;
        this.bottomy= bottomy;
    }
    public double getArea()
    {
        return Math.abs(bottomx - topx)*Math.abs(bottomy - topy);
    }
}


public class MyShape 
{
    public static void main(String[] args)
    {
        Shape s1 = new Circle(3.0, 4.0, 5.0); 
        Shape s2 = new Rectangle(3.0, 4.0, 5.0, 6.0); 
        System.out.println("s1=" + s1.getArea());
        System.out.println("s2=" + s2.getArea());
    }
}
import classfile.*;

class StopWatch {
    private long startTime = 0;
    private long stopTime = 0;
    private boolean running = false;

    public void StopWatch(){
        this.startTime = System.currentTimeMillis();
        this.running = true;
    }
    

    public void start() {
        this.startTime = System.currentTimeMillis();
        this.running = true;
    }

    public void stop() {
        this.stopTime = System.currentTimeMillis();
        this.running = false;
        long elapsed = ((System.currentTimeMillis() - startTime) / 1000000);
        Print.pbl(elapsed);
        Print.pbl("startTime=" + startTime);
        Print.pbl("stopTime=" + stopTime);
        Print.pbl("diff=" + (startTime - stopTime));
    }

    //elaspsed time in milliseconds
    public long getElapsedTime() {
        long elapsed;
        if (running) {
            elapsed = (System.currentTimeMillis() - startTime);
        } else {
            elapsed = (stopTime - startTime);
        }
        return elapsed;
    }

    public void diff() {
        Print.pbl(getElapsedTime());
    }

    //elaspsed time in seconds
    public long getElapsedTimeSecs() {
        long elapsed;
        if (running) {
            elapsed = ((System.currentTimeMillis() - startTime) / 1000);
        } else {
            elapsed = ((stopTime - startTime) / 1000);
        }
        return elapsed;
    }
}

public class MyStopWatch {
    public static void main(String[] args) {
        StopWatch sw = new StopWatch();
        for(int i=0; i < 100; i++)
            System.out.println(i);
        sw.stop();
    }
}

import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class TNode {
    boolean isWord;
    TNode[] array = new TNode[26];
}

class Tries {
    TNode root;
    public Tries() {
        root = new TNode();
        root.isWord = true;
    }
    public int map(char ch) {
        return (int)ch - 'a';
    }

    //[ file=newtries.html title=""
    public  void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();

            add(r.array[arr[k]], arr, k+1);
        }else if(k == arr.length){
            r.isWord = true;
        }
    }

    public  boolean contains(TNode r, int[] arr, int k) {
        if(r != null){
            if(k < arr.length) {
                return contains(r.array[arr[k]], arr, k+1);
            }else if (k == arr.length){
                return r.isWord;
            }
        }
        return false;
    }
    public  void addWord(TNode r,  String word, int k) {
        if( k < word.length()) {
            if(r.array[map(word.charAt(k))] == null)
                r.array[map(word.charAt(k))] = new TNode();

            addWord(r.array[map(word.charAt(k))], word, k+1);
        }else{
            r.isWord = true;
        }
    }
    public  boolean containsWord(TNode r, String word, int k) {
          if(r != null){
              if(k == word.length())
                  return r.isWord;
              else if(k < word.length()){
                  return containsWord(r.array[map(word.charAt(k))], word, k+1);
              }
          }
          return false;
    }
    //]
}

class MyTries {
    public static void main(String args[]) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();

        test11();
        test12();
        test13();
        test14();
        test15();
    }
    
    public static void test0() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test1() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test2() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0, 0, 1};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }
    public static void test3() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0, 0, 1};
        int[] arr1 = {0, 0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test4() {
        Aron.beg();
        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr = {0};
        int[] arr1 = {0,0};
        add(t.root, arr, k);
        System.out.println("[" + (t.contains(t.root, arr, h) == true)+ "]"); 
        Aron.end();
    }

    public static void test5() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        int[] arr1 = {0,0,0};
        int[] arr3 = {0};
        add(t.root, arr1, k);
        add(t.root, arr3, k);

        int[] arr2 = {0,0};
        System.out.println("[" + (t.contains(t.root, arr1, h) == true)+ "]"); 
        System.out.println("[" + (t.contains(t.root, arr2, h) == false)+ "]"); 
        System.out.println("[" + (t.contains(t.root, arr3, h) == true)+ "]"); 

        Aron.end();
    }
    // 'a'-> 0
    // 'b'-> 1
    // 'z'-> 25
    public static int map(char ch) {
        return (int)ch - 'a';
    }
    public static void add(TNode r, int[] arr, int k) {
        if( k < arr.length) {
            if(r.array[arr[k]] == null)
                r.array[arr[k]] = new TNode();
            add(r.array[arr[k]], arr, k+1);
        }else{
            r.isWord = true;
        }
    }

    public static void test11() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "abc";
        t.addWord(t.root, word, k);
        System.out.println("[" + (t.containsWord(t.root, word, h) == true ) + "]"); 
        Aron.end();
    }
    public static void test12() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "abc";
        t.addWord(t.root, word, k);
        String word1 = "ab";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == false) + "]"); 
        Aron.end();
    }
    public static void test13() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "a";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == true) + "]"); 

        Aron.end();
    }
    public static void test14() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "aa";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == false) + "]"); 

        Aron.end();
    }
    public static void test15() {
        Aron.beg();

        Tries t = new Tries();
        int k=0;
        int h=0;
        String word = "a";
        t.addWord(t.root, word, k);
        String word1 = "";
        System.out.println("[" + (t.containsWord(t.root, word1, h) == true) + "]"); 

        Aron.end();
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

class MyNode{
    String data;
    int count;
    public MyNode(String data, int count){
        this.data = data;
        this.count = count;
    }
}

class TextMap{

    public TextMap(){
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }
}

public class AnimalLogic{
    public static void main(String[] args) {
//        test0();
//        test1();
        //test2();
//        test3();
//        test4();
//        test5();
//        test00();
//        test11();
//        test12();
        test13();
    }

    static void test00(){
        Aron.beg();
        
        int n = random(1);
        Print.pbl("n=" + n);

        for(int i=0; i<10; i++){
            int n1 = random(2);
            Print.pbl("n1=" + n1);
        }

        Aron.end();
    }

    // generate number [1...n] 
    public static int random(int n){
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public static void test12(){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }

    public static void test13(){
        Aron.beg();

        List<String> list = getWords("./text/animal_logic.txt"); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        Map<Map<String, String>, Map<Integer, String>> revMap = createBiMap(map);

        String seedFirst = "one";
        String seedSecond = "two";
        int numWords = 10;
        List<String> wordList = generateText(numWords, seedFirst, seedSecond, map, revMap);
        Aron.printList(wordList);
    }

    public static List<String> generateText(int numWords, String seedFirst, String seedSecond, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> revMap){

        List<String> list = new ArrayList<String>(); 
        list.add(seedFirst);
        list.add(seedSecond);
        for(int i=0; i<numWords-2; i++){
            Map<String, String> key = new  HashMap<String, String>();
            key.put(seedFirst, seedSecond);

            Map<String, Integer> value = map.get(key);
            if(value != null){
                 Map<Integer, String> revValueMap = revMap.get(key);
                 if(revValueMap != null){
                     int ranKey = random(revValueMap.size());
                     String nextWord = revValueMap.get(ranKey);
                     Print.pbl("nextWord=" + nextWord + " " + "ranKey=" + ranKey);
                     seedFirst = seedSecond;
                     seedSecond = nextWord;
                     list.add(nextWord);
                 }
            }else{
                break;
            }
        }
        return list;
    }

//    public static Map<String, String> newKeyMap(Map<String, String> map, String newWord){
//        map.get
//    }

    public static Map<Map<String, String>, Map<Integer, String>> createBiMap(Map<Map<String, String>, Map<String, Integer>> map){
        Aron.beg();

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        } 
        return revMap;
    }

    public static void test11(){
        Aron.beg();
        String[] arr = {"dog", 
                        "cat", 
                        "cow", 
                        "dog", 
                        "cat", 
                        "cow", 
                        "rat", 
                        "pig"}; 

        Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();

        List<String> list = getWords("./text/animal_logic.txt"); 
        //Map<Map<String, String>, Map<String, Integer>> map = createMap(arr); 
        Map<Map<String, String>, Map<String, Integer>> map = createMap(list); 

        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()){
            Map<String, String> key = entry.getKey(); 
            Map<String, Integer> value = entry.getValue(); 
            for(Map.Entry<String, String> keyEntry : key.entrySet()){
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                revMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()){
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()){
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pp("\n");
            }
            Ut.l();
        } 

        Aron.end();
    }


    public static Map<Map<String, String>, Map<String, Integer>> createMap(List<String> list){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        for(int i=0; i<list.size() - 2; i++){
            Map<String, String> key = new HashMap<String, String>(); 
            Map<String, Integer> value = new HashMap<String, Integer>(); 
            key.put(list.get(i), list.get(i+1)); 
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key); 
            if(v == null){
                map.put(key, value);
            }else{
                Integer n = v.get(list.get(i+2));
                if(n == null){
                    v.put(list.get(i+2), 1);
                }else{
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    public static Map<Map<String, String>, Map<String, Integer>> createMap(String[] arr){
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>(); 
        List<String> list = Arrays.asList(arr); 
        map = createMap(list);
        return map;
    }
    public static void test0(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");

        String fileName = "text/myfile.txt";
        List<String> list = getWords(fileName); 

        for(String s : list){
            List<String> pairList = pair(s); 
            for(String k : pairList){
                if(map.containsKey(k)){
                    int count = map.get(k);
                    count++;
                    map.put(k, count);
                }else{
                    map.put(k, 1);
                }
            }
        }
        
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue() + "]");
        } 
        
        Aron.printList(list);

        Aron.end();
    }
    public static List<String> pair(String s){
        List<String> list = new ArrayList<String>(); 
        if(s.length() > 1){
            for(int k=0; k < s.length(); k++){
                for(int i=0; i < s.length()-(1 + k); i++){
                    list.add(s.substring(i, i+(2 + k)));
                }
            }
        }
        return list;
    }

    // read a text file capture all words
    // word: non-whitespace char 
    public static List<String> getWordsNonWhiteSpace(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)\\S+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    // read a text file and capture all words
    // word: a-z char
    public static List<String> getWords(String fileName){
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        
        List<String> wordList = new ArrayList<String>(); 
        List<String> list = Aron.readFile(fileName);
        for(String s : list){
            String[] arr = s.split("\\s+");
            for(String str : arr){
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()){
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }
    public static void test1(){
        Aron.beg();
        
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }

        Aron.end();
    }

    public static void test2(){
        Aron.beg();
                
        String fileName = "text/textfile.txt";
        List<String> list = getWordsNonWhiteSpace(fileName);
        Aron.printList(list);

        Aron.end();
    }

    public static void test3(){
        Aron.beg();
        String s = "abc";                
        int len = s.length();

            // "abc" [ "" -> "abc"]
            //       [ "a" -> "bc"]
            //       [ "ab"-> "c" ]
            for(int j=0; j<len-1; j++){
                    String prefix = s.substring(0, j);
                    String suffix = s.substring(j, len);
                    Print.pbl("prefix=" + prefix);
                    Print.pbl("suffix=" + suffix);
            }

        Aron.end();
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public static Map<Integer, String> inverseMap(Map<String, Integer> map){

        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        return revMap;
    }
    public static void test5(){
        Aron.beg();

        Map<String, Integer> map = new HashMap<String, Integer>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        Map<Integer, String> revMap = inverseMap(map); 

        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        Aron.end();
    }

    public static void test4(){
        Aron.beg();
        String s = "abc";                
        
        Map<String, Integer> map = new HashMap<String, Integer>(); 
        Map<Integer, String> revMap = new HashMap<Integer, String>(); 
        map.put("invert", 1);
        map.put("investable", 2);
        map.put("inverse", 1);
        map.put("definite", 1);
        map.put("definitely", 3);
        map.put("define", 3);
        map.put("be defined", 3);

        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()){
            Integer n = entry.getValue();
            
            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n){
                revMap.put(k, entry.getKey());
                k++;
            }
        } 
        
        for(Map.Entry<Integer, String> entry : revMap.entrySet()){
            Print.pbl(entry.getKey() + " , " + entry.getValue());
        } 

        // 1 -> k1
        // 2 -> k2
        // 3 -> k2

        Aron.end();
    }
} 

import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import classfile.*;

final class TextMap {
    String fileName;
    Map<List<String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() {
    }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = Aron.readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    public Map<List<String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<List<String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            List<String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.add(list.get(i));
            key.add(list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String prefix, String suffix, Map<List<String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {

        List<String> list = new ArrayList<String>();


        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            Print.pbl("firstPrefix =" + firstPrefix);
            Print.pbl("secondPrefix=" + secondPrefix);
            Print.pbl("inputSuffix=" + inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {

                        int ranKey = random(revValueMap.size());

                        String newSuffix = revValueMap.get(ranKey);
                        Print.pbl("newSuffix=" + newSuffix + " " + "ranKey=" + ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<List<String>, Map<String, Integer>> map) {

        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<List<String>, Map<String, Integer>> entry : map.entrySet()) {

            List<String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()) {
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        }
        return tableMap;
    }

    public List<String> textGeneMap() {

        List<String> list = getWords();
        map = prefixSuffixMap(list);
        // Map<List<String>, Map<String, Integer>> 

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<List<String>,  Map<String, Integer>> entry : map.entrySet()) {
            List<String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";

                for(String s : key){
                    Print.pp(s + " ");
                    str += s + " ";
                }
                str += "=>"

//                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "[" + valueEntry.getValue() + "]");
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                Ut.l();
                str += "\n";
                Print.pp("\n");
            }
            retList.add(str);
            Ut.l();
        }
        return retList;
    }

    public List<String> processFile(int maxWords, String prefix, String suffix) {
        Aron.beg();

        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class OpenFileFX extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");


        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                Print.pbl("file =" + file);
                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            Print.pbl("s=" + s);
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                Aron.beg();

                if(fileName != null) {
                    List<String> list = Aron.getWords(fileName);
                    Aron.printList(list);

                    if(prefixTF.getText().length() > 0 && prefixTF.getText().length() > 0) {
                        Print.pbl("prefixTF=" + prefixTF.getText());
                        Print.pbl("suffixTF=" + suffixTF.getText());
                        Print.pbl("maxWordsLable=" + maxWordsLable.getText());

                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            Print.pbl("maxWords=" + maxWords);
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                Print.pbl("s=" + s);
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }

                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }

                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 800, 600));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class NimGame{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        int num = 8;
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(num);
        boolean flag = false;
        boolean boo = nim(num, num, flag, list);
        System.out.println("nim[" + boo + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        int num = 1;
        List<Integer> list = new ArrayList<Integer>(); 
        list.add(num);
        boolean flag = false;
        boolean boo = nim(num, num, flag, list);
        System.out.println("nim[" + boo + "]"); 
        Aron.end();
    }
    // Init level = 0 
    public static boolean nim(int n, int prev, boolean flag, List<Integer> list){
        boolean ret = false;
        if(n == 0){
            if(prev == 1 && flag){
                for(Integer item : list){
                    System.out.println("item[" + item + "]"); 
                }
                ret = true;
            }
        }else if(n > 0){
            for(int i=1; i<=3; i++){
                list.add(n-i);
                System.out.println("[" + n + "]->(" + i + ")[" + (n-i) + "] flag[" + flag + "] prev[" + prev + "] i[" + i + "]"); 
                ret = nim(n-i, n, !flag, list);

                if(list.size() > 0)
                    list.remove(list.size()-1);
            }
        }
        return ret;
    } 
}

import java.util.*;
import java.io.*;
import classfile.*;

public class NonConsecutive{
    public static void main(String[] args) {
         test00_maxNonConsecutiveSum();
         test01_maxNonConsecutiveSum();
         test02_maxNonConsecutiveSum();
         test03_maxNonConsecutiveSum();
         test04_maxNonConsecutiveSum();
    }

    //[file=nonconsecutive.html title="maximum consecutive sum"
    // [ ] {4} 5
    // 
    // [4, 7]
    // m = 4
    // curr = 7 
    // max = 4 
    // => max = 7
    // --------------- 
    // [4, 7, 5]
    // m = 4 
    // curr = 7
    // max = 4
    // ------
    // m = 7
    // curr = 4 + 5 
    // max = 7
    // => max(9, 7) = 9
    // ---------------
    public static int maxNonConsecutiveSum(int[] arr){
        int max = 0;
        if(arr != null && arr.length > 0){
            int len = arr.length;
            int pmax = 0;
            max = arr[0];
            for(int i=1; i<len; i++){
                int m1 = Math.max(pmax + arr[i], arr[i]);
                int m2 = Math.max(max, arr[i]);
                pmax = max;
                max = Math.max(m1, m2);
            } 
        }
        return max;
    }
    //]

    static void test00_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 4);
        Aron.end();
    }
    static void test01_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 7);
        Aron.end();
    }
    static void test02_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 9);
        Aron.end();
    }
    static void test03_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5, 9, 1, 2, -4, 20}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 38);
        Aron.end();
    }
    static void test04_maxNonConsecutiveSum(){
        Aron.beg();
        int[] arr = {4, 7, 5, 9, 90, 100}; 
        int max = maxNonConsecutiveSum(arr);
        Test.t(max, 116);
        Aron.end();
    }
}

import java.util.*;
import java.io.*;
import classfile.*;


class Node {
    public Node left;
    public Node right;
    public Node next;
    public Character data;
    public boolean isVisited;
    public Node(Character n) {
        left = right = null;
        data = n;
        isVisited = false;
    }
}


public class NonRepeatingChar{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
    }

    static void test0(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a'}; 

        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 1;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test1(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a', 'c'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 9;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a', 'b', 'e', 'b'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 2;
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test3(){
        Aron.beg();
        Character[] arr = {'a'}; 
        int len = arr.length;
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Character value = 'a';
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    static void test4(){
        Aron.beg();
        Character[] arr = {'a', 'b', 'a'}; 
        int len = arr.length;
        Character value = 'b';
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        Character[] arr = {'a', 'a', 'a', 'b', 'a'}; 
        int len = arr.length;
        Character value = 'b';
        Character nonRepeating = nonRepeatingChar(arr, len-1);
        Print.p(nonRepeating);
        Test.t(nonRepeating, value);
        Aron.end();
    }

    //[ file=nonrepeatingchar.html title=""
    static Character nonRepeatingChar(Character[] arr, int index){
        List<Node> list =  new LinkedList<Node>();
        if(arr != null){
            Map<Character, Node> map = new HashMap<Character, Node>();

            for(int i=0; i<arr.length; i++){
                if(i <= index){
                    Character ch = arr[i];
                    if(!map.containsKey(ch)){
                        Node node = new Node(ch);
                        list.add(node);
                        map.put(ch, node);
                    }else{
                        Node vNode = map.get(ch);
                        if(vNode != null){
                            list.remove(vNode);
                            map.put(ch, null);
                        }
                    }
                }else{
                    break;
                }
            }
        }
        if(list.size() > 0)
            return list.get(0).data;
        else
            return null;
    }
    //]
} 
import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.List;

public class NumOperator{
    public static void main(String[] args) {
        System.out.println("Hello World!");
        test();
    }
    static int numOperator(int n){
        List<Integer> list = new ArrayList<Integer>();
        if(n == 0)
            list.add(0);
        else if(n > 0){
            while(n > 0){
                int r = n % 2;
                list.add(r);
                n = n/2;
            }
        }

        int sum = 0;
        for(int i=0; i<list.size(); i++){
            if(list.get(i) == 1)
                sum += i+1;
        }
        return sum;
    }
    static void test(){
        System.out.println(numOperator(5));
        System.out.println(numOperator(3));
    }
}
import java.util.*;

//Convert numerical number to English spoken words
class ConvertNumberToEnglish
{
    Map<Integer, String> map = new HashMap<Integer, String>();
    public ConvertNumberToEnglish()
    { }
    public void InitMap()
    {
        map.put(0, "[zero]");
        map.put(1, "[one]");
        map.put(2, "[two]");
        map.put(3, "[three]");
        map.put(4, "[four]");
        map.put(5, "[five]");
        map.put(6, "[six]");
        map.put(7, "[seven]");
        map.put(8, "[eight]");
        map.put(9, "[nine]");

        map.put(10, "[ten]");
        map.put(11, "[eleven]");
        map.put(12, "[twelve]");
        map.put(13, "[thirteen]");
        map.put(15, "[fifteen]");
        map.put(16, "[sixteen]");
        map.put(17, "[seventeen]");
        map.put(18, "[eighteen]");
        map.put(19, "[nineteen]");

        map.put(20, "[twenty]");
        map.put(30, "[thirty]");
        map.put(40, "[forty]");
        map.put(50, "[fifty]");
        map.put(60, "[sixty]");
        map.put(70, "[seventy]");
        map.put(80, "[eighty]");
        map.put(90, "[ninety]");

        map.put(100, "[hundred]");
        map.put(1000, "[thousand]");
        map.put(1000000, "[million]");
        map.put(1000000000, "[billion]");
    }
    public void convert(int num)
    {
        System.out.print("{"+num+"}=");
        if(num == 0)
            System.out.print(map.get(num));
        else if(num > 0)
        {
            int[][] array = table(num);
            int len = array.length;
            String s = "";
            for(int c=0; c < array.length; c++)
            {
                s = processRow(array[c], c) + s;
            }
            System.out.print(s);
        }
    }
    public int[][] table(int num)
    {
        int numRow = 0;
        if(num > 0)
            numRow = (int)(Math.log(num)/Math.log(1000)) + 1;

        int[][] array = new int[numRow][3];
        int col = 0;
        while(num > 0)
        {
           int r = num % 1000; 
           num /= 1000;
           int row = 0;
           while(r > 0)
           {
                int rr = r % 10;
                r /= 10;
                array[col][row] = rr;
                row++;
           }
           col++;
        }
        return array;
    }
    public String processRow(int[] row, int pow)
    {
        String first = "";
        String second = "";
        String third = "";
        String s ="";
        if(row[0] != 0 || row[1] != 0 || row[2] != 0)
        {
            if(row[0] > 0)
            {
                first = map.get(row[0]);
            }
            if(row[1] > 0)
            {
                second = map.get(row[1]*10);
            }
            if(row[2] > 0)
            {
                int r = row[2] % 100;
                third = map.get(r) + map.get(100);
            }
            if(pow > 0)
                s = third + second + first + map.get((int)Math.pow(1000, pow));
            else 
                s = third + second + first;
        }
        return s;
    }
}

public class NumberToWord
{
    public static void main(String[] args)
    {
        System.out.println("Convert Number to English Words");
        ConvertNumberToEnglish con = new ConvertNumberToEnglish();
        con.InitMap();
        con.convert(0);
        System.out.println();
        con.convert(123);
        System.out.println();
        con.convert(20004);
        System.out.println();
        con.convert(200005);
        System.out.println();
        con.convert(123346789);
        System.out.println();
        con.convert(987654321);
        System.out.println();
        con.convert(90000001);
        System.out.println();
        con.convert(100000000);
        System.out.println();
    }
}
import java.io.File;
import javafx.application.Application;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextAreaBuilder;
import javafx.scene.layout.VBox;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBoxBuilder;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.control.Dialog;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.event.ActionEvent;
import javafx.scene.control.Alert;
import javafx.scene.control.Alert.AlertType;
import javafx.geometry.Pos;
import javafx.geometry.Insets;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;

import classfile.*;

final class TextMap {
    String fileName;
    Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
    Map<Map<String, String>, Map<Integer, String>> revMap = new HashMap<Map<String, String>, Map<Integer, String>>();
    public TextMap() {
    }
    public TextMap(String fileName) {
        this.fileName = fileName;
    }

    // read a text file and capture all words
    // word: a-z char
    public List<String> getWords() {
        //Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-zA-Z]+(?=\\s|$)");

        List<String> wordList = new ArrayList<String>();
        List<String> list = Aron.readFile(fileName);
        for(String s : list) {
            String[] arr = s.split("\\s+");
            for(String str : arr) {
                Matcher matcher = pattern.matcher(str.toLowerCase());
                if(matcher.find()) {
                    wordList.add(matcher.group());
                }
            }
        }
        return wordList;
    }

    public Map<Map<String, String>, Map<String, Integer>> prefixSuffixMap(List<String> list) {
        Map<Map<String, String>, Map<String, Integer>> map = new HashMap<Map<String, String>, Map<String, Integer>>();
        for(int i=0; i<list.size() - 2; i++) {
            Map<String, String> key = new HashMap<String, String>();
            Map<String, Integer> value = new HashMap<String, Integer>();
            key.put(list.get(i), list.get(i+1));
            value.put(list.get(i+2), 1);

            Map<String, Integer> v = map.get(key);
            if(v == null) {
                map.put(key, value);
            } else {
                Integer n = v.get(list.get(i+2));
                if(n == null) {
                    v.put(list.get(i+2), 1);
                } else {
                    n++;
                    v.put(list.get(i+2), n);
                }
            }
        }
        return map;
    }

    // generate number [1...n]
    public int random(int n) {
        Random ran = new Random();
        int num = ran.nextInt(n) + 1;
        return num;
    }

    public List<String> generateText(int numWords, String prefix, String suffix, Map<Map<String, String>, Map<String, Integer>> map , Map<Map<String, String>, Map<Integer, String>> reverseFreMap) {

        List<String> list = new ArrayList<String>();


        // clean up prefix and suffix, e.g. trim white-space
        String[] arr = prefix.split("\\s+");
        List<String> inputList = new ArrayList<String>();
        for(String s : arr) {
            if(s.trim().length() > 0)
                inputList.add(s);
        }

        String inputSuffix = suffix.trim();
        if(inputList.size() == 2) {
            String firstPrefix = inputList.get(0);
            String secondPrefix = inputList.get(1);
            list.add(firstPrefix);
            list.add(secondPrefix);
            list.add(inputSuffix);

            Print.pbl("firstPrefix =" + firstPrefix);
            Print.pbl("secondPrefix=" + secondPrefix);
            Print.pbl("inputSuffix=" + inputSuffix);

            firstPrefix = secondPrefix;
            secondPrefix = inputSuffix;
              while(true){
                Map<String, String> key = new  HashMap<String, String>();
                key.put(firstPrefix, secondPrefix);

                Map<String, Integer> value = map.get(key);

                if(value != null) {
                    Map<Integer, String> revValueMap = reverseFreMap.get(key);
                    if(revValueMap != null) {

                        int ranKey = random(revValueMap.size());

                        String newSuffix = revValueMap.get(ranKey);
                        Print.pbl("newSuffix=" + newSuffix + " " + "ranKey=" + ranKey);
                        firstPrefix = secondPrefix;
                        secondPrefix= newSuffix;
                        list.add(newSuffix);

                        if(list.size() >= numWords){
                            break;
                        }
                    }
                }else{
                    break;
                }
            }
        }
        return list;
    }
    public Map<Map<String, String>, Map<Integer, String>>  reverseFrequencyMap(Map<Map<String, String>, Map<String, Integer>> map) {

        Map<Map<String, String>, Map<Integer, String>> tableMap = new HashMap<Map<String, String>, Map<Integer, String>>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");

                Map<Integer, String> rmap = inverseMap(value);
                tableMap.put(key, rmap);

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "->" + valueEntry.getValue());
                }

                Ut.l();
                for(Map.Entry<Integer, String> revEntry: rmap.entrySet()) {
                    Print.pb(revEntry.getKey() + "->" + revEntry.getValue());
                }
                Print.pbl("size=" + rmap.size());
                Print.pp("\n");
            }
            Ut.l();
        }
        return tableMap;
    }

    public List<String> textGeneMap() {

        List<String> list = getWords();
        map = prefixSuffixMap(list);

        List<String> retList = new ArrayList<String>();
        for(Map.Entry<Map<String, String>, Map<String, Integer>> entry : map.entrySet()) {
            Map<String, String> key = entry.getKey();
            Map<String, Integer> value = entry.getValue();
            String str = "";
            for(Map.Entry<String, String> keyEntry : key.entrySet()) {
                Print.pp(keyEntry.getKey() + " " + keyEntry.getValue() + "=>");
                str += keyEntry.getKey() + " " + keyEntry.getValue() + " => ";

                for(Map.Entry<String, Integer> valueEntry: value.entrySet()) {
                    Print.pb(valueEntry.getKey() + "[" + valueEntry.getValue() + "]");
                    str += valueEntry.getKey()  + "[" + valueEntry.getValue() + "] ";
                }
                Ut.l();
                str += "\n";
                Print.pp("\n");
            }
            retList.add(str);
            Ut.l();
        }
        return retList;
    }

    public List<String> processFile(int maxWords, String prefix, String suffix) {
        Aron.beg();

        revMap = reverseFrequencyMap(map);
        List<String> listWords= generateText(maxWords, prefix, suffix, map, revMap);
        return listWords;
    }

    // return investable map: <k, v> => <v, k>
    // v = 1, 2, ... , n
    public Map<Integer, String> inverseMap(Map<String, Integer> map) {

        Map<Integer, String> rMap = new HashMap<Integer, String>();
        int k = 1;
        for(Map.Entry<String, Integer> entry : map.entrySet()) {
            Integer n = entry.getValue();

            Print.pbl(entry.getKey() + "->" + entry.getValue());
            int init = k;
            while(k < init + n) {
                rMap.put(k, entry.getKey());
                k++;
            }
        }
        return rMap;
    }
}

public class OpenFileFX extends Application {
    String fileName = null;
    TextMap textMap = new TextMap();
    final int numCharLine = 10;
    public static void main(String[] args) {
        launch(args);
    }

    public boolean isNumeric(String str) {
        return str.matches("[1-9][0-9]*|0");
    }
    @Override
    public void start(final Stage primaryStage) {
        Group root = new Group();

        Alert alert = new Alert(AlertType.INFORMATION);
        alert.setTitle("Error");


        TextArea textArea = new TextArea();
        TextArea textTable = new TextArea();
        textArea.setMinSize(500,500);
        textTable.setMinSize(500,500);

        TextField selectedFileTF = new TextField();
        selectedFileTF.setEditable(false);
        selectedFileTF.setPrefWidth(200);
        Button buttonLoad = new Button("Select File");
        Button buttonGeneText= new Button("Generate Text");

        HBox hboxField = new HBox();
        hboxField.setAlignment(Pos.CENTER);
        hboxField.setPadding(new Insets(1, 1, 1, 1));
        hboxField.getChildren().add(textTable);
        hboxField.getChildren().add(textArea);

        VBox box = new VBox();
        box.setAlignment(Pos.TOP_CENTER);
        box.setSpacing(5);
        box.getChildren().add(hboxField);

        HBox hboxTextField1 = new HBox();
        HBox hboxtextField2 = new HBox();
        hboxTextField1.setAlignment(Pos.CENTER);
        hboxTextField1.setSpacing(20);

        Label prefixLable = new Label("Prefix:");
        Label suffixLable = new Label("Suffix:");
        Label maxWordsLable = new Label("Maximum Words:");

        TextField prefixTF = new TextField ();
        TextField suffixTF = new TextField ();
        TextField maxWordsTF = new TextField ();


        buttonLoad.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                FileChooser fileChooser = new FileChooser();
                FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("TXT files (*.txt)", "*.txt");
                fileChooser.getExtensionFilters().add(extFilter);

                File file = fileChooser.showOpenDialog(primaryStage);

                Print.pbl("file =" + file);
                if(file != null) {
                    fileName = file.getAbsolutePath();

                    if(fileName != null) {
                        textMap = new TextMap(fileName);
                        selectedFileTF.setText(file.getName());

                        List<String> textList = textMap.textGeneMap();
                        textTable.clear();
                        for(String s : textList) {
                            Print.pbl("s=" + s);
                            textTable.appendText(s + " ");
                        }
                    }
                } 
            }
        });

        buttonGeneText.setOnAction(new EventHandler<ActionEvent>() {
            @Override
            public void handle(ActionEvent arg0) {
                Aron.beg();

                if(fileName != null) {
                    List<String> list = Aron.getWords(fileName);
                    Aron.printList(list);

                    if(prefixTF.getText().length() > 0 && prefixTF.getText().length() > 0) {
                        Print.pbl("prefixTF=" + prefixTF.getText());
                        Print.pbl("suffixTF=" + suffixTF.getText());
                        Print.pbl("maxWordsLable=" + maxWordsLable.getText());

                        if(isNumeric(maxWordsTF.getText().trim())) {
                            Integer maxWords = Integer.valueOf(maxWordsTF.getText().trim());
                            Print.pbl("maxWords=" + maxWords);
                            List<String> wlist = textMap.processFile(maxWords, prefixTF.getText(), suffixTF.getText());

                            textArea.clear();

                            int count = 0;
                            for(String s : wlist) {
                                Print.pbl("s=" + s);
                                if((count % numCharLine)  + 1 == numCharLine)
                                    textArea.appendText(s + "\n");
                                else
                                    textArea.appendText(s + " ");

                                count++;
                            }

                        } else {
                            alert.setHeaderText("Maximum Words: invalid input");
                            alert.setContentText("Maximum Words field must be an integer.");
                            alert.showAndWait();
                        }

                    }else{
                        alert.setHeaderText("Invalid Prefix or Suffix");
                        alert.setContentText("Prefix must be two words\n Suffix must be one word");
                        alert.showAndWait();
                    }
                }else{
                    alert.setHeaderText("Invalid file");
                    alert.setContentText("Please select a valid text file.");
                    alert.showAndWait();
                }

            }
        });

        HBox lbtTFBox1 = new HBox();
        HBox lbtTFBox2 = new HBox();
        HBox lbtTFBox3 = new HBox();

        lbtTFBox1.getChildren().addAll(prefixLable, prefixTF);
        lbtTFBox1.setSpacing(2);
        lbtTFBox1.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox1.setStyle("-fx-background-color: #EEEEEE;");


        lbtTFBox2.getChildren().addAll(suffixLable, suffixTF);
        lbtTFBox2.setSpacing(2);
        lbtTFBox2.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox2.setStyle("-fx-background-color: #EEEEEE;");

        lbtTFBox3.getChildren().addAll(maxWordsLable, maxWordsTF);
        lbtTFBox3.setSpacing(2);
        lbtTFBox3.setPadding(new Insets(1, 1, 1, 1));
        lbtTFBox3.setStyle("-fx-background-color: #EEEEEE;");

        hboxTextField1.getChildren().addAll(lbtTFBox1);
        hboxTextField1.getChildren().addAll(lbtTFBox2);
        hboxTextField1.getChildren().addAll(lbtTFBox3);

        box.getChildren().addAll(hboxTextField1);

        HBox fileBox = new HBox();
        fileBox.setAlignment(Pos.CENTER);
        fileBox.setSpacing(2);
        fileBox.getChildren().addAll(buttonLoad, selectedFileTF);
        box.getChildren().add(fileBox);

        box.getChildren().add(buttonGeneText);
        primaryStage.setScene(new Scene(box, 800, 600));
        primaryStage.show();
    }
}
import java.util.*;
import java.io.*;
import classfile.*;
import org.apache.commons.lang3.StringUtils;

// padding example 
// use apache common lib
// jar file /Users/cat/myfile/github/JavaLib/commons-lang3-3.5.jar
public class PaddingExample{
    public static void main(String[] args) {
        String s1 = StringUtils.leftPad("reccoon", 10, '-');
        Print.pbl(s1);
        String s2 = StringUtils.leftPad("bat", 5, '=');
        Print.pbl(s2);
    }
}

public class PalindromeSpace
{
    public static void main(String[] args)
    {
        System.out.println("Palindrome With Space");
        
        boolean ret0 = isPalindrome(null);
        boolean ret1 = isPalindrome("");
        boolean ret2 = isPalindrome(" ");
        boolean ret3 = isPalindrome(" a");
        boolean ret4 = isPalindrome("a ");
        boolean ret5 = isPalindrome("ab");
        boolean ret6 = isPalindrome("aa");
        boolean ret7 = isPalindrome("a a");
        boolean ret8 = isPalindrome("a b");
        boolean ret9 = isPalindrome("a b ba");
        System.out.println("[null]["+ret0+"] []["+ret1+"] [ ]["+ret2+"] [ a]["+ret3+"] [a ]["+ret4+"] [ab]["+ret5+"] [aa]["+ret6+"] [a a]["+ret7+"] [a b]["+ret8+"] [a b ba]["+ret9+"]");
    }
    public static boolean isPalindrome2(String str) 
    {
        if( str != null)
        {
            int len = str.length();
            int i=0;
            for(i=0; i<len && str.charAt(i) != str(len-1-i); i++);
            return i == len;
        }
    }
    public static boolean isPalindrome(String str)
    {
        boolean ret = true;
        boolean done = false;
        if(str != null && str.length() > 1)
        {
            int len = str.length();
            int i = 0; 
            int j = len - 1;
            while(!done && ret)
            {
                if(str.charAt(i) == str.charAt(j)) 
                {
                    if(i == j || i == j - 1)
                        done = true;
                    else
                    {
                        if(i < len - 1)
                            i++;
                        if(j > 0)
                            j--;
                    }
                }
                else
                {
                    if(str.charAt(i) == ' ')
                    {
                        if(i < len - 1)
                            i++;
                    }
                    else if(str.charAt(j) == ' ') 
                    {
                        if(j > 0)
                            j--;
                    }
                    else
                    {
                        ret = false;
                    }
                }
            }
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import java.util.stream.*;
import classfile.*;

enum Type{
    OPEN,
    CLOSE,
    ITEM,
    NONE
}

public class ParseBracketTree{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    public static void test0(){
        Aron.beg();

        String str = "[ 1 ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        Aron.printList(list);

        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test2(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" [ 14 ]"
                    +"  [ 111 "
                         +" [ 112 ]"
                         +" [ 113 ]"
                    +"  ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        Iterator<String> ite = list.iterator(); 
        Node root = buildTree(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test3(){
        Aron.beg();
        String str = "[ 1 ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        List<String> list2 = new ArrayList<String>(); 

        for(String s : list){
            if(getTokenType(s) != Type.OPEN)
                list2.add(s);
        }
        
        Iterator<String> ite = list2.iterator(); 
        Node root = buildTreeRecursion(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static void test4(){
        Aron.beg();
        String str = "[ 1"
                    +" [ 12 ]"
                    +" [ 13 ]"
                    +" [ 14 ]"
                    +"  [ 111 "
                         +" [ 112 ]"
                         +" [ 113 ]"
                    +"  ]"
                    +" ]";
        String[] arr = str.split("\\s+");
        List<String> list = Arrays.asList(arr);
        List<String> list2 = new ArrayList<String>(); 

        for(String s : list){
            if(getTokenType(s) != Type.OPEN)
                list2.add(s);
        }

        Aron.printList(list2, "(");
        
        Iterator<String> ite = list2.iterator(); 
        Node root = buildTreeRecursion(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);
        Aron.preorderGraph(root);
        Aron.printList(list, "(");
         
        Aron.end();
    }
    public static boolean validate(String fname){
        try{
            BufferedReader br = new BufferedReader(new FileReader(fname));
            String line = null;
            while( (line = br.readLine()) != null){
                Print.pbl(line);
            }
        }
        catch(IOException e){
            e.printStackTrace();
        }
        return true;
    }

    public static Node buildTree(Iterator<String> ite){
        Stack<Node> stack = new Stack<>();

        while(ite.hasNext()){
            String item = ite.next();
            if(getTokenType(item) == Type.ITEM){
                stack.push(new Node(item));
            }else if(getTokenType(item) == Type.CLOSE){
                if(stack.size() > 1){
                    Node node = stack.pop();
                    stack.peek().list.add(node);
                }
            }
        }
        return stack.peek();
    }
    public static Node buildTreeRecursion(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String item = ite.next();
            if(getTokenType(item) == Type.ITEM){
                root = buildTreeRecursion(ite);
            }else if(getTokenType(item) == Type.CLOSE){
                Node ret = buildTreeRecursion(ite);     
            }
        }
        return root;
    }

    public static Type getTokenType(String str){
        Pattern r = Pattern.compile("\\d+");
        if(str.equals("[")){
            return Type.OPEN;
        }else if(str.equals("]")){
            return Type.CLOSE;
        }else if(r.matcher(str).find()){
            return Type.ITEM;
        }
        return Type.NONE;
    }
    
    static void test9(){
        Aron.beg();
        Type type1 = getTokenType("[");
        Type type2 = getTokenType("]");
        Type type3 = getTokenType("123");
        Print.pbl(type1);
        Print.pbl(type2);
        Print.pbl(type3);
        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Partition 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
		int[] Arr = {1, 7};
		int left = 0;
		int right = Arr.length - 1;
		int piv = partition(Arr, left, right);
		System.out.println("piv=" + piv);
	}
	public static int partition(int[] Arr, int left, int right)
	{
		int ret = -1;
		if(Arr != null)
		{
			int len = Arr.length;
			if(len == 1)
				ret = 0;
			else if(len > 1)
			{
				int i=left;
				int j=len - 1;
				int pivot = Arr[left];
				while(i<j)
				{
					while(Arr[i] <= pivot && i < len-1) i++;
					while(Arr[j] > pivot && j > 0) j--;
					if(i < j)
					{
						int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;

				for(int k=0; k<len; k++)
				{
					System.out.println("Arr[" + k + "]=" + Arr[k]);
				}

			}
		}
		return ret;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

public class PartitionArray{
    public static void main(String[] args) {
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    
    static void test3(){
        Aron.beg();
        Integer[] arr = {2, 0, 3, 0};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    } 
    static void test4(){
        Aron.beg();
        Integer[] arr = {2, 0, 3};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    }
    static void test5(){
        Aron.beg();
        Integer[] arr = {0, 0, 2, 0, 0, 3, 2, 0, 3};
        partition(arr);
        Aron.printArray(arr);
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        Integer[] arr = {0, 0, 0, 0, 0};
        Aron.printArray(arr);
        Aron.end();
    } 
    static void test7(){
        Aron.beg();
        Integer[] arr = {2, 3};
        Aron.printArray(arr);
        Aron.end();
    } 

    //[ file=partitionarray.html title=""
    static void partition(Integer[] arr){
        if(arr != null){
            int len = arr.length;
            int nonzero = len-1;
            for(int i=len-1; i >= 0; i--){
                if(arr[i] == 0){
                    int tmp = arr[i];
                    arr[i] = arr[nonzero];
                    arr[nonzero] = tmp;
                    nonzero--;
                }
            }
        }
    }
    //]
}
import java.util.*;
import java.io.*;
import classfile.*;

public class PartitionFB{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
    }
    public static void test0() {
        Aron.beg();

        Integer[] arr = {0, 2}; 
        Integer[] expectedArray = {2, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test1() {
        Aron.beg();

        Integer[] arr = {0}; 
        Integer[] expectedArray = {0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test2() {
        Aron.beg();

        Integer[] arr = {1}; 
        Integer[] expectedArray = {1}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test3() {
        Aron.beg();

        Integer[] arr = {1, 0}; 
        Integer[] expectedArray = {1, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void test4() {
        Aron.beg();

        Integer[] arr = {0, 2, 0, 3, 0}; 
        Integer[] expectedArray = {2, 3, 0, 0, 0}; 
        partition(arr);
        Aron.printArray(arr);
        Test.t(arr, expectedArray);

        Aron.end();
    }
    public static void swap(Integer[] arr, int i, int j){
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    //[ file=part3.html title=""
    // move all zeros to the right side of array
    // [1, 0, 3, 0] => [1, 3, 0, 0]
    public static void partition(Integer[] arr){
        if(arr != null){
            int zeroIndex = 0;
            int len = arr.length;
            for(int i=0; i<len; i++){
                if(arr[i].intValue() > 0){
                    if(i != zeroIndex)
                        swap(arr, i, zeroIndex);
                    // make sure the zeroIndex is not out of bounds
                    if(zeroIndex < len-1)
                        zeroIndex++;
                }
            }
        }
    }
    //]
}

import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public Node getRoot()
	{ return root;}
}

//Find the node from the Binary Tree and return the path from the current node
//to root
//The algorithm is similar to isBST() and use inorder traveral to walk through
//all the nodes, once the node is found, then recursion is terminated 
class PathToKBinarySearch 
{

	public static void main(String args[])
	{
		BST b1 = new BST();
		b1.Insert(10);
		b1.Insert(5);
		b1.Insert(15);
        
		b1.Insert(17);
		b1.Insert(199);
		b1.Insert(16);
        
        Node[] first = new Node[1];
        Node[] second = new Node[1];
        first[0] = null;
        second[0] = null;
        //swap(5, 15, b1.getRoot(), first, second);
        
        inorder(b1.getRoot());
		
        System.out.println("");
        PathToK(b1.getRoot(), 199);
	}
    public static void swap(int m, int n, Node root, Node[] first, Node[] second)
    {
        if(root != null)
        {
            swap(m, n, root.left, first, second);
            if(root.data == m)
            {
                first[0] = root;
            }
            else if(root.data == n)
            {
                second[0] = root;
            }
            if( first[0] != null && second[0] != null)
            {
                int tmp = first[0].data;
                first[0].data = second[0].data;
                second[0].data = tmp;
                first[0] = null;
                second[0] = null;
            }
            swap(m, n, root.right, first, second);
        }
    }

    public static void inorder(Node node)
    {
        if(node != null)
        {
            inorder(node.left);
		        System.out.println(node.data);
            inorder(node.right);
        }
    }

    public static boolean PathToK(Node node, int k)
    {
        if(node != null)
        {
            if(PathToK(node.left, k))
            {
		        System.out.println(node.data);
                return true;
            }
            if(node.data == k)
            {
		        System.out.println(node.data);
                return true;
            }
            if(PathToK(node.right, k))
            {
		        System.out.println(node.data);
                return true;
            }
        }
        return false;
    }
}
public class PatternMatch 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
    }
    //"ab?"
    //Generate table for "ab?" pattern
    public static boolean match(String pattern, String str)
    {
        Map<Integer, Map<String, Integer>> map = new HashMap<Integer, Map<String, Character>>();

        /*
        for(int i=0; i<pattern.length(); i++)
        {
            char currChar = pattern.charAt(i);
            char nextChar = '0';
            if(i+1 < pattern.length())
                char nextch = pattern.charAt(i+1);
            //if(nextChar == '?')
            //else


        }
        */
    }
}
import java.io.*;
import java.lang.String;
import classfile.*; 

class PermRecursive {
    public static void main(String args[]) {
        test0_permutation();
        test1_permutation();
        test2_permutation();
        test0_permutationPrefix();
        test1_permutationPrefix();
        test2_permutationPrefix();
        test3_permutationPrefix();
        //test1();
        //test2();
    }
    
    static void test0_permutation(){
        Aron.beg();
        char[] charArr= {'a'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test1_permutation(){
        Aron.beg();
        char[] charArr= {'a', 'b'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test2_permutation(){
        Aron.beg();
        char[] charArr= {'a', 'b', 'c'};
        int index = 0;
        permutation(charArr, index);
        Aron.end();
    }
    static void test0_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test1_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "a";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test2_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "ab";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    static void test3_permutationPrefix(){
        Aron.beg();
        String prefix = "";
        String str = "abc";
        permutationPrefix(prefix, str);
        Aron.end();
    }
    public static void test1() {
        char[] charArr= {'a', 'b', 'c'};
        int[] arr = {100};
        int inx = 0;

        System.out.println("digraph G {\n");
        permu_Graph(charArr, inx, arr);
        System.out.println("}\n");
    }
    public static void test2() {
        // Print the content on the console
        //System.out.println ("cool");
        int inx=0;
        char[] charArr= {'a', 'b', 'c'};
        //char[] charArr={};
        //permu(charArr, inx);
        //String s = removeChar("abcde", 2);
        //System.out.println ("s=" + s);

        int[][] array = { {1, 2, 3},
            {4, 5, 6},
            {7, 8, 9}
        };
        int col = 0;
        printUpperTriangle(array, col);
    }

    public static void permu(char[] charArr, int inx) {
        if( charArr != null) {
            if(charArr.length == inx) {
                for(int i=0; i<charArr.length; i++)
                    System.out.print(charArr[i]+" ");
                System.out.println();
            } else
                for(int i=inx; i<charArr.length; i++) {
                    char tmp = charArr[i];

//                    charArr[i] = charArr[inx];
//                    charArr[inx] = tmp;
//                    permu(charArr, inx+1);
                    Aron.swap(charArr, i, inx);

                    tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;
                }
        }
    }

    public static void permu_Graph(char[] charArr, int inx, int[] arr) {
        if( charArr != null) {
            if(charArr.length == inx) {
                for(int i=0; i<charArr.length; i++)
                    System.out.print(charArr[i]+" ");
                System.out.println();
            } else {
                for(int i=inx; i<charArr.length; i++) {
                    char tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;

                    permu_Graph(charArr, inx+1, arr);

                    tmp = charArr[i];
                    charArr[i] = charArr[inx];
                    charArr[inx] = tmp;
                }
            }
        }
    }
    public static void printUpperTriangle(int[][] array, int col) {
        for(int row=col; row<array.length; row++) {
            printUpperTriangle(array, col+1);
            System.out.println("[" + col + "][" + row+ "]=" + array[col][row]);
        }
    }

    //[ file=permuteJava.html title=" Generate permutation for n characters"
    // generate all permutation from given char[], e.g. ['a', 'b']
    //
    public static void permutation(char[] arr, int index){
        if(index == arr.length){
            Aron.printArray(arr);
        }else{
            if(arr != null){
                int len = arr.length;
                for(int i=index; i<len; i++){
                    Aron.swap(arr, i, index);
                    permutation(arr, index + 1);
                    Aron.swap(arr, i, index);
                } 
            }
        }
    }
    //]

    
    //[ file=permutationprefix.html title=" Generate all permutation in sorted order"
    // permutations are in sorted ordering in lexicographically
    public static void permutationPrefix(String prefix, String str){
        if(str != null){
            if(str.length() == 0){
                Print.p(prefix);
            }else{
                int len = str.length();
                for(int i=0; i<len; i++){
                    String s = str.charAt(i) + "";
                    permutationPrefix(prefix + s, remove(str, i));
                } 
            }
        }
    }
    public static String remove(String str, int index){
        String s = "";
        for(int i=0; i<str.length(); i++){
            if(i != index)
                s += str.charAt(i) + "";
        } 
        return s;
    }
    //]
}
import java.util.*;
public class PermRepeated 
{
    public static void main(String[] args)
    {
        System.out.println("Print all permuation character with repeating character!");
        String s = "ABC";
        char[] array = new char[s.length()];
        int depth = 0;
        Set<Character> map = new LinkedHashSet<Character>();
        //permRepeated(s, array, depth);
        //perm(s, array, depth, map);

        int k=2;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i);

        test1();
    }

    public static void ExcelSheetRowNumber(String s)
    {
        char[] array = new char[s.length()];
        int depth = 0;
        for(int i=1; i<=s.length(); i++)
            permRepeatedChooseK(s, array, depth, i);
    }


    //Given string character array and integer k,
    //print all permutation with repeatation string length k 
    public static void permRepeatedChooseK(String s, char[] array, int depth, int k)
    {
        if(depth == k)
        {
            for(int i=0; i<depth; i++)
            {
                System.out.print("["+array[i]+"]");
            }
            System.out.println();
        }
        else 
        {
            if(array != null && s != null)
            {
                for(int i=0; i<s.length(); i++)
                {
                    array[depth] = s.charAt(i);
                    permRepeatedChooseK(s, array, depth+1, k);
                }
            }
        }
    }

    public static void permRepeated(String s, char[] array, int depth)
    {
        if(s != null)
        {
            if(s.length() == depth)
            {
                for(int i=0; i<depth; i++)
                {
                    System.out.print("["+array[i]+"]");
                }
                System.out.println();
            }
            else
            {
                for(int i=0; i<s.length(); i++)
                {
                    array[depth] = s.charAt(i);
                    permRepeated(s, array, depth+1);
                }
            }
        }
    }
    public static void permRepeatingChar(Character[] array, int depth, Set<String> set)
    {
        if(depth == array.length)
        {
            String s="";
            for(Character ch:array)
                s += ch.toString();

            if(!set.contains(s))
                set.add(s);
        }
        else
        {
            for(int i=depth; i<array.length; i++)
            {
                Aron.swap(array, i, depth);
                permRepeatingChar(array, depth+1, set);
                Aron.swap(array, i, depth);
            }
        }
    }
    public static void perm(String s, char[] array, int depth, Set<Character> map)
    {
        if(s != null)
        {
            if(s.length() == depth)
            {
                for(Character ch: map)
                    System.out.print(ch);
                System.out.println();
            }
            else
            {
                for(int i=0; i<s.length(); i++)
                {
                    Character ch = new Character(s.charAt(i));
                    if(!map.contains(ch))
                    {        
                        map.add(ch);
                        perm(s, array, depth+1, map);
                        map.remove(ch);
                    }
                } 
            }
        }
    }
    public static void test1()
    {
        Character[] array = {'a', 'b', 'b'};
        int depth = 0;
        Set<String> set = new LinkedHashSet<String>();
        permRepeatingChar(array, depth, set);
        for(String item: set)
            System.out.println(item);
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class Permu2
{
	public static void main(String args[])
	{
		per("abcd");
	}
	public static void per(String str)
	{
		Vector<String> vet = new Vector<String>();
		if(str != null)
		{
			int len = str.length();
			if(len > 0)
			{
				vet.add(str.charAt(0) + "");
				Vector<String> vet2 = new Vector<String>();
				for(int j = 1; j < len; j++)
				{
					for(int i = 0; i < vet.size(); i++)
					{
						Vector<String> vet1 = new Vector<String>();
						vet1 = Combin2(vet.get(i), str.charAt(j) + "");	

						for(int k=0; k<vet1.size(); k++)
							vet2.add(vet1.get(k));
					}	
					vet.clear();

					for(int x=0; x<vet2.size(); x++)
						vet.add(vet2.get(x));
					vet2.clear();

				}
				for(int i = 0; i < vet.size(); i++)
				{
					System.out.println(vet.get(i));
				}
			}
		}	
	}

	public static Vector<String>  Combin2(String str, String ch)
	{
		Vector<String> vet = new Vector<String>();
		for(int i = 0; i < str.length() + 1; i++)
		{
			StringBuffer sb = new StringBuffer(str);
			sb.insert(i, ch);
			vet.add(sb.toString());
		}
		return vet;
	}
	public static Vector<String>  Combin(String str, String ch)
	{
		Vector<String> vet = new Vector<String>();
		int i = 0;
		for(i = 0; i < str.length() + 1; i++)
		{
			String s = "";
			for(int j = 0; j < str.length(); j++)
			{
				if(i == j)
					s = s + ch; 
				s = s + str.charAt(j);
			}	
			if(i == str.length())
				s = s+ch;
			System.out.println (s);
		}
		return vet;
	}
}
import java.io.*;
import java.util.*;

//a1b -> a1b, A1b, a1B, A1B
//permut upper and lower cases

class PermuBin
{
	public static void main(String args[])
	{
		System.out.println("cool");
		Vector<String> v = perm("1");
		for(int i=0; i<v.size(); i++)
			System.out.println(v.get(i));
	}
	public static Vector<String> perm(String str)
	{ Vector<String> v = new Vector<String>();
		Vector<String> vet = new Vector<String>();
		v.add("$");
		if( str != null && str.length() > 0)
		{ 
			for(int j=0; j<str.length(); j++)
			{
				char ch = str.charAt(j);
				for(int i=0; i<v.size(); i++)
				{ String s="";
					if('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z')			
					{ if(j != 0 || i != 0)
						{
							s = v.get(i) + Character.toUpperCase(ch); 
							vet.add(s);
							s = v.get(i) + Character.toLowerCase(ch); 
							vet.add(s);
						}
						else
						{ 
							vet.add(Character.toUpperCase(ch)+"");
							vet.add(Character.toLowerCase(ch)+"");
						}
					}
					else
					{ if(j != 0 || i != 0)
						{ s = v.get(i) + ch; 
							vet.add(s);
						}
						else
						{ s = ch + ""; 
							vet.add(s);
						}
					}
				}
				v.clear();
				for(int i=0; i<vet.size(); i++)
					v.add(vet.get(i));
				vet.clear();
			}
		}
		return v;
	}
}
public class PermutationPrefix {
    public static void main(String[] args) {
        permute("", "abc");
    }
    public static void permute(String prefix, String s) {
        if(s.length() == 0)
            System.out.println(prefix);
        else {
            for(int i=0; i< s.length(); i++) {
                permute(prefix + (s.charAt(i) + ""), remove(s, i));
            }
        }
    }
    public static String remove(String s, int index) {
        String ret = "";
        for(int i=0; i<s.length(); i++) {
            if(i != index)
                ret += s.charAt(i) + "";
        }
        return ret;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class Pi{
    public static void main(String[] args) {
        test0();
        test1();
    }

    public static double calculatePI(int nStep){
       double pi = 1.0;
       for(int i=1; i<nStep; i++){
           if(i % 2 == 1)
               pi += (double)-1/(2*i + 1);
           else
               pi += (double)1/(2*i + 1);
       } 
       Print.pbl(4*pi);
       return 4*pi;
    }
    public static void test0(){
        Aron.beg();
        int nStep = 1000;
        calculatePI(nStep);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

import java.util.*;
import java.io.*;
import classfile.*;

public class Pill{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();
        int x = 4;
        int y = 5;
        pill(x, y);
        Aron.end();
    }
    static void pill(int x, int y){
        if(x > 0 && y > 0){
            System.out.println("[" + x + " " + (y-1) + "]"); 
            pill(x, y-1);
            System.out.println("[" + (x-1) + " " + y + "]"); 
            pill(x-1, y);
        }
    }
} 
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class PreOrderToTree 
{
	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();
		
		b1.Insert(15);
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		/*
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		*/

		Node r = b1.getRoot();
		//PreOrder(r);

		int[] Arr = {10, 1, 12};
		ArrayList<Integer> leftArr = new ArrayList<Integer>();
		ArrayList<Integer> rightArr = new ArrayList<Integer>();

		//splitInOrder(Arr, leftArr, rightArr);

		Node myroot= PreOrderToTree(Arr);
		PreOrder(myroot);
	}
	
	public static Node PreOrderToTree(int[] Arr)
	{
		ArrayList<Integer> leftList = new ArrayList<Integer>();
		ArrayList<Integer> rightList = new ArrayList<Integer>();
		Node root=null;
		if(Arr != null && Arr.length > 0)
		{
			root = new Node(splitInOrder(Arr, leftList, rightList));

			int[] leftArr = new int[leftList.size()];
			int[] rightArr = new int[rightList.size()];
			for(int i=0; i<leftList.size(); i++)
				leftArr[i] = leftList.get(i);

			for(int i=0; i<rightList.size(); i++)
				rightArr[i] = rightList.get(rightList.size()-1 - i); //keep the order: [root] [ left subtree] [ right subtree]

			root.left = PreOrderToTree(leftArr);	
			root.right = PreOrderToTree(rightArr);
		}
		return root;
	}
	public static int splitInOrder(int[] Arr, ArrayList<Integer> leftList, ArrayList<Integer> rightList)
	{
		int rootNum=0;
		if( Arr != null && Arr.length > 0 && leftList != null && rightList != null)
		{
			int len = Arr.length;
			rootNum = Arr[0];

			if( len > 1)
			{
				int i=1;
				int j=len-1;

				int nl = 0, nr = 0;
				while(i <= j)
				{
					while(i < len && rootNum > Arr[i]) 
						leftList.add(Arr[i++]); 

					while(j > 0 && rootNum < Arr[j])
						rightList.add(Arr[j--]);
				}
				
				for(i=0; i<leftList.size(); i++)
				{ System.out.println(leftList.get(i)); }

				System.out.println(); 
				for(i=0; i<rightList.size(); i++)
				{ System.out.println(rightList.get(i)); }
			}
		}
		return rootNum;
	}
	public static void PreOrder(Node root)
	{
		if(root != null)
		{
			System.out.println("pre=" + root.data);
			PreOrder(root.left);
			PreOrder(root.right);
		}
	}
}
import java.io.IOException;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.StringTokenizer;
import java.util.*;

import classfile.*;

           
//         4
//      2     5
//    1   3
//    pre [4 2 1 3 5]
//    post[1 3 2 5 4]
//
//[test0]
//--------------------------------------------------------------------------
//[4][2][1][3][5]
//--------------------------------------------------------------------------
//[1][3][2][5][4]
//--------------------------------------------------------------------------
//----------------------------------------------------------------------------------------
public class PrePostTree{
    public static void main(String[] args) {
        test0();
    }
    static void test0(){
        Aron.beg();
        List<Integer> preList = Arrays.asList(4, 2, 1, 3, 5);
        List<Integer> postList = Arrays.asList(1, 3, 2, 5, 4);

        Node r = buildTreePrePost(preList, postList);
        Aron.preorder(r);
        Ut.l();
        Aron.postorder(r);
        Ut.l();
        Aron.end();
    }

//pre order [r][left][right]
//post order[left][right][r]

// [1, 2, 3, 4]
    public static Node buildTreePrePost(List<Integer> preList, List<Integer> postList) {
        Node parent = null;
        if(preList != null || postList != null) {
            if(preList.size() == postList.size() && preList.size() > 0) {
                parent = new Node(preList.get(0));
                List<Integer> subPreList = preList.subList(1, preList.size());
                List<Integer> subPostList = postList.subList(0, postList.size()-1);
                if(subPreList.size() == subPostList.size() && subPreList.size() > 0) {
                    Integer subRoot = subPreList.get(0);
                    List<Integer> leftPostList  = postLeft(subPostList, subRoot);
                    List<Integer> rightPostList = postRight(subPostList, subRoot);
                    List<Integer> leftPreList   = preLeft(subPreList, rightPostList);
                    List<Integer> rightPreList  = preRight(subPreList, leftPostList);
                    parent.left = buildTreePrePost(leftPreList, leftPostList);
                    parent.right = buildTreePrePost(rightPostList, rightPostList);
                }
            }
        }
        return parent;
    }
    public static List<Integer> preRight(List<Integer> list, List<Integer> leftList) {
        List<Integer> rightList = new ArrayList<Integer>(); 
        Set<Integer> set = new HashSet<Integer>(leftList);
        for(Integer n: list){
            if(!set.contains(n)){
                rightList.add(n);
            }
        }
        return rightList;
    }
    public static List<Integer> preLeft(List<Integer> list, List<Integer> rightList) {
        List<Integer> leftList = new ArrayList<Integer>(); 
        Set<Integer> set = new HashSet<Integer>(rightList);
        for(Integer n: list){
            if(!set.contains(n)){
                leftList.add(n);
            }
        }
        return leftList;
    }

    public static List<Integer> postRight(List<Integer> list, Integer r) {
        List<Integer> rightList = new ArrayList<Integer>(); 
        boolean equal = false;
        for(Integer n : list) {
            if(equal)
                rightList.add(n);

            if(n.intValue() == r.intValue())
                equal = true;
        }
        return rightList;
    }
    public static List<Integer> postLeft(List<Integer> list, Integer r) {
        List<Integer> leftList = new ArrayList<Integer>(); 
        for(Integer n : list) {
            if(n.intValue() != r.intValue())
                leftList.add(n);
        }
        return leftList;
    }
}


import java.util.*;

class Node {
    Node next;
    String key;
    String word;
    public Node(String key, String word) {
        this.key = key;
        this.word = word;
    }
}

public class PrefixMap {
    public static void main(String[] args) {
        test1();
        test2();
    }
    public static void test1() {
        String s = "abc";
        for(int i=0; i<s.length(); i++) {
            String str = s.substring(0, i+1);
            System.out.println("str="+str);
        }
    }
    public static void test2() {
        String str = "My dog is god and done what the hell is going on yep this sucks what the hell is going on yep this sucks";
        String[] array = str.split(" ");
        List<String> list = Arrays.asList(array);
        Map<String, Node> map = buildMap(list);
        for(String key:map.keySet()) {
            Node curr = map.get(key);
            System.out.print("{"+key+"}");
            while(curr != null) {
                System.out.print("->["+curr.word+"]");
                curr = curr.next;
            }
            System.out.println();
        }
    }
    public static Map<String, Node> buildMap(List<String> list) {
        Map<String, Node> map = new HashMap<String, Node>();
        for(String word:list) {
            prefixWord(word, map);
        }
        return map;
    }
    public static void prefixWord(String word, Map<String, Node> map) {
        for(int i=0; i<word.length(); i++) {
            String key = word.substring(0, i+1);
            if(map.containsKey(key)) {
                Node curr = map.get(key);
                Node prev = null;
                while(curr != null) {
                    if(curr.word.equals(word))
                        break;
                    else {
                        prev = curr;
                        curr = curr.next;
                    }
                }
                if(curr == null)
                    prev.next = new Node(key, word);
            } else {
                map.put(key, new Node(key, word));
            }
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Node
{
	public Node left;
	public Node right;
	public int data;
	public Node(int n)
	{ data = n; left = null; right = null; }
	public Node getLeft()
	{ return left; }
	public Node getRight()
	{ return right; }
	public void setLeft(Node l)
	{ left = l;}
	public void setRight(Node r)
	{ right = r;}
}

class BST
{
	Node root;
	public BST()
	{ root = null;};
	public void Insert(int n)
	{
		if(root == null)
		{ root = new Node(n); }
		else
		{ 
			Node cur = root;
			boolean end = false;
			while(cur != null && !end)
			{
				if(n < cur.data)
				{ 
					if(cur.left == null)
					{ cur.left = new Node(n); end = true; }
					else 
						cur = cur.left;
				}
				else 
				{
					if(cur.right == null)
					{ cur.right = new Node(n); end = true; }
					else
						cur = cur.right;
				}
			}
		}
	}
	public void Inorder(Node cur)
	{
		if(cur != null)
		{
			Inorder(cur.left);
			System.out.print(cur.data + " ");
			Inorder(cur.right);
		}
	}
	public Node getRoot()
	{ return root;}
}
class PreorderIteration
{

	public static Node prev = null;
	public static void main(String args[])
	{
		BST b1 = new BST();


		b1.Insert(15);
		
		b1.Insert(12);
		b1.Insert(14);
		b1.Insert(17);
		b1.Insert(19);
		b1.Insert(130);
		b1.Insert(16);
		b1.Insert(10);
		
		
		PreorderIteration(b1.getRoot());
		System.out.println();
		Inorder(b1.getRoot());
	}
	//in order traversal using iteration
	public static void InorderIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					st.push(cur);
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					System.out.println("no.data=" + no.data);
					cur = no.right;
				}
			}
		}
	}

	public static void PreorderIteration(Node r)
	{
		Stack<Node> st = new Stack<Node>();
		Node cur = r;

		if( cur != null)
		{ 
			while(!st.empty() || cur != null)
			{
				if(cur != null)
				{
					System.out.println("cur.data=" + cur.data);
					st.push(cur);
					cur = cur.left;
				}
				else 
				{ Node no = st.pop();
					cur = no.right;
				}
			}
		}
	}	
	public static void Inorder(Node root)
	{
		if(root != null)
		{
			Inorder(root.left);
			System.out.println("data=" + root.data);
			Inorder(root.right);
		}
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;

import classfile.*;

class PrettyBinPrint {
    public static Node prev = null;
    public static void main(String args[]) {
       test0(); 
       //test1(); 
    }
    
    static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(14);
        b1.insert(17);
        b1.insert(19);

        b1.insert(16);
        b1.insert(10);
//        b1.insert(18);
//        b1.insert(60);
//        b1.insert(2);
//        b1.insert(8);
//        b1.insert(70);

        int[] Arr = new int[100];
        int len=0;
        Node r = b1.root;

        Aron.levelOrder(r); 

        System.out.println(contain(r, 15));
        System.out.println();
        int indent=1;
        Aron.prettyPrint(r, indent);
        System.out.println();

        Aron.binImage(r);
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);

        int[] arr = new int[20]; 
        int index = 0;
        Aron.printAllPath(b1.root, arr, index); 

        Aron.binImage(b1.root);
        Aron.end();
    } 

    public static int MaxDepth(Node r) {
        if( r != null) {
            int nl = MaxDepth(r.left);
            int nr = MaxDepth(r.right);

            return (nl>nr?nl:nr)+1;
        }
        return 0;
    }

    public static boolean contain(Node r, int value) {
        if( r != null) {
            if(contain(r.left, value))
                return true;
            if(r.data == value)
                return true;
            if(contain(r.right, value))
                return true;
        }
        return false;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class PreviousNumberBin{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test_next();
    }
    public static void test0(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 7;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 1;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }

    public static void test2(){
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 15;
        Node prev = null;
        Print.pbl("curr=" + n);
        previous(b1.root, n, prev);
        Aron.end();
    }

    // print previous number, previous element, previous node 
    // previous num in binary tree, previous n in binary tree, previous n in binarytree
    // microsoft interview, ms inerview, MS interview
    public static boolean previous(Node r, int n, Node prev){
        if( r != null){
            if(previous(r.left, n, prev))
                return true;
            if(r.data == n){
                if(prev == null)
                    Print.pbl(-1);
                else
                    Print.pbl(prev.data);
                return true;
            }
            if(previous(r.right, n, r))
                return true;
        }
        return false;
    }
    
    static void test_next(){
        Aron.beg();

        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(1);
        b1.insert(7);
        int level = 0;
        boolean isLeaf = true;
        Aron.prettyPrint(b1.root, level, isLeaf);
        Aron.binImage(b1.root); 

        int n = 5;
        if(!next(b1.root, n)){
            Print.pp("null");
        }

        Aron.end();
    }

    // print the next node, next node,
    // next node from binary tree, next node binary tree
    static Node nextNode = null;
    public static boolean next(Node r, int n){
        if(r != null){
            if(next(r.left, n))
               return true;

            if(nextNode != null){
                Print.pb("next node=" + r.data);
                return true;
            }

            if(r.data == n){
                nextNode = r;
            }

            if(next(r.right, n))
                return true;
        }
        return false;
    }
} 

import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import classfile.*;

public class Prime {
    public static void main(String[] args) {
        System.out.println("Hello World!");
        long startTime = System.currentTimeMillis();
        Prime(100000);
        long endTime = System.currentTimeMillis();
        long diff = endTime - startTime;
        System.out.println("diff=" + diff);
    }
    

    //Find all the primes from 2 to n
    public static void Prime(int n) {
        boolean[] prime = new boolean[n];
        for(int i=0; i<n; i++)
            prime[i] = true;

        for(int i=2; i<n; i++) {
            for(int j=2; j<i && prime[i]; j++) {
                if(prime[j] && (i % j) == 0)
                    prime[i] = false;
            }
        }
        for(int i=2; i<n; i++) {
            System.out.println("[" + i + "]=" + prime[i]);
        }
    }

    // generate n primes
    public static List<Integer> nPrime(int n) {
        List<Integer> list = new ArrayList<Integer>();
        list.add(2);
        int count = 1;
        int num = 3;
        while(count <= n) {
            boolean isPrime = true;
            for(Integer p : list) {
                if(num % p == 0) {
                    isPrime = false;
                    break;
                }
            }
            if(isPrime) {
                list.add(num);
                count++;
            }
            num++;
        }
        return list;
    }
    //[ file=allprime.html title=""
    // generate all prime are up to n
    public static List<Integer> allPrime(int n) {
        List<Integer> list = new ArrayList<Integer>();
        if(n > 1) {
            list.add(2);
            for(int i=3; i<=n; i++) {
                boolean isPrime = true;
                for(int j=0; j<list.size() && isPrime; j++) {
                    if(i % list.get(j) == 0)
                        isPrime = false;
                }
                if(isPrime)
                    list.add(i);
            }
        }
        return list;
    }
    //]

    //[file=checkprime.html title=""
    public static boolean prime(int d, int n) {
        if(n == 2)
            return true;
        else if(n % d == 0)
            return false;
        else if(d*d <= n)
            return prime(d+1, n);
        else
            return true;
    }
    public static boolean isPrimeLoop(int n) {
        if( n == 2)
            return true;
        for(int d=2; d*d <= n; d++) {
            if(n % d == 0)
                return false;
        }
        return true;
    }
    //]
}
public class PrintTriangle 
{
    public static void main(String[] args)
    {
        int array[][] = new int[][]{
        { 0, 2, 3, 4, 5 },
        { 0, 0, 1, 2, 9 },
        { 0, 0, 0, 6, 5 },
        { 0, 0, 0, 0, 7 },
        { 0, 0, 0, 0, 0 }
        };
        System.out.println("Hello World!");
        int depth = 0;
        int max = Triangle(array, 0, 0);
        System.out.println("max="+max);
    }
    public static int Triangle(int[][] array, int row, int depth)
    {
        int max = 0;
        if(array != null)
        {
            int height = array.length;
            int width  = array[0] != null ? array[0].length : 0;
            //System.out.println("height="+height);
            //System.out.println("width ="+width);
            if(depth < width)
            {
                for(int i=0; i<width; i++)
                {
                    if(row < height && array[depth][i] != 0 && i != row)
                    {
                        int m = Triangle(array, i, depth+1) + array[depth][i];
                        max = max < m? m : max; 
                        System.out.println("["+depth+"]["+i+"]="+array[depth][i]);
                    }
                }
            }
        }
        return max;
    }
}
import java.util.*;
import classfile.*;

// priority heap compareto compareTo heapify heap
//[ file=priorityheap.html title=""
class Contact implements Comparable<Contact> {
    String name;
    String addr;
    int    age;
    public Contact(String name, String addr, int age) {
        this.name = name;
        this.addr = addr;
        this.age = age;
    }

    //Minimum heap
    public int compareTo(Contact c) {
        return this.age - c.age;
        //Maximum heap
        //return -(this.age - c.age);
    }

    public String toString() {
        return "["+name+"]["+addr+"]["+age+"]";
    }
}

public class PriorityQueueHeap {
    public static void main(String[] args) {
        test1();
    }
    public static void test1() {
        System.out.println("Minimum/Maximum Heap PriorityQueue");
        PriorityQueue<Contact> miniHeap = new PriorityQueue<Contact>();
        miniHeap.add(new Contact("David", "U.S", 3));
        miniHeap.add(new Contact("John", "U.S", 4));
        miniHeap.add(new Contact("Johnny", "U.S", 2));
        miniHeap.add(new Contact("Nathan", "U.S", 1));

        int k = 3;
        while(k > 0) {
            Print.p(miniHeap.remove().toString());
            k--;
        }
    }
}
//]
import java.io.IOException;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.LineIterator;
import classfile.*;

// parse CVS file
public class ProcessCVS{
    public static void main(String[] args) {
        test0();
        //test1();
        //writeCrapToFile();
    }

    public static void test0() {
        long ti, tf;
        ti = System.currentTimeMillis();
        //String cvsFile = "/Users/cat/myfile/github/java/text/acl.cvs";
        String cvsFile = "/Users/cat/myfile/github/java/text/big.txt";
        String outFile = "/Users/cat/myfile/github/java/text/acl_out.txt";
        convertCVS(cvsFile, outFile);
        tf = System.currentTimeMillis();
        Print.pbl("Finish. Total time:" + (tf - ti)/1000.00); 
    }
    public static void test1() {
        long ti, tf;
        ti = System.currentTimeMillis();
        //String cvsFile = "/Users/cat/myfile/github/java/text/acl.cvs";
        String cvsFile = "/Users/cat/myfile/github/java/text/big.txt";
        String outFile = "/Users/cat/myfile/github/java/text/acl_out.txt";
        convertCVSList(cvsFile, outFile);
        tf = System.currentTimeMillis();
        Print.pbl("Finish. Total time:" + (tf - ti)/1000.00); 
    }

    public static String leftPad(String str, int max, int len) {
        int diff = max - len;
        if(diff > 0) {
            for(int i=0; i<diff; i++)
                str = " " + str;
        }
        return str;
    }
    public static String rightPad(String str, int max, int len) {
        int diff = max - len;
        if(diff > 0) {
            for(int i=0; i<diff; i++)
                str += " ";
        }
        return str;
    }

    // if str is a string, strim two double quotes. O.W return null
    public static String getString(String str) {
        if(str != null) {
            Pattern pattern = Pattern.compile("\"([^\"]*)\"");
            Matcher matcher = pattern.matcher(str);
            while(matcher.find()) {
                for(int i=1; i<=matcher.groupCount(); i++) {
                    if(matcher.group(i) != null)
                        return matcher.group(i);
                }
            }
        }
        return null;
    }

    public static int getMax(List<String> list) {
        int max = 0;
        for(String s : list) {
            if(getString(s) != null) {
                int l = s.length() - 2;
                if(l > max)
                    max = l;
            } else {
                if(s.length() > max)
                    max = s.length();
            }
        }
        return max;
    }

    public static void convertCVS(String cvsFile, String outFile) {

        // match string or number/decimal
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        FileWriter fstream = null;
        BufferedWriter out = null;

        try {
            fstream = new FileWriter(outFile);
            out = new BufferedWriter(fstream);

            LineIterator it = FileUtils.lineIterator(new File(cvsFile), "UTF-8");
            while (it.hasNext()) {
                String s = it.next();
                Matcher matcher = pattern.matcher(s);
                int len = 0;
                List<String> row = new ArrayList<String>();
                while(matcher.find()) {
                    for(int i=1; i<= matcher.groupCount(); i++) {
                        if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                            len = matcher.group(i).length();

                            String ss = matcher.group(i);
                            if(getString(ss) != null) {
                                // ss is string 
                                String str1 = ss.replace("\\r\\n", " ");
                                row.add(str1);
                            } else {
                                // ss is number or decimal 
                                row.add(matcher.group(i));
                            }
                        }
                    }
                }
                int max = getMax(row);

                for(int i=0; i<row.size(); i++){
                    String item = row.get(i);
                    String newStr = getString(item);
                    if(newStr != null) {
                        String paddedStr = rightPad(newStr, max, newStr.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }else{
                        String paddedStr = leftPad(item, max, item.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }
                }
                out.write("\r\n");
            }

            out.close();
        } catch(IOException e) {
            System.err.println(e.getMessage());
        }
    }

    public static void convertCVSList(String cvsFile, String outFile) {

        // match string or number/decimal
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        List<ArrayList<String>> list2d = new ArrayList<ArrayList<String>>();
        FileWriter fstream = null;
        BufferedWriter out = null;

        try {
            fstream = new FileWriter(outFile);
            out = new BufferedWriter(fstream);

            List<String> list = Aron.readFile(cvsFile);
            for(String s : list) {
                Matcher matcher = pattern.matcher(s);
                int len = 0;
                List<String> row = new ArrayList<String>();
                while(matcher.find()) {
                    for(int i=1; i<= matcher.groupCount(); i++) {
                        if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                            len = matcher.group(i).length();

                            String ss = matcher.group(i);
                            if(getString(ss) != null) {
                                // ss is string 
                                String str1 = ss.replace("\\r\\n", " ");
                                row.add(str1);
                            } else {
                                // ss is number or decimal 
                                row.add(matcher.group(i));
                            }
                        }
                    }
                }
                int max = getMax(row);

                for(int i=0; i<row.size(); i++){
                    String item = row.get(i);
                    String newStr = getString(item);
                    if(newStr != null) {
                        String paddedStr = rightPad(newStr, max, newStr.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }else{
                        String paddedStr = leftPad(item, max, item.length());
                        if(i < row.size() - 1)
                            out.write(paddedStr + " ");
                        else
                            out.write(paddedStr);
                    }
                }
                out.write("\r\n");
            }

            out.close();
        } catch(IOException e) {
            System.err.println(e.getMessage());
        }
    }
    public static void writeCrapToFile(){
        String fname = "./text/big.txt";
        List<String> list = new ArrayList<String>(); 
        for(int i=0; i<100000; i++){
            list.add("\"dog cat\"" + "," + "12334" + "," + "341.44" + "\n");
        } 
       Aron.writeFile(fname, list);
    }
}

import java.util.*;
import java.io.*;
import classfile.*;

interface Publisher{
    public void publish(String msg);
}

class News implements Publisher{
    HashSet<Subscriber> set = new HashSet<Subscriber>();
    public void publish(String msg){
        for(Subscriber s : set){
            s.msgList.add(msg);
        }
    }

    public void addSub(Subscriber sub){
        set.add(sub);
    }
}

interface Subscriber{
    public void getPublisher();
}

class User1 implements Subscriber{
    Publisher pub;
    List<String> msgList = new ArrayList<String>();
    public Subscriber(Publisher pub){
        this.pub = pub;
    }
    public void getPublisher(){
        pub.publish();
    }
    public void add(String msg){
        msgList.add(msg);
    }
    public void show(){
        for(String s : msgList){
            Print.p(msg);
        }
    }
}


public class PublicSubscribe{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }
} 

/**
  * solve eight queen problem with backtrack 
  */
public class Queen 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        final int len = 4;
        int[][] board = new int[len][len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                board[i][j] = i*len+j;

        int[] path = new int[len];
        int row = 0;
        queen(board, row, path);
    }
    public static void queen(int[][] board, int row, int[] path)
    {
        if(board != null && board[0] != null)
        {
            int len = board.length;
            for(int col = 0; col < len && row < len; col++)
            {
                if(consistent(path, row, col))
                {
                    path[row] = col;
                    queen(board, row+1, path);
                }
            }

            if(row == len)
            {
                for(int r=0; r<len; r++)
                {
                    for(int c=0; c<len; c++)
                    {
                        if(path[r] == c)
                            System.out.print("["+"x"+"]");        
                        else
                            System.out.print("["+"0"+ "]");        

                    }
                    System.out.println("");        
                }
                System.out.println("");        
            }
        }
    }
    public static boolean consistent(int[] path, int currentRow, int currentCol) 
    {
        boolean ret = true;
        if(path != null)
        {
            int len = path.length;
            for(int row=0; row < currentRow && ret; row++)
            {
                if(path[row] == currentCol)
                    ret = false;
                else if( Math.abs(currentRow - row ) == Math.abs(currentCol - path[row]))
                    ret = false;
            }
        }
        return ret;
    }
}
public class Queen2 
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        final int len = 4;
        final int width = 8;
        int[][] board = new int[len][len];
        for(int i=0; i<len; i++)
            for(int j=0; j<len; j++)
                board[i][j] = i*len+j;

        int[][] path = new int[width][2];
        int depth = 0;
        queen(path, width, depth);

    }
    public static boolean consistent(int[][] path, int width, int depth, int newRow)
    {
        if(path != null)
        {
            for(int i = 0; i < depth; i++)
            {
                int currCol = path[i][0];
                int currRow = path[i][1];
                if(currRow == newRow)
                    return false;
                else if(Math.abs(depth - currCol ) ==Math.abs(newRow - currRow))
                    return false;
            }
        }
        return true;
    }
    public static void queen(int[][] path, int width, int depth)
    {
        if(depth == width)
        {
            for(int i=0; i < depth; i++)
                System.out.println("["+path[i][0]+"]["+path[i][1]+"]");
            System.out.println("");
        }
        else 
        {
            for(int row=0; row < width; row++)
            {
                if(consistent(path, width, depth, row)) 
                {
                    path[depth][0] = depth;
                    path[depth][1] = row;
                    queen(path, width, depth+1);
                }
            }
        }
    }
}
import java.io.*;
import java.util.*;

//quick sort algorithm
class QuickSort 
{
	public static void main(String args[])
	{
        Test1();
        Test2();
        Test3();
        Test4();
        Test5();
	}
    public static void Test1()
    {
        System.out.println("test case1:");
		int[] Arr = {100};
		int left = 0;
		int right = Arr.length-1;
		QuickSort(Arr, left, right);
		for(int i=0; i<Arr.length; i++)
			System.out.println("Arr[" + i + "]=" + Arr[i]);
    }
    public static void Test2()
    {
        System.out.println("test case2:");
		int[] Arr1 = {100, 1};
		int left = 0;
		int right = Arr1.length-1;
		QuickSort(Arr1, left, right);
		for(int i=0; i<Arr1.length; i++)
			System.out.println("Arr1[" + i + "]=" + Arr1[i]);
    }
    public static void Test3()
    {
		System.out.println("test case3:");
		int[] Arr2 = {1, 5};
		int left = 0;
		int right = Arr2.length-1;
		QuickSort(Arr2, left, right);
		for(int i=0; i<Arr2.length; i++)
			System.out.println("Arr2[" + i + "]=" + Arr2[i]);
    }
    public static void Test4()
    {
        System.out.println("test case4:");
		int[] Arr3 = {100, 1, 7, 6};
		//int[] Arr3 = {100, 1, 3, 9, 6, 5, 7};
		//int[] Arr3 = {9, 1, 2, 4};
		int left = 0;
		int right = Arr3.length-1;
		QuickSort(Arr3, left, right);
		for(int i=0; i<Arr3.length; i++)
			System.out.println("Arr3[" + i + "]=" + Arr3[i]);
    }

    public static void Test5()
    {
        System.out.println("test case5:");
		int[] Arr3 = {1, 7, 5};
		int left = 0;
		int right = Arr3.length-1;
		QuickSort(Arr3, left, right);
		for(int i=0; i<Arr3.length; i++)
			System.out.println("Arr3[" + i + "]=" + Arr3[i]);
    }
    public static void QuickSort(int[] Arr, int left, int right)
    {
        if(left < right)
        {
            int pivot = Partition(Arr, left, right);
            QuickSort(Arr, left, pivot-1);
            QuickSort(Arr, pivot+1, right);
        }
    }

    public static void swap(int[] arr, int left, int right)
    {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
    public static int Partition(int[] arr, int left, int right)
    {
        int prev = left;
        if(arr != null)
        {
            int pivot = arr[right];
            prev = left;
            for(int i=left; i<=right; i++)
            {
                if(arr[i] < pivot)
                {
                    swap(arr, i, prev);
                    prev++;    
                }
            }
            swap(arr, prev, right);
        }
        return prev;
    }
    //partition
	public static int Partition2(int[] Arr, int left, int right)
	{
		int ret = 0;
		if(Arr != null)
		{
			int len = right - left + 1; 
			if(len == 1)
				ret = left;
			else if(len > 1)
			{
				int pivot = Arr[left];
				int i=left;
				int j=right;
				while(i < j)
				{
					while(i < right && Arr[i] <= pivot ) i++;
					while(j > left && Arr[j] > pivot) j--;
					if(i<j)
					{ int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;
			}
		}
		return ret;
	}
}
import java.util.*;

public class QuickSortLinkedList 
{
    public static void main(String[] args)
    {
        System.out.println("Try it");
        SLL s1 = new SLL();
        SLL s2 = new SLL();
        SLL s3 = new SLL();
        s1.append(2);
        s1.append(20);
        s1.append(30);
        s1.append(40);
        s1.append(50);

        System.out.println("================");
        show(s1.getHead());
        System.out.println("================");
        Node mnode = partition(s1.getHead());
        show(s1.getHead());
        System.out.println("================");
        show(mnode);
        System.out.println("================");

        Node node = median(s1.getHead());
        System.out.println("median["+node.data+"]");

        s2.append(1);
        s2.append(7);
        s2.append(10);

        s3.append(3);
        s3.append(4);
        s3.append(20);

        Node s =  mergeList(mergeList(s1.getHead(), s2.getHead()), s3.getHead());
        show(s);
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    public static void show(Node curr)
    {
        while(curr != null)
        {
	 	    System.out.println("["+curr.data+"]");
            curr = curr.next;
        }
    }

    public static void test4()
    {
        System.out.println("begin test4==================");
        SLL s1 = new SLL();
        
        s1.append(2);
        s1.append(40);
        s1.append(100);
        
        s1.append(50);
        
        s1.append(30);
        
        s1.append(20);
        s1.append(1);
        s1.append(6);
        s1.append(20);
        s1.append(2);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test4==================");
    }

    public static void test5()
    {
        System.out.println("begin test4==================");
        SLL s1 = new SLL();
        
        s1.append(1);
        s1.append(2);
        s1.append(3);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test5==================");
    }

    public static void test6()
    {
        System.out.println("begin test6==================");
        SLL s1 = new SLL();
        
        s1.append(30);
        s1.append(20);
        s1.append(10);
        
        System.out.println("----------------------------");
        show(s1.getHead());
        System.out.println("----------------------------");

        Node[] prev = new Node[1];
        prev[0] = null;
        qsLinkedList(s1.getHead(), s1.getTail(), prev);
        show(s1.getHead());
        System.out.println("begin test4==================");
    }

    public static void test2()
    {
        System.out.println("begin test2()================");
        SLL s1 = new SLL();
        s1.append(4);
        s1.append(8);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test1()================");
    }

    public static void test3()
    {
        System.out.println("begin test3()================");
        SLL s1 = new SLL();
        s1.append(4);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        if(pivot != null)
            System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test3()================");
    }
    public static void test1()
    {
        System.out.println("begin test2()================");
        SLL s1 = new SLL();
        s1.append(4);
        s1.append(8);
        s1.append(3);
        s1.append(6);
        s1.append(5);
        show(s1.getHead());

        Node[] prev = new Node[1];
        prev[0] = null;
        Node pivot = qsPartition(s1.getHead(), s1.getTail(), prev);
        System.out.println("pivot=["+pivot.data+"]");
        System.out.println("================");
        show(s1.getHead());
        System.out.println("end test1()================");
    }
    public static void swap(Node first, Node second)
    {
        int tmp = first.data;
        first.data = second.data;
        second.data = tmp;
    }
    public static void qsLinkedList(Node head, Node tail, Node[] prev)
    {
        Node h = head;
        Node t = tail;
        Node pivot = qsPartition(h, t, prev); 
        Node myh = h;
        Node myt = t;
        while(myh != null)
        {
            System.out.println("myh["+myh.data+"]");
            if(myh != myt)
                myh = myh.next;
            else
                break;
        }
        if(head != tail)
        {
            if(pivot != null)
                System.out.println("pivot["+pivot.data+"]");
            if(prev[0] != null)
                System.out.println("prev["+prev[0].data+"]");
            if(h != null)
                System.out.println("h["+h.data+"]");
            if(t != null)
                System.out.println("t["+t.data+"]");
            System.out.println("-----------------------");
            
            //if(h != null && prev[0] != null)
            if(h != pivot)
                qsLinkedList(h, prev[0], prev); 
            if(pivot != t)
                qsLinkedList(pivot.next, t, prev);
        }
    }
    public static Node qsPartition(Node head, Node tail, Node[] prev)
    {
        Node curr = head;
        Node big = curr;
        Node pivot = tail;
        if(head == tail)
        {
            System.out.println("head{"+head.data+"}");
            System.out.println("tail{"+tail.data+"}");
            System.out.println("pivot{"+pivot.data+"}");
            prev[0] = null;
            return null;    
        }
        else
        {
            while(curr != null)
            {
                if(curr.data < pivot.data)
                {
                    swap(curr, big);
                    prev[0] = big;
                    System.out.println("prev{"+prev[0].data+"}");
                    big = big.next;
                }                
                curr = curr.next;
            }
            if(big != null)
                swap(pivot, big);
            return big;
        }
    }
    public static Node partition(Node head)
    {
        Node mnode = median(head);
        if(mnode != null)
        {
            Node ret = mnode.next;
            mnode.next = null;
            return ret;
        }
        else
            return mnode;
    }
    public static Node median(Node head)
    {
        Node curr = head;
        Node mcurr = curr;
        if(curr != null)
        {
            while(curr.next != null)
            {
                curr = curr.next.next;
                if(curr == null)
                    break;
                mcurr = mcurr.next;
            }
        }
        return mcurr;
    }
    public static int[] merge(int[] arr1, int[] arr2)
    {
        int[] arr = null; 
        if(arr1 == null)
            return arr2;
        else if(arr2 == null)
            return arr1;
        else 
        {
            int len1 = arr1.length;
            int len2 = arr2.length;
            arr = new int[len1+len2];
            int inx1 = 0;
            int inx2 = 0;
            int k=0;

            while(inx1 < len1 || inx2 < len2)
            {
                if(inx1 >= len1)
                {
                    arr[k] = arr1[inx2];
                    inx2++;
                }
                else if(inx2 >= len2)
                {
                    arr[k] = arr2[inx1];
                    inx1++;
                }
                else
                {
                    if(arr1[inx1] < arr2[inx2])
                    {
                        arr[k] = arr1[inx1];
                        inx1++;
                    }
                    else
                    {
                        arr[k] = arr2[inx2];
                        inx2++;
                    }
                }
                k++;
            }
        }
        return arr;
    }
    public static Node mergeList(Node s1, Node s2)
    {
        Node curr = null;
        Node head = curr;
        while( s1 != null || s2 != null)
        {
            if(s1 == null)
            {
                if(curr == null)
                   head = curr = s2;
                else
                {
                    curr.next = s2;
                    curr = curr.next;
                }
                s2 = s2.next;
            }
            else if(s2 == null)
            {
                if(curr == null)
                    head = curr = s1;
                else
                {
                    curr.next = s1;
                    curr = curr.next;
                }
                s1 = s1.next;
            }
            else
            {
                if(s1.data < s2.data)
                {
                    if(curr == null)
                        head = curr = s1;
                    else
                    {
                        curr.next = s1;
                        curr = curr.next;
                    }
                    s1 = s1.next;
                }
                else
                {
                    if( curr == null)
                        head = curr = s2;
                    else
                    {
                        curr.next = s2;
                        curr = curr.next;
                    }
                    s2 = s2.next;
                }
            }
        }
        return head;
    }
}
	public static int Partition2(int[] Arr, int left, int right)
	{
		int ret = 0;
		if(Arr != null)
		{
			int len = right - left + 1; 
			if(len == 1)
				ret = left;
			else if(len > 1)
			{
				int pivot = Arr[left];
				int i=left;
				int j=right;
				while(i < j)
				{
					while(i < right && Arr[i] <= pivot ) i++;
					while(j > left && Arr[j] > pivot) j--;
					if(i<j)
					{ int tmp = Arr[i];
						Arr[i] = Arr[j];
						Arr[j] = tmp;
					}
				}
				int t = Arr[left];
				Arr[left] = Arr[j];
				Arr[j] = t;
				ret = j;
			}
		}
		return ret;
	}
public class Quine {
  public static void main(String[] args) {
    System.out.printf("public class Quine {\n public static void main(String[] args) {\n System.out.printf(");
  }
}

import java.util.Random;

public class RandomNumber
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[] array = RandomNum(1, 10);
        Aron.printArray(array);
    }
    // generate 0 - [n-1]
    public static int[] RandomNum(int init, int n)
    {   
        int[] array = new int[n]; 
        Random rn = new Random();
        for(int i=0; i<n; i++)
            array[i] = rn.nextInt(n) + init;

        return array;
    }
}
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;

// regex example, regular expression example
// match, case insensitive, case-insensitive, case-sensitive, group, find
// *jregex* *j_regex_example_many*
public class RegexExample{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
        test10();
        test11();
    }
    static void test0(){
        Aron.beg();
        String pattern = "([a-z]+).([a-zA-Z-]+)(/)";
        String[] strArr = {
            "www.google.com/search?q=goog/nice",
            "www.google.com/search?q=goog",
            "http://www.google.msn.ca/search?q=goog",
            "http://www.google.msn.ca/a/b/c/d"
        };

        Pattern r = Pattern.compile(pattern);
        for(int i=0; i<strArr.length; i++) {
            Matcher mat = r.matcher(strArr[i]);
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
        }

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Pattern r = Pattern.compile("captheorem", Pattern.CASE_INSENSITIVE);
        Matcher mat = r.matcher("CAPTHEOREM");
        if(mat.find()) {
            Print.p("found=" + mat.group(0));
        }
        Aron.end();
    }
    static void test2(){
        Aron.beg();
        //Pattern pattern = Pattern.compile("[0-9]{3}[-]{0,1}[0-9]{3}[-]{0,1}[0-9]{4}");
        Pattern pattern = Pattern.compile("[0-9]{3}[-]?[0-9]{3}[-]?[0-9]{4}");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
        Aron.end();
    } 
    static void test3(){
        Aron.beg();

        // match number
        Pattern pattern = Pattern.compile("\\d+");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
        Aron.end();
    } 
    static void test4(){
        Aron.beg();

        // match number and group
        Pattern pattern = Pattern.compile("\\w+");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
        Aron.end();
    } 
    static void test5(){
        Aron.beg();

        // match number
        Pattern pattern = Pattern.compile("[A-Z]+");
        Matcher matcher = pattern.matcher("This is case insensitive PREPOSITION");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test6(){
        Aron.beg();

        // match number
        Pattern pattern = Pattern.compile("[a-zA-Z0-9_]+");
        Matcher matcher = pattern.matcher("This is case_INSENSITIVE PREPOSITION");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test7(){
        Aron.beg();

        // excluding a,n, and space
        Pattern pattern = Pattern.compile("[^an ]+");
        Matcher matcher = pattern.matcher("This is banana");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test8(){
        Aron.beg();

        // excluding all vowels 
        Pattern pattern = Pattern.compile("[a-z&&[^youiea]]+");
        Matcher matcher = pattern.matcher("show all the words which do not contains vowel");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 
    static void test9(){
        Aron.beg();

        // POSIX character classes \p{Lower}+ => [a-z]+ 
        Pattern pattern = Pattern.compile("\\p{Lower}+");
        Matcher matcher = pattern.matcher("show all the words which do not contains vowel");
        while(matcher.find()) {
            Print.pbl(matcher.group());
        }
        Aron.end();
    } 

    // grouping
    static void test10(){
        Aron.beg();
        //import java.util.regex.Matcher;
        //import java.util.regex.Pattern;
        String str = "\"dog cat\" 3241.10 "; 
        Pattern pattern = Pattern.compile("(\"[^\"]*\")|([0-9]*\\.?[0-9]+)");
        Matcher matcher = pattern.matcher(str);
        while(matcher.find()) {
            for(int i=1; i<= matcher.groupCount(); i++) {
                if(matcher.group(i) != null && matcher.group(i).length() > 0) {
                    String ss = matcher.group(i);
                    Print.pbl(ss);
                }
            }
        }

        
        Aron.end();
    }

    public static void test11(){
        Aron.beg();
        
        // match boundary word, match word, match words, match word only
        // boundary word, boundary words only, boundary only, word boundary
        String[] arr = {
            "dog",
            "cat",
            "key-value"
        };
        Pattern pattern = Pattern.compile("(?<=^|\\s)[a-z]+(?=\\s|$)");
        Aron.printArray(arr);
        for(String s : arr){
            Matcher matcher = pattern.matcher(s);
            if(matcher.find()){
                Print.pbl("match word=" + matcher.group());
            }
        }
        Print.pbl("Does not match key-value");

        Aron.end();
    }
} 

import java.io.*;
import java.lang.String;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import classfile.*;

public class RegexMatches {
    public static void main( String args[] ) {
        test0();
        test1();
    }
    static void test0(){
        Aron.beg();
        String pattern = "([a-z]+).([a-zA-Z-]+)(/)";
        String[] strArr = {
            "www.google.com/search?q=goog/nice",
            "www.google.com/search?q=goog",
            "http://www.google.msn.ca/search?q=goog",
            "http://www.google.msn.ca/a/b/c/d"
        };

        Pattern r = Pattern.compile(pattern);
        for(int i=0; i<strArr.length; i++) {
            Matcher mat = r.matcher(strArr[i]);
            if(mat.find()) {
                Print.p("found=" + mat.group(0));
            }
        }

        Aron.end();
    }
    // case insensitive
    static void test1(){
        Aron.beg();
        Pattern r = Pattern.compile("captheorem", Pattern.CASE_INSENSITIVE);
        Matcher mat = r.matcher("CAPTHEOREM");
        if(mat.find()) {
            Print.p("found=" + mat.group(0));
        }
        Aron.end();
    }
}
import java.util.regex.Pattern;
import java.util.regex.Matcher;

// 411-114-3475 whatever  415-3354567 what 665335-9987 cool 6653334467
public class RegexPhone {
    public static void main(String[] args) {

        //Pattern pattern = Pattern.compile("[0-9]{3}[-]{0,1}[0-9]{3}[-]{0,1}[0-9]{4}");
        Pattern pattern = Pattern.compile("[0-9]{3}[-]?[0-9]{3}[-]?[0-9]{4}");
        Matcher matcher = pattern.matcher("334-4467777 yes... 334666-4456 415-333-9674 whatever 4264491569");
        while(matcher.find()) {
            System.out.println(matcher.group());
        }
    }
}

/* output
334-4467777
334666-4456
415-333-9674
4264491569
*/
import Lib.*;

public class Hello
{
    public static void main(String[] args)
    {
        System.out.println("Hello World!");
        int[][] array2d = new int[3][2];

        System.out.println("array2.length="+array2d.length);
        System.out.println("array2[0].length="+array2d[0].length);

        for(int i=0; i<3; i++)
            array2d[i] = fun();

        for(int i=0; i<3; i++)
        {
            for(int j=0; j<2; j++)
                System.out.print("["+array2d[i][j]+"]");
            System.out.println();
        }

        test1();
        testParition();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
        test8();
        test9();
    }

    public static void test8()
    {
        System.out.println("test8"); 
        String str = "abcde";
        int k=0;
        int p=0;
        Integer num = new Integer(0);
        dump(str, k, p, num);
    } 
    public static void test9()
    {
		BST b1 = new BST();
		b1.Insert(15);
		b1.Insert(12);
        Node prev = null;
        boolean isbst = isBST(b1.root, prev);
        System.out.println("isbst=" + isbst);

    } 
    public static void dump(String str, int k, int p, Integer num){
        if(k < str.length()){
            dump(str, k+1, p, num);
        }
        else if(k == str.length()){
            num = new Integer(3); 
            p = 10;
        }
        if(k < str.length())
            System.out.println("charAt [" + k + "]=" + str.charAt(k));
        System.out.println("p=" + p + "  num=" + num);
    }

    public static boolean isBST(Node root, Node prev)
    {
        if( root != null)
        {
            if(!isBST(root.left, prev))
                return false;
            if(prev != null && prev.data >= root.data)
                return false;
            if(!isBST(root.right, root))
                return false;
        }
        return true;
    }

    public static void kdistance(Node r, int k){
        
        if(r != null){
            if(k == 0)
                System.out.println(r.data);
            else{
                kdistance(r.left, k-1);
                kdistance(r.right, k-1);
            }
        }
    }

    public static void test7()
    {
        System.out.println("test7"); 
        int[] arr1 = {3, 1, 4, 6, 2};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test6()
    {
        System.out.println("test6"); 
        int[] arr1 = {3};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test5()
    {
        System.out.println("test5"); 
        int[] arr1 = {3, 2};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test4()
    {
        System.out.println("test4"); 
        int[] arr1 = {2, 3, 2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        mergeSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    //[file=mergesort1.html title=""
    public static void mergeSort(int[] arr, int lo, int hi){
        if(lo < hi){
            int mid = (lo + hi)/2;
            mergeSort(arr, lo, mid);
            mergeSort(arr, mid+1, hi);
            merge(arr, lo, mid, hi);
        }
    }
    public static void merge(int[] arr1, int lo, int mid, int hi){
        int len = hi - lo + 1; 
        int[] array = new int[len];
        if(len > 1){
            int i = lo;
            int j = mid+1;
            int k = 0;
            while(i <= mid || j <= hi){
                if(i > mid){
                    array[k] = arr1[j];
                    j++;
                }
                else if (j > hi){
                    array[k] = arr1[i];
                    i++;
                }
                else{
                    if(arr1[i] < arr1[j]){
                        array[k] = arr1[i];
                        i++;
                    }else{
                        array[k] = arr1[j];
                        j++;
                    }
                }
                k++;
            }
            for(int x=0; x<len; x++){
                arr1[x+lo] = array[x];
            }
        }
    }
    //]
    public static void testParition()
    {
        System.out.println("testParition"); 
        int[] arr1 = {2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  

    } 
    public static void test2()
    {
        System.out.println("test2"); 
        int[] arr1 = {2, 3};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    }
    public static void test3()
    {
        System.out.println("test3"); 
        int[] arr1 = {3, 2, 1, 5, 2, 6};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    } 
    public static void test1()
    {
        System.out.println("test1"); 
        int[] arr1 = {2};                

        int lo = 0;
        int hi = arr1.length-1;
        quickSort(arr1, lo, hi);
        Aron.printArray(arr1);  
    } 
    public static void quickSort(int[] arr, int lo, int hi){
        if(lo < hi){
            int p = partition(arr, lo, hi);
            quickSort(arr, lo, p-1);
            quickSort(arr, p+1, hi);
        }
    }
    public static int partition(int[] arr, int lo, int hi){
        int len = hi - lo + 1;
        int bigger = lo;
        if(len > 1){
            int pivot = arr[hi];
            for(int i=lo; i<len; i++){
                if(arr[i] < pivot){  
                    swap(arr, bigger, i);
                    bigger++;
                } 
            }
            swap(arr, bigger, hi);
        }
        return bigger;
    }
    public static void swap(int[] arr, int i, int j){
        int tmp  = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
    public static int[] fun()
    {
        int[] array = {1, 2};
        return array;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class RemoveSpace 
{
	public static void main(String args[])
	{
		System.out.println("n=");
		String str = RemoveSpace(" ");
		System.out.println("str=[" + str + "]");
	}
	public static String RemoveSpace(String str)
	{
		String s="";
		if( str != null)
		{
			int len = str.length();
			if(len == 1)
			{ if(str.charAt(0) != ' ')	s = str; }
			else if( len > 1)
			{ String w="";
				if(str.charAt(0) != ' ')
					w = str.charAt(0) + "";
				for(int i=1; i<len; i++)
				{ if(str.charAt(i) != ' ')
						w = w + str.charAt(i);
					else if(str.charAt(i-1) != ' ')
					{ if(s.equals(""))
						{ s = w; w="";}
						else 
						{
							s = s + " " + w;
							w = "";
						}
					}
				}
				if(!w.equals(""))
					s = s + " " + w;
			}
		}
		return s;
	}
}
//[ java regular expression example ]//
//[ java regular expression tutorial ]//

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.HashMap;
import java.util.Map;

public class ReplaceMultiString {
    public static void main( String args[] ) {
        // java regular, java regex, jregex
        Map<String, String> replacements = new HashMap<String, String>() {
            {
                put(":", "colon");
                put("#", "number_sign");
                put("$", "dollar");
            }
        };

        String input = "$dog";

        String regexp = "\\$";
        StringBuffer sb = new StringBuffer();
        Pattern pattern = Pattern.compile(regexp);
        Matcher match = pattern.matcher(input);

        while(match.find()) {
            match.appendReplacement(sb, replacements.get(match.group()));
        }
        match.appendTail(sb);
        System.out.println(sb.toString());
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class ReverseSingleLinkedList {
    public static void main(String args[]) {
        test0();
        test1();
        test2();
    }
    static void test0(){
        Aron.beg();
        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);

        s.append(n1);
        s.append(n2);
        s.append(n3);
        s.print();
        Node head = ReverseIterationClone(s.head);
        s.Remove(n1);
        s.Remove(n2);
        Print.pbl("Clone and Reverse the list");
        Aron.printSLL(head);
        Ut.l();
        Print.pbl("Original List");
        Aron.printSLL(s.head);
        Aron.end();
    }
    static void test1(){
        Aron.beg();

        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        s.append(n1);
        s.append(n2);
        s.append(n3);
        s.print();
        Ut.l();
        Node head = Reverse3(s.head);
        Aron.printSLL(head);

        Aron.end();
    }
    static void test2(){
        Aron.beg();

        SingleLinkedList s = new SingleLinkedList();
        Node n1 = new Node(1);
        s.append(n1);
        s.print();
        Ut.l();
        Node head = Reverse3(s.head);
        Aron.printSLL(head);

        Aron.end();
    }
    static Node head = null;
    public static Node Reverse(Node curr) {
        if(curr != null) {
            Node node = Reverse(curr.next);
            if(node != null) {
                node.next = curr;
                curr.next = null;
            } else {
                head = curr;
            }
        }
        return curr;
    }

    public static Node Reverse2(Node curr) {
        Node tmp = null;
        if(curr == null)
            return null;
        else if(curr.next == null)
            return curr;
        else {
            tmp = Reverse2(curr.next);
            curr.next.next = curr;
            curr.next = null;
        }
        return tmp;
    }

    public static Node Reverse3(Node curr) {
        Node tmpHead = null;
        if(curr != null){
            tmpHead = Reverse3(curr.next);
            if(tmpHead == null)
                tmpHead = curr;
            else{
                curr.next.next = curr;
                curr.next = null;
            }
        }
        return tmpHead;
    }
    // Modified the original list
    public static Node ReverseOriginalList(Node head) {
        Node prev = null;
        Node curr = head;
        while(curr != null) {
            Node tmpNext = curr.next;
            curr.next = prev;
            prev = curr;
            curr = tmpNext;
        }
        return prev;
    }
    //Clone the original list and reverse it
    public static Node ReverseIterationClone(Node head) {
        Node curr = head;
        Node prev = null;
        Node newCurr = null;
        Node newPrev = null;
        while(curr != null) {
            newCurr = new Node(curr.data);

            Node newNext = newCurr.next;
            newCurr.next = newPrev;

            newPrev = newCurr;
            newCurr = newNext;
            curr = curr.next;
        }
        return newPrev; //return head
    }
    public static Node ReverseCloneStack(Node mycurr) {
        Stack<Node> st = new Stack<Node>();
        Node curr = mycurr;
        while(curr != null) {
            Print.pbl(curr.data);
            st.push(curr);
            curr = curr.next;
        }
        Ut.l();

        Node head = null;
        Node newPrev = null;
        Node newCurr = null;
        while(!st.isEmpty()) {
            newCurr = new Node(st.pop().data);
            if(newPrev != null)
                newPrev.next = newCurr;
            else
                head= newCurr;
            newPrev = newCurr;
        }
        return head;

    }
    public static Node ReverseClone(Node head) {
        Node curr = head;
        Node prev = null;
        Node newCurr = null;
        Node newPrev = null;
        while(curr != null) {
            newCurr = new Node(curr.data);

            curr.next = prev;
            newCurr.next = newPrev;

            prev = curr;
            curr = curr.next;
            newPrev = newCurr;
            newCurr = newCurr.next;
        }
        return newPrev;
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseStr
{
	public static void main(String args[])
	{
		int i = 0;
		System.out.println("s=" + RevStr("", i));
		System.out.println("s1=" + RevStr("a", i));
		System.out.println("s2=" + RevStr("ab", i));
		System.out.println("s3=" + RevStr("ab ", i));
	}
	public static String RevStr(String str, int i)
	{
		String s="";
		if(str != null)
		{
			if(str.length() == 1)
				s = str;
			else if(str.length() > 1 && i < str.length())
			{
				s = RevStr(str, i+1) + str.charAt(i);
			}
		}
		return s;
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseStrIte
{
	public static void main(String args[])
	{
		int i = 0;
		System.out.println("s3=" + RevStr("ab"));
	}
	public static String RevStr(String str)
	{
		char[] chArr=null;
		if( str != null)
		{
			chArr = str.toCharArray();
			int len = str.length();
			for(int i=0; i<len/2; i++)
			{
				char tmp = chArr[i];
				chArr[i] = chArr[len-1-i];
				chArr[len-1-i] = tmp;
			}
		}
		return new String(chArr);
	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

class ReverseStrings{
    public static void main(String args[]) {
        test0();
    }
    static void test0(){
        Aron.beg();
        String str = "dog and cat hello world";
        reverseString(str);
        Aron.end();
    }
    public static void reverseString(String str){
        StringBuilder sb = new StringBuilder(str);
        StringBuilder word = new StringBuilder();
        if(str != null){
            int len = str.length();
            for(int i=0; i<len/2; i++){
                char tmp = sb.charAt(i);
                sb.setCharAt(i, sb.charAt(len-1-i));
                sb.setCharAt(len-1-i, tmp);
            }
            Print.pbl(sb.toString());
            String s = "";
            for(int i=0; i<len; i++){
                if(sb.charAt(i) != ' '){
                    word.append(sb.charAt(i));
                }else{
                    Print.pbl(word.reverse());
                    word.delete(0, word.length()); 
                }
            } 
            if(word.length() > 0)
                Print.pbl(word.reverse());
        }
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;
class ReverseWord
{
	public static void main(String args[])
	{
		int k = 0;
		String s = ReverseWord("", k);
		System.out.println("s=" + s);
	}
	public static String ReverseWord(String str, int k)
	{
		String s = "";
		for(int i = k; i < str.length(); i++)
		{
			if((str.charAt(i)==' ') && !s.equals(""))
			{
				return ReverseWord(str, i+1) + " " + s;
			}
			else if(str.charAt(i) != ' ')
				s = s + Character.toString(str.charAt(i));
		}
		return s;

	}
}
import java.io.*;
import java.lang.String;
import java.util.*;
class RotateMatrix90 
{
	public static void main(String args[])
	{
		System.out.println("n2=");
        test1();
		System.out.println();
        test2();
        System.out.println();
        test3();
        System.out.println();
        test4();
	}

	//rotate matrix clockwise 90
	public static int[][] rotateMatrixClockwise90(int[][] A)
	{
		if(A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][i];
					A[k][i] = A[nRow-1-i][k];
					A[nRow-1-i][k] = A[nRow-1-k][nRow-1-i];
					A[nRow-1-k][nRow-1-i] = A[i][nRow-1-k];
					A[i][nRow-1-k] = tmp;
				}
		}
		return A;
	}

	//rotate matrix counterclockwise 90
	public static int[][] rotatecounterclockwise90(int[][] A)
	{
		if( A != null)
		{
			int nRow = A.length;
			int nCol = A[0].length;
			for(int k=0; k<nRow/2; k++)
			{
				for(int i=k; i<nRow-1-k; i++)
				{
					int tmp = A[k][nRow-1-i];
					A[k][nRow-1-i] = A[nRow-1-i][nRow-1-k];
					A[nRow-1-i][nRow-1-k]=A[nRow-1-k][i];
					A[nRow-1-k][i]=A[i][k];
					A[i][k]=tmp;
				}
			}
		}
		return A;
	}

    //Rotate matrix counterclosewise 90 recursively 
    public static void rotatecounterclockwise90Recursion(int[][] arr, int depth)
    {
        if(arr != null)
        {
            int len = arr.length;
            for(int i=depth; i<len-1-depth; i++)
            {
                int tmp = arr[depth][i];
                arr[depth][i] = arr[len-1-i][depth];
                arr[len-1-i][depth] = arr[len-1-depth][len-1-i];
                arr[len-1-depth][len-1-i] = arr[i][len-1-depth];
                arr[i][len-1-depth] = tmp;
            }
            if(len - 2*depth > 1)
                rotatecounterclockwise90Recursion(arr, depth+1);
        }
    }

    //Rotate matrix clockwise 90 recursively 
    public static void rotateClockWise90Recursion(int[][] arr, int depth)
    {
        if(arr != null)
        {
            int len = arr.length;
            for(int i=depth; i<len-1-depth; i++)
            {
                int tmp = arr[depth][len-1-i];
                arr[depth][len-1-i] = arr[len-1-i][len-1-depth];
                arr[len-1-i][len-1-depth] = arr[len-1-depth][i];
                arr[len-1-depth][i] = arr[i][depth];
                arr[i][depth] = tmp;
            }
            if(len - 2*depth > 1)
                rotateClockWise90Recursion(arr, depth+1);
        }
    }

    public static void test1()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

        int depth = 0;
		rotatecounterclockwise90Recursion(A, depth);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }

    public static void test2()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

        int depth = 0;
		rotateClockWise90Recursion(A, depth);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }
    public static void test3()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotatecounterclockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

    }
    public static void test4()
    {
        Random ran = new Random();
		int nRow = 4;
		int nCol = 4;
		int[][] A = new int[nRow][nCol];
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				A[i][j] = ran.nextInt(10);
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}

		rotateMatrixClockwise90(A);
		System.out.println();
		for(int i=0; i<nRow; i++)
		{
			for(int j=0; j<nCol; j++)
			{
				System.out.print("["+A[i][j]+"]");
			}
			System.out.println();
		}
    }
}
import java.util.ArrayList;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector; 
import classfile.*;

public class RotatedSortedArray{
    public static void main(String[] args) {
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test0_findMinIndexNew();
        test1_findMinIndexNew();
        test2_findMinIndexNew();
        test3_findMinIndexNew();
        test4_findMinIndexNew();
    }

    static void test1(){
        Aron.beg();
        int[] arr = {4, 3, 2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);

        Aron.end();
    }


    static void test2(){
        Aron.beg();
        int[] arr = {1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 1);
        Aron.end();
    } 

    static void test3(){
        Aron.beg();
        int[] arr = {3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);
        Aron.end();
    } 

    static void test4(){
        Aron.beg();
        int[] arr = {3, 4, 5, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 2);

        Aron.end();
    }

    static void test5(){
        Aron.beg();
        int[] arr = {3, 4, 5, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinIndexNegative(negative(arr), lo, hi);
        Test.t(index, 3); 

        Aron.end();
    }

    static void test6(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaxIndex(arr, lo, hi);
        Test.t(index, 0);

        Aron.end();
    }

    //[ file=RotatedSortedArray.html title=""
    // assume there is not duplicated number in the array
    // find the index of maximum value in the rotated sorted array
    public static int findMaxIndex(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] < arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;
                if(arr[lo] < arr[mid])
                    return findMaxIndex(arr, mid, hi);
                else
                    return findMaxIndex(arr, lo, mid);
            }
        }
        return -1;
    }
    //]

    // negative all values in the array
    public static int[] negative(int[] arr) {
        int[] tmpArr = new int[arr.length];
        int c=0;
        for(int e: arr) {
            tmpArr[c] = -e;
            c++;
        }
        return tmpArr;
    }

    // find the mininum index from a rotated sorted array
    public static int findMinIndex(int[] arr, int lo, int hi) {
        return findMaxIndex(arr, lo, hi);
    }
    
    public static int findMinIndexNegative(int[] arr, int lo, int hi) {
        if(arr != null) {
            if(arr[lo] > arr[hi] || lo == hi)
                return hi;
            else {
                int mid = (lo + hi)/2;

                if(arr[lo] < arr[mid])
                    return findMinIndexNegative(arr, mid, hi);
                else
                    return findMinIndexNegative(arr, lo, mid);
            }
        }
        return -1;
    }

    static void test0_findMinIndexNew(){
        Aron.beg();
        int[] arr = {1, 2, 3, 4}; 
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinIndexNew(arr, lo, hi);
        Test.t(findMinIndexNew(arr, lo, hi), 0);

        Aron.end();
    }
    static void test1_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 3);

        Aron.end();
    }
    static void test2_findMinIndexNew(){
        Aron.beg();
        int[] arr = {1, 2}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 0);

        Aron.end();
    }
    static void test3_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 1);

        Aron.end();
    }
    static void test4_findMinIndexNew(){
        Aron.beg();
        int[] arr = {2, 3, 1}; 
        int lo = 0;
        int hi = arr.length - 1;
        Test.t(findMinIndexNew(arr, lo, hi), 2);

        Aron.end();
    }

    public static int findMinIndexNew(int[] arr, int lo, int hi){
        if(arr != null){
            if(arr[lo] < arr[hi] || lo == hi)
                return lo;
            else{
                int mid = 0;
                if((lo + hi) % 2 == 1)
                    mid = ((lo + hi)/2) + 1;
                else 
                     mid = (lo + hi)/2;

                if(arr[mid] < arr[hi])
                    return findMinIndexNew(arr, lo, mid);
                else
                    return findMinIndexNew(arr, mid, hi);
            }
        }
        return -1;
    }

}
import java.util.*;
import java.io.*;
import classfile.*;

public class RotatedSortedArrayMaxMin{
    public static void main(String[] args) {
        test00_min();
        test0_min();
        test1_min();
        test2_min();
        test3_min();
        test4_min();
        test5_max();
        test6_max();
        test7_max();
        test8_max();
    }
    public static void test00_min(){
        Aron.beg();
        int[] arr = {1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test0_min(){
        Aron.beg();
        int[] arr = {1, 2, 3, 4};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test1_min(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test2_min(){
        Aron.beg();
        int[] arr = {3, 1, 2};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test3_min(){
        Aron.beg();
        int[] arr = {4, 1, 2, 3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 1);
        Aron.end();
    }
    public static void test4_min(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMinimumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 3);
        Aron.end();
    }

    // find the index of minimum element of an array
    public static int findMinimumIndex(int[] arr, int lo, int hi){
        if( arr[lo] <= arr[hi])
            return lo;
        else{
            // [2, 1]
            // [3, 1, 2]
            // =>[3, 1] => [1]
            int mid = (lo + hi)/2;
            if(arr[lo] < arr[mid])
                return findMinimumIndex(arr, mid, hi);
            else if(arr[lo] > arr[mid])
                return findMinimumIndex(arr, lo, mid);
            else 
                return hi;
        }
    }
    public static int findMaximumIndex(int[] arr, int lo, int hi){
        if(arr[lo] <= arr[hi])
            return hi;
        else{
            // [2, 1]
            int mid = (lo + hi)/2;
            if( arr[lo] < arr[mid])
                return findMaximumIndex(arr, mid, hi);
            else if(arr[lo] > arr[mid]) 
                return findMaximumIndex(arr, lo, mid);
            else
                return lo;
        }
    }
    public static void test5_max(){
        Aron.beg();
        int[] arr = {2, 3, 4, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 2);
        Aron.end();
    }
    public static void test6_max(){
        Aron.beg();
        int[] arr = {2, 1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test7_max(){
        Aron.beg();
        int[] arr = {1};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }
    public static void test8_max(){
        Aron.beg();
        int[] arr = {4, 1, 2, 3};
        int lo = 0;
        int hi = arr.length - 1;
        int index = findMaximumIndex(arr, lo, hi);
        Print.pbl("index=" + index);
        Test.t(index == 0);
        Aron.end();
    }

} 

import java.io.*;
import java.lang.String;
import java.util.*;
class Search2DMatrix 
{
	public static void main(String args[])
	{
		int[][] Arr = new int[1][3];
		gen2D(Arr);
		int right=0;
		int down=Arr.length-1;
		int key=2;
		boolean found = Search2DRecur(Arr, right, down, key);

		if(found)
			System.out.println("found key=" + key);
		else 
			System.out.println("not found key="+key);
	}

	public static void gen2D(int[][] Arr)
	{
		int row, col;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;
			Arr[0][0] = 0;
			Random r = new Random();
			for(int i=0; i<row; i++)
			{
				int ran = r.nextInt(3); 
				for(int j=0; j<col; j++)
				{
					if(i-1>=0 && j-1>=0)
					Arr[i][j] = Arr[i-1][j]+ Arr[i][j-1]+ran;
					else if(j-1>=0)
						Arr[i][j] = Arr[i][j-1]+ran;
					else if(i-1>=0)
						Arr[i][j] = Arr[i-1][j]+ran;

					System.out.print(String.format("%10s", Arr[i][j]));
				}
				System.out.println();
			}
		}
	}
	public static boolean Search2D(int[][] Arr, int key)
	{
		int row, col;
		boolean found=false;
		if(Arr != null)
		{
			row = Arr.length;
			col = Arr[0].length;

			int right = 0;
			int down = row-1;
			while(right < col && down >= 0 && !found)
			{
				if(key > Arr[down][right])
						right++;
				else if(key < Arr[down][right])
                        down--;
				else if(key == Arr[down][right])
				{
					found = true;
					System.out.println("found Arr["+down+"]["+right+"]="+Arr[down][right]);
				}
			}
			if(!found)
					System.out.println("not fund key=" + key);
		}
		return found;
	}

	//right = 0;
	//down = row-1; 
	
	public static boolean Search2DRecur(int[][] Arr, int right, int down, int key)
	{
		if(Arr != null && right < Arr[0].length && down >= 0)
		{
			if(key > Arr[down][right])
				return Search2DRecur(Arr, right+1, down, key);			
			else if(key < Arr[down][right])
				return Search2DRecur(Arr, right, down-1, key);			
			else 
				return true;
		}
		return false;
	}
	
}
import java.io.*;
import java.lang.String;
import java.util.*;
import classfile.*;

public class SerializeBinary {
    public static void main(String[] args) {
        test_serializeLevel();
        test_deserializeBinary();
        test1_deserializeIterator();
        test2_deserializeIterator();
        test_deSerializeIndex();
        test1_deSerializeIndex();
    }
    static void test_serializeLevel(){
        Aron.beg();
       
        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        Aron.inorder(bin.root);
        Aron.line();
        try {
            BufferedWriter out1 = new BufferedWriter(new FileWriter("text/level0.txt"));

            serializeLevel(bin.root, out1);
            out1.close();

            BufferedReader levelIn = new BufferedReader(new FileReader("text/level0.txt"));

            List<List<String>> list = createMap(levelIn);
            int depth = 0;
            
            Map<String, Node> map = new HashMap<String, Node>(); 
            Node root = deserializeLevel(list, map);
            Aron.line();
            Aron.inorder(root);
        } catch(Exception e) {
        }
        Aron.end();
    }
    
    static void test1_deserializeIterator(){
        Aron.beg();
        BST bin = new BST();
        bin.insert(10);
        bin.insert(11);

        try {
            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            List<String> list = Aron.readFileOneLineSplit("text/out.txt");
            Iterator<String> ite = list.iterator();
            Node root = deserializeIterator(ite);

            Aron.inorder(root);

        } catch(Exception e) {
        }

        Aron.end();
    } 

    static void test2_deserializeIterator(){
        Aron.beg();
        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        try {
            Aron.inorder(bin.root);
            Aron.line();

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            List<String> list = Aron.readFileOneLineSplit("text/out.txt");
            Iterator<String> ite = list.iterator();
            Node root = deserializeIterator(ite);

            Aron.inorder(root);

        } catch(Exception e) {
        }

        Aron.end();
    } 
    
    static void test_deserializeBinary(){
        Aron.beg();

        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        try {
            Aron.inorder(bin.root);

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));

            int[] A = new int[1];
            A[0] = 0;
            String[] Array = readFile(in);
            Node root = deserializeBinary(Array, A);
            Aron.inorder(root);
        } catch(Exception e) {
        }

        Aron.end();
    }

    static void test_deserializeBinary3(){
        Aron.beg();

        BST bin = new BST();
        bin.insert(10);
        bin.insert(5);
        bin.insert(15);
        bin.insert(12);

        System.out.println("");
        try {
            Aron.inorder(bin.root);

            BufferedWriter out = new BufferedWriter(new FileWriter("text/out.txt"));
            serializeBinary(bin.root, out);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));

            String[] Array = readFile(in);
            Node root = deserializeBinary3(Array);
            Aron.inorder(root);
        } catch(Exception e) {
        }

        Aron.end();
    }

    //Use Level order to write node to file
    public static void serializeLevel(Node root, BufferedWriter out1) {
        try {
            if(root != null) {
                Queue<Node> q1 = new LinkedList<Node>();
                Queue<Node> q2 = new LinkedList<Node>();
                q1.add(root);
                while(q1.peek() != null || q2.peek() != null) {
                    while(q1.peek() != null) {
                        String s = "";
                        Node node = q1.remove();
                        s += node.data + " ";
                        if(node.left != null) {
                            s += node.left.data + " ";
                            q2.add(node.left);
                        } else
                            s += "#" + " ";
                        if(node.right != null) {
                            s += node.right.data + " ";
                            q2.add(node.right);
                        } else
                            s += "#" + " ";

                        s += "\n";
                        out1.write(s);
                    }

                    while(q2.peek() != null) {
                        String s = "";
                        Node node = q2.remove();
                        s += node.data + " ";
                        if(node.left != null) {
                            s += node.left.data + " ";
                            q1.add(node.left);
                        } else
                            s += "#" + " ";
                        if(node.right != null) {
                            s += node.right.data + " ";
                            q1.add(node.right);
                        } else
                            s += "#" + " ";

                        s += "\n";
                        out1.write(s);
                    }
                }

            }
        } catch(Exception e) {
        }
    }

    public static List<List<String>> createMap(BufferedReader in) {
        List<List<String>> list = new ArrayList<List<String>>();
        try {
            String line = null;
            while((line = in.readLine()) != null) {
                line = line.trim();
                String[] array = line.split("\\s+");
                if(array != null && array.length == 3) {
                    list.add(Arrays.asList(array));
                }
            }
        } catch(Exception e) {
        }
        return list;
    }

    public static String[] readFile(BufferedReader in) {
        String[] Array = null;
        try {
            String str;
            boolean end = false;
            while( (str = in.readLine()) != null && !end) {
                System.out.println(str);
                Array = str.split("\\s");
                end = true;
            }
            in.close();

            for(int i=0; Array != null && i<Array.length; i++) {
                System.out.println("["+Array[i]+"]");
            }

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        return Array;
    }

    public static Node deserializeLevel(List<List<String>> listList, Map<String, Node> map) {
        Node root = null;
        for(List<String> list : listList){
            if(root == null){
                root = new Node(Integer.parseInt(list.get(0)));
                map.put(list.get(0), root);

                String left = list.get(1);
                if(!left.equals("#")){
                    Node node =  new Node(Integer.parseInt(left));
                    root.left = node;
                    map.put(left, node);
                }

                String right = list.get(2);
                if(!right.equals("#")){
                    Node node =  new Node(Integer.parseInt(right));
                    root.right = node;
                    map.put(right, node);
                }
            }
            else{
                Node curr = map.get(list.get(0));
                if(curr == null){
                    curr = new Node(Integer.parseInt(list.get(0)));
                    map.put(list.get(0), curr);
                }

                String left = list.get(1);
                if(!left.equals("#")){
                    Node node =  new Node(Integer.parseInt(left));
                    curr.left = node;
                    map.put(left, node);
                }

                String right = list.get(2);
                if(!right.equals("#")){
                    Node node =  new Node(Integer.parseInt(right));
                    curr.right = node;
                    map.put(right, node);
                }
            }
        }
        return root;
    }

    public static Node deserializeBinary(String[] Array, int[] A) {
        Node root = null;
        if(Array != null && A[0] < Array.length) {
            if(!Array[A[0]].equals("#")) {
                root = new Node(Integer.parseInt(Array[A[0]]));
                A[0]++;
                root.left = deserializeBinary(Array, A);
                A[0]++;
                root.right = deserializeBinary(Array, A);
            }
        } else {
            Print.pbl("root is null");
        }
        return root;
    }

    static int index = 0;
    public static Node deserializeBinary3(String[] Array) {
        Node root = null;
        if(Array != null && index < Array.length) {
            if(!Array[index].equals("#")) {
                root = new Node(Integer.parseInt(Array[index]));
                index++;
                root.left = deserializeBinary3(Array);
                index++;
                root.right = deserializeBinary3(Array);
            }
        } else {
            Print.pbl("root is null");
        }
        return root;
    }

    //[ file=serializebin.html title=""
    public static void serializeBinary(Node root, BufferedWriter out) {
        try {
            if(root != null) {
                out.write(root.data + " ");
                serializeBinary(root.left, out);
                serializeBinary(root.right, out);
            } else {
                out.write("# ");
            }
        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
    }
    public static Node deserializeIterator(Iterator<String> ite) {
        Node root = null;
        if(ite.hasNext()) {
            String token = ite.next();
            if(!token.equals("#")) {
                root = new Node(Integer.parseInt(token));
                root.left = deserializeIterator(ite);
                root.right = deserializeIterator(ite);
            }
        } 
        return root;
    }
    //]

    public static void test_deSerializeIndex() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(15);
        b1.insert(12);
        b1.insert(14);
        b1.insert(17);
        b1.insert(19);
        b1.insert(130);
        b1.insert(16);
        b1.insert(10);

        Aron.inorder(b1.root);
        Aron.line();

        try {
            FileWriter fstream = new FileWriter("text/out.txt");
            BufferedWriter out = new BufferedWriter(fstream);
            int k=0;
            serializeIndex(b1.getRoot(), out, k);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out.txt"));
            Map<Integer, Integer> map = buildMapFromFile(in);

            k = 0;
            Node root = deSerializeIndex(map, k);
            Aron.inorder(root);

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        Aron.end();
    }

    public static void test1_deSerializeIndex() {
        Aron.beg();
        BST b1 = new BST();
        b1.insert(10);
        b1.insert(5);
        b1.insert(15);
        b1.insert(12);

        Aron.inorder(b1.root);
        Aron.line();

        try {
            FileWriter fstream = new FileWriter("text/out1.txt");
            BufferedWriter out = new BufferedWriter(fstream);
            int k=0;
            serializeIndex(b1.getRoot(), out, k);
            out.close();

            BufferedReader in = new BufferedReader(new FileReader("text/out1.txt"));
            Map<Integer, Integer> map = buildMapFromFile(in);

            k = 0;
            Node root = deSerializeIndex(map, k);
            Aron.inorder(root);

        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        Aron.end();
    }

    //Write nodes to file with inorder traversal
    public static void serializeIndex(Node root, BufferedWriter out, int k) {
        if(root != null) {
            String s = k + ":" + root.data + "\n";
            try {
                serializeIndex(root.left, out, 2*k + 1);
                out.write(s);
                serializeIndex(root.right, out, 2*k + 2);
            } catch(Exception e) {
                System.err.println("Error" + e.getMessage());
            }
        }
    }
    //Initialize k = 0 
    public static Node deSerializeIndex(Map<Integer,Integer> map, int k) {
        if(map.containsKey(k)) {
            Integer data = map.get(k);
            Node root = new Node(data);
            root.left = deSerializeIndex(map, 2*k + 1);
            root.right = deSerializeIndex(map, 2*k + 2);
            return root;
        }
        return null;
    }

    public static Map<Integer,Integer> buildMapFromFile(BufferedReader in) {
        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        try {
            String line = null;
            while((line = in.readLine()) != null) {
                line = line.trim();
                String[] array = line.split(":");
                if(array.length == 2) {
                    map.put(Integer.parseInt(array[0]), Integer.parseInt(array[1]));
                } else
                    System.err.println("Error: invalid file format");
            }
        } catch(Exception e) {
            System.err.println("Error" + e.getMessage());
        }
        return map;
    }
}
//Traveral binary tree in level order store it in HashMap
//Reconstruct the binary tree from HashMap
//
//      [p]
//[2*p+1] [2*p+2]
//

import java.util.*;
import classfile.*;

public class SerializeBinaryLevelOrder {
    public static void main(String[] args) {
        test0();        
        test1();        
        test2();        
        test3();        
        test4();        
        test5();        
    }
    static void test0(){
        Aron.beg();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();
        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        Aron.preorder(bt.root);
        levelOrder(bt.root);
        map = levelOrder(bt.root);

        BST newbt = new BST();
        int key = 0;
        newbt.root = buildBinaryTree(map, key);
        Aron.inorder(newbt.root);

        Aron.end();
    }
    static void test1(){
        Aron.beg();

        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        Aron.inorder(bt.root);
        levelOrder2(bt.root);

        Aron.end();
    }

    static void test2(){
        Aron.beg();
        //System.out.println(String.format("[%-20s]=[%s]" , "label", "content" ));
        System.out.println(String.format("[%-20s]=[%s]" , 9, "content" ));
        for(int i=0; i<5; i++){
            System.out.println(String.format("[%1$05d]" , i));
        } 
        Aron.end();
    } 
    
    static void test3(){
        Aron.beg();
        padding();
        Aron.end();
    }

    static void test4(){
        Aron.beg();

        for(int i=0; i< 5; i++){
            String str = "%1$-" + (i + 1) + "s";
            String value = String.format(str, i);
            System.out.println("["+ value + "]");
        } 
        Aron.end();
    }
    static void test5(){
        Aron.beg();

        BST bt = new BST();
        bt.insert(10);
        bt.insert(5);
        bt.insert(15);
        bt.insert(12);
        bt.insert(20);

        int level = level(bt.root);
        System.out.println("level[" + level + "]");
        for(int i=1; i<=level; i++){
            prettyPrint(bt.root, i);
            System.out.println();
        } 
        Aron.end();
    }
    static int level(Node root){
        if(root != null){
            return Math.max(level(root.left), level(root.right)) + 1;
        }
        return 0;
    }

    static void prettyPrint(Node r, int level){
        if(r != null){
                //String format = "%1$-" + level + "s";
                String format = "%1$" + (level + 10) + "s";
                String str = "[" + r.data + "]";
                System.out.print(String.format(format, str));

            prettyPrint(r.left, level - 1);
            prettyPrint(r.right, level - 1);
        }
    }

    static void padding(){
        String[] left  = {"Technology", "Technic", "Technologies", "Technisian"};
        String[] right = {"Continuous", "Continua", "Continuously", "Continuation"};
        for(int i=0; i< left.length; i++){
            String str = "%1$-" + (i + 4) + "s";
            //System.out.println("str[" + str + "]");
            //String value = String.format("%1$-15s %2$15s", left[i], right[i]);
            String value = String.format(str + " %2$15s", left[i], right[i]);
            System.out.println("[" + value + "]");
        } 
    }

    public static Node buildBinaryTree(Map<Integer, Integer> map, int key) {
        Node root = null;
        if(map.containsKey(key)) {
            root = new Node((Integer)map.get(key));
            map.remove(key);
            root.left   = buildBinaryTree(map, 2*key+1);
            root.right  = buildBinaryTree(map, 2*key+2);
        }
        return root;
    }

    public static void levelOrderRecursion(Queue<Node> q, Map<Integer, Integer> map, int k) {
        Queue<Node> tmpQueue = new LinkedList<Node>();
        while(q.peek() != null) {
            Node node = q.remove();
            map.put(k, node.data);
            if(node.left != null)
                tmpQueue.add(node.left);
            if(node.right != null)
                tmpQueue.add(node.right);
        }
        if(tmpQueue.peek() != null)
            levelOrderRecursion(tmpQueue, map, k);
    }

    
    public static void levelOrder2(Node curr) {
        if(curr != null){
            Queue<Node> q1 = new LinkedList<Node>();
            Queue<Node> q2 = new LinkedList<Node>();
            q1.add(curr);
            while(!q1.isEmpty() || !q2.isEmpty()){

                while(!q1.isEmpty()){
                    Node node = q1.remove();
                    System.out.println("[" + node.data + "]");
                    if(node.left != null)
                        q2.add(node.left);
                    if(node.right != null)
                        q2.add(node.right);
                }

                while(!q2.isEmpty()){
                    Node node = q2.remove();
                    System.out.println("[" + node.data + "]");

                    if(node.left != null)
                        q1.add(node.left);
                    if(node.right != null)
                        q2.add(node.right);
                }
            }
        }
    }
    public static Map<Integer, Integer> levelOrder(Node root) {
        Queue<Node> queue1 = new LinkedList<Node>();
        Queue<Node> queue2 = new LinkedList<Node>();
        Queue<Integer> numq1 = new LinkedList<Integer>();
        Queue<Integer> numq2 = new LinkedList<Integer>();
        Map<Integer, Integer> orderedMap = new LinkedHashMap<Integer, Integer>();

        Map<Integer, Integer> map = new HashMap<Integer, Integer>();

        int parentIndex = -1;
        int[] Array = new int[20];
        if(root != null) {
            parentIndex= 0;
            System.out.println("here");
            queue1.add(root);
            numq1.add(parentIndex);
        }
        while(queue1.peek() != null || queue2.peek() != null) {
            while(queue1.peek() != null) {
                Node no = queue1.remove();
                parentIndex = numq1.remove();
                map.put(parentIndex, no.data);
                orderedMap.put(parentIndex, no.data);

                System.out.print("["+no.data+"]");
                System.out.print(" parentIndex="+parentIndex);
                if(no.left != null) {
                    queue2.add(no.left);
                    numq2.add(2*parentIndex+1);
                }
                if(no.right != null) {
                    queue2.add(no.right);
                    numq2.add(2*parentIndex+2);
                }
            }
            System.out.println("");
            while(queue2.peek() != null) {
                Node no = queue2.remove();
                parentIndex = numq2.remove();
                map.put(parentIndex, no.data);
                orderedMap.put(parentIndex, no.data);

                System.out.print("["+no.data+"]");
                System.out.print(" parentIndex="+parentIndex);
                if(no.left != null) {
                    queue1.add(no.left);
                    numq1.add(2*parentIndex+1);
                }
                if(no.right != null) {
                    queue1.add(no.right);
                    numq1.add(2*parentIndex+2);
                }
            }
            System.out.println("");
        }
        return map;
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

public class SerializeGeneralTree{
    public static void main(String[] args) {
        test0();
        test1();
    }
    public static void test0(){
        Aron.beg();
        String file = "./text/try.txt";
        
        try{
            Node r = Aron.createGeneralTree();
            Aron.inorderGeneralTree(r);
            Ut.l();
            BufferedWriter bw = new BufferedWriter(new FileWriter(file));
            serializeGeneralTree(r, bw);
            bw.close();
            
            List<String> list = Aron.readFileOneLineSplit(file);
            Aron.printlnList(list);

            Ut.l();
            Node dr = deserializeGeneralTree(list);
            Aron.inorderGeneralTree(dr);
        }catch(IOException e){
        }
        Aron.end();
    }
    public static void test1(){
        Aron.beg();
        Aron.end();
    }

    public static void serializeGeneralTree(Node r, BufferedWriter bw){
        if(r != null){
            try{
            bw.write(r.data + " ");
            for(Node n : r.list)
                serializeGeneralTree(n, bw);

            bw.write(" # ");
            }catch(IOException e){
                e.printStackTrace();
            }
        }
    }

    // use one stack to deserialize general tree
    public static Node deserializeGeneralTree(List<String> list){ 
        Stack<Node> stack = new Stack<>();
        for(String s : list){
            if(!s.equals("#")){
                Node n = new Node(s);
                stack.push(n);
            }else{
                if(stack.size() > 1){
                    Node top = stack.pop();
                    stack.peek().list.add(top);
                }
            }
        }
        return stack.peek();
    }
} 

import java.util.*;
import java.io.*;
import java.util.stream.*;
import classfile.*;

//class NNode<T>{
//    public T data;
//    public List<NNode> list = new ArrayList<>();
//    public NNode(T data){
//        this.data = data;
//    }
//}

public class SerializeNaryTree{
    public static void main(String[] args) {
        //test0();
        test00();
        //test1();
//        test2();
//
//        test0_deserialize_debug();
//        test1_deserialize_debug();
//        test2_deserialize_debug();
//        test00_writeFile();
          //test01_readFile();
//        test10_deserialize();
//        test11_deserializeStack();
//        test12_deserializeStack();
//        test13_deserializeStack();
//        test02_buildTreeFromLevelOrder();
    }
    static void test0(){
        Aron.beg();
        Node root = new Node("1");
        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        int level = 0;
        Aron.prettyPrintGeneral(node, level);

        Aron.end();
    }
    static void test00(){
        Aron.beg();

        String fName = "file4.txt";
        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();
        Node root = deserialize(ite);
        int level = 0;
        Aron.prettyPrintGeneral(root, level);

        Aron.end();
    }

    static void test0_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");
        root.list.add(new Node("2"));
        root.list.add(new Node("3"));
        root.list.add(new Node("4"));
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test2_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");

        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");

        Node n35 = new Node("5");
        Node n36 = new Node("6");
        n3.list.add(n35);
        n3.list.add(n36);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test1_deserialize_debug(){
        Aron.beg();
        Node root = new Node("1");
        Node n1 = new Node("2");
        Node n2 = new Node("3");
        Node n3 = new Node("4");

        Node n4 = new Node("5");
        Node n5 = new Node("6");

        n3.list.add(n4);
        n3.list.add(n5);
        root.list.add(n1);
        root.list.add(n2);
        root.list.add(n3);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize_debug(ite);
        printNary(node);

        Aron.end();
    }
    static void test1(){
        Aron.beg();
        Node root = new Node("1");
        root.list.add(new Node("2"));
        root.list.add(new Node("3"));
        root.list.add(new Node("4"));

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        printNary(node);

        Aron.end();
    }
    static void test2(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        Node n4 = new Node("4");
        Node n5 = new Node("5");

        root.list.add(n2);
        root.list.add(n3);

        n3.list.add(n4);
        n3.list.add(n5);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserialize(ite);
        printNary(node);

        Aron.end();
    }
    static void test10_deserialize(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        Node n4 = new Node("4");
        Node n5 = new Node("5");

        root.list.add(n2);
        root.list.add(n3);

        n3.list.add(n4);
        n3.list.add(n5);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }

    static void test11_deserializeStack(){
        Aron.beg();

        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");

        root.list.add(n2);
        root.list.add(n3);

        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);
 

        Aron.end();
    }

    static void test12_deserializeStack(){
        Aron.beg();
        Node root = new Node("1");
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }
    static void test13_deserializeStack(){
        Aron.beg();

        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);
        printNary(root);

        String fName = "file4.txt";
        write(root, fName);

        List<String> list = read(fName);
        Aron.printList(list);
        Iterator<String> ite = list.iterator();

        Node node = deserializeStack(ite);
        printNary(node);

        Aron.end();
    }
    public static void printNary(Node curr){
        if(curr != null){
            Print.pbl(curr.data);
            for(int i=0; i<curr.list.size(); i++){
                printNary((Node)curr.list.get(i));
            } 
        }
    }

    public static void write(Node curr, String fname){
        if(fname != null){
            try(BufferedWriter bw = new BufferedWriter(new FileWriter(fname))){
                serialize(curr, bw);
            }catch(IOException e){
                System.out.println(e.getMessage());
            }
        }
    }
    public static List<String> read(String fname){
        List<String> list = null; 
        if(fname != null){
            try(BufferedReader br = new BufferedReader(new FileReader(fname))){
                String line; 
                while((line = br.readLine()) != null){
                    break;
                }
                list = Arrays.asList(line.trim().split("\\s+"));

                Aron.printList(list);
            }catch(IOException e){
                System.out.println(e.getMessage());
            }
        }
        return list;
    }
    //[ file=serializetree.html title=""
    // serialize n-ary tree from preorder to post order 
    public static void serialize(Node curr, BufferedWriter bw){
        if(curr != null){
            try{
                bw.write(curr.data + " ");
                for(Node node : curr.list){
                    serialize(node, bw);
                }
                bw.write("#" + " ");
            }catch(IOException e){
            }
        }
    }

    public static Node deserialize(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String token = ite.next();
            //Print.pbl("[" + token);
            if(!token.equals("#")){
                root = new Node(token);
                Node child = deserialize(ite);
                if(child != null)
                    root.list.add(child);
            }else{
                root = deserialize(ite);
            }
            //Print.pbl("]");
        }
        return root;
    }

    public static Node deserialize_debug(Iterator<String> ite){
        Node root = null;
        if(ite.hasNext()){
            String token = ite.next();
            if(!token.equals("#")){
                Print.p("[" + token);
                root = new Node(token);
                Node child = deserialize_debug(ite);
                if(child != null){
                    root.list.add(child);
                    Print.pbl(root.data + "->(" + child.data + ")");
                }
                Print.p("]");
            }else{
                Print.p("[" + token);
                root = deserialize_debug(ite);
                Print.p("]");
            }
        }
        return root;
    }
    //]

    //[ file=deserializetree.html title=""
    // deserialize with stack
    public static Node deserializeStack(Iterator<String> ite){
        Stack<Node> stack = new Stack<>(); 
        while(ite.hasNext()){
            String token = ite.next();
            if(!token.equals("#")){
                stack.push(new Node(token));
            }else{
                if(stack.size() > 1){
                    Node top = stack.pop();
                    Node peek = stack.peek();
                    peek.list.add(top);
                }
            }
        }
        return stack.peek();
    }
    //]

    public static void writeFile(Node r, String fName){
        try{
            BufferedWriter bw = new BufferedWriter(new FileWriter(fName));
            levelOrder(r, bw);
            bw.close();
        }catch(IOException ie){
            ie.printStackTrace();
        }
    }
    public static void levelOrder(Node r, BufferedWriter bw){
        if(r != null){
            try{
                Queue<Node> queue = new LinkedList<Node>(); 
                if(r != null){
                    queue.add(r);
                    while(!queue.isEmpty()){
                        Node node = queue.remove();
                        bw.write(node.data + ":");
                        for(Node n : node.list){
                            bw.write(n.data + ":");
                            queue.add(n);
                        }
                        bw.write("\n");
                    }
                }
            }catch(IOException ie){
                ie.printStackTrace();
            }
        }
    }
    public static Map<Integer, List<Integer>> readFile(String fName){
       Map<Integer, List<Integer>> map = new HashMap<>(); 
       if(fName != null){
           try{
               BufferedReader br = new BufferedReader(new FileReader(fName));
               String line = null;
               while((line = br.readLine()) != null){
                   List<String> strList = Arrays.asList(line.split(":"));
                   // Java 8 lambda expr
                   List<Integer> list = strList.stream().map(Integer::parseInt).collect(Collectors.toList());
                   if(list.size() > 0) 
                       map.put(list.get(0), list.size() > 1? list.subList(1, list.size()) : new ArrayList<Integer>());
               }
           }catch(IOException ie){
               ie.printStackTrace();
           }
       }
       return map;
    }
    
    static void test00_writeFile(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
        Aron.end();
    }
    static void test01_readFile(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
//        Map<Integer, List<Integer>> map = readFile(fName); 
//        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
//            Print.pp(entry.getKey());
//            Aron.printList(entry.getValue());
//        } 
        Aron.end();
    }
    static void test02_buildTreeFromLevelOrder(){
        Aron.beg();
        Node root = new Node("1");
        Node n2 = new Node("2");
        Node n3 = new Node("3");
        Node n4 = new Node("4");
        
        Node n5 = new Node("5");
        Node n6 = new Node("6");

        n3.list.add(n5);
        n3.list.add(n6);

        root.list.add(n2);
        root.list.add(n3);
        root.list.add(n4);

        printNary(root);
        String fName = "file5.txt";
        writeFile(root, fName);
        Map<Integer, List<Integer>> map = readFile(fName); 
        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
            Print.pp(entry.getKey());
            Aron.printList(entry.getValue());
        } 
        Node r = buildTreeFromLevelOrder(map, 1);  
        printNary(r);

        Aron.end();
    }
    public static Node buildTreeFromLevelOrder(Map<Integer, List<Integer>> map, Integer r){
        Node parent = null;
        if(map.size() > 0){
            parent = new Node(r + "");
            List<Integer> list = map.get(r);
            for(Integer n : list){
                parent.list.add(buildTreeFromLevelOrder(map, n));
            }
        }
        return parent;
    }
} 
import java.util.ArrayList;
public class SetMatrixZero 
{
    public static void main(String[] args)
    {
        System.out.println("SetMatrixZero");
        int[][] Matrix = {
            {0, 3, 5, 6},
            {1, 3, 5, 0},
            {4, 0, 5, 6},
            {7, 3, 5, 6}
        };
        ArrayList<Integer> arrayList = new ArrayList<Integer>();
        int len = Matrix.length; 
        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                if(Matrix[i][j] == 0)
                {
                    arrayList.add(i*len + j);
                }
            }
        }

        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                System.out.print(Matrix[i][j] + " ");
            }
            System.out.println();
        }

        System.out.println();
        for(int k=0; k<arrayList.size(); k++)
        {
            int row = arrayList.get(k)/len;
            int col = arrayList.get(k)%len;
            for(int i=0; i<len; i++)
            {
               for(int j=0; j<len; j++)
               {
                   if(i==row || j==col)
                   {
                       Matrix[i][j] = 0;
                   }
               } 
            }
        }

        for(int i=0; i<len; i++)
        {
            for(int j=0; j <len; j++)
            {
                System.out.print(Matrix[i][j] + " ");
            }
            System.out.println();
        }

    }
}
import java.util.*;
import java.io.*;
import classfile.*;

class URLShortener{
    final int base = 52;
    Map<Integer, Character> map = new HashMap<Integer, Character>(); 
    Map<Character, Integer> revmap = new HashMap<Character, Integer>(); 
    public URLShortener(){
        createMap();
    }
    //[ file=shortener.html title=""
    public StringBuilder encodeTo52(int n){
        final int base = 52; 
        StringBuilder sb = new StringBuilder();
        if(n == 0)
           sb.append("0");
        else{
            while(n > 0){
                sb.append(map.get(n % base));
                n /= base;
            }
        }
        return sb.reverse();
    }
    public int decode(StringBuilder sb){
        int sum = 0;
        for(int i=sb.length()-1; i>=0; i--){
            sum += (int)Math.pow(base, revmap.get(new Character(sb.charAt(i))));     
        }
        return sum;
    }
    public void createMap(){
        int count = 0;
        for(int i=0; i<10; i++){
            map.put(count, new Character((char)((int)'0' + i))); 
            revmap.put(new Character((char)((int)'0' + i)), count);
            count++;
        }

        for(int i=0; i<26; i++){
            map.put(count, new Character((char)((int)'a' + i))); 
            revmap.put(new Character((char)((int)'a' + i)), count);
            count++;
        }

        for(int i=0; i<26; i++){
            map.put(count, new Character((char)((int)'A' + i))); 
            revmap.put(new Character((char)((int)'A' + i)), count);
            count++;
        }

        
    }
    //]
    public void printMap(){
        for(Map.Entry<Integer, Character> entry: map.entrySet()){
            System.out.println("[" + entry.getKey() + "] [" + entry.getValue() + "]"); 
        }
    }
}


public class Shortener{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
    }
    public int encode(int n){
        return 1;
    }

    static void test0(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(100); 
        System.out.println("100[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test1(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(0); 
        System.out.println("0[" + sb.toString() + "]"); 
        Aron.end();
    }

    static void test2(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(9); 
        System.out.println("9[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test3(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(10); 
        System.out.println("10[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test4(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(11); 
        System.out.println("11[" + sb.toString() + "]"); 
        Aron.end();
    }

    static void test5(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(1000000); 
        System.out.println("1000000[" + sb.toString() + "]"); 
        Aron.end();
    }
    static void test6(){
        Aron.beg();
        URLShortener urls = new URLShortener();
        StringBuilder sb = urls.encodeTo52(100000000); 
        System.out.println("100000000[" + sb.toString() + "]"); 
        Aron.end();
    }
} 
import classfile.*;

// update: Wed Sep 28 03:22:10 PDT 2016
//
public class ShortestPathKthEdge {
    static final int INT = 100;
    public static void main(String[] args) {
        Print.p("Hello World!");
        int[][] graph= { 
            {0, 10, 3, 2},
            {INT, 0, INT, 7},
            {INT, INT, 0, 6},
            {INT, INT, INT, 0}
        };
        int u = 0;
        int v = 3;
        int k = 2;
        int numVertex = 4;
        int min = minPath(graph, numVertex, k, u, v);
        Print.p("u=["+u+"]");
        Print.p("v=["+v+"]");
        Print.p("k=["+k+"]");
        Print.p("finalmin=["+min+"]");
        int numEdge = 0;

        //GraphTraveral(graph, numVertex, numEdge);
        Ut.l();
        PreorderGraphTraveral(graph, numVertex, numEdge);
        Ut.l();
        PostGraphTraveral(graph, numVertex, numEdge);
        /*
        int min2 = minPathDP(graph, numVertex, numEdge, u, v);
        Print.p("min2=["+min2+"]");
        */
    }

    //Use Depth First Search to find the shortest path from vertex u to v with k edges
    public static int minPath(int[][] graph, int numVertex, int k, int u, int v) {
        //when u == v, assume the cycle in the same node
        if(k <= 0 && u == v)
            return 0;
        else if( k <= 0)
            return INT;
        /*
        else if( k == 1 && graph[u][v] != INT)
            return graph[u][v];
        */
        else {
            int min = INT;
            for(int i=0; i<numVertex; i++) {
                if(graph[u][i] != INT && u != i && v != i) {
                    Print.p("inorder["+u+"]["+i+"]=["+graph[u][i]+"]");
                    Print.p("k=["+k+"]");
                    int subm = minPath(graph, numVertex, k-1, i, v);
                    if(subm != INT) {
                        min = Math.min(min, subm) + graph[u][i];
                        Print.p("min=["+min+"] subm["+subm+"]   ["+u+"]["+i+"]");
                    }
                }
            }
            return min;
        }
    }

    //Traveral from node(depth) to other nodes
    public static void PostGraphTraveral(int[][] w, int numVertex, int depth) {
        for(int i=0; i<numVertex; i++) {
            if( i !=depth && w[depth][i] != 0 && w[depth][i] != INT) {
                PostGraphTraveral(w, numVertex, i);
                //Print.p(depth+"->"+i+"["+w[depth][i]+"]");
                Print.p(i+"->"+depth+"["+w[depth][i]+"]");
            }
        }
    }

    //Preorder Traveral
    public static void PreorderGraphTraveral(int[][] w, int numVertex, int depth) {
        for(int i=0; i<numVertex; i++) {
            if( i !=depth && w[depth][i] != INT) {
                Print.p(depth+"->"+i+"["+w[depth][i]+"]");
                PreorderGraphTraveral(w, numVertex, i);
            }
        }
    }


    //Use dynamic programming to find the shortest path from vertex u to v with numEdge
    //edge
    public static int minPathDP(int[][] graph, int numVertex, int numEdge, int u, int v) {
        int[][][] cube = new int[numVertex][numVertex][numEdge+1];

        for(int e=0; e<numEdge+1; e++) {
            for(int i=0; i<numVertex; i++) {
                for(int j=0; j<numVertex; j++) {
                    cube[i][j][e] = INT;

                    //base case
                    if( e == 0 && i == j)
                        cube[i][j][e] = 0;
                    else if ( e == 1 && graph[i][j] != INT)
                        cube[i][j][e] = graph[i][j];
                    else if( e > 1) {
                        for(int a=0; a < numVertex; a++) {
                            if(i != j && a != i && a != j && graph[i][a] != INT &&
                                    cube[i][j][e-1] != INT)
                                cube[i][j][e] = Math.min(graph[i][a] + cube[a][j][e-1],
                                                         cube[i][j][e]);
                        }
                    }
                }
            }

            for(int i=0; i<numVertex; i++) {
                for(int j=0; j<numVertex; j++) {
                    if(cube[i][j][e] < 100)
                        Print.p("["+cube[i][j][e]+"]");
                    else
                        Print.p("["+0+"]");
                }
            }
        }
        return cube[u][v][numEdge];
    }
}
import java.io.*;
import java.lang.String;
import java.util.*;

class Shuffle 
{
	public static void main(String args[])
	{
		int[] B = new int[10];
		for(int i=0; i<10; i++)
			B[i] = i;  

		for(int i=0; i<B.length; i++)
			System.out.print(B[i]+" ");

		System.out.println();

		int[] A = Shuffle(B);
		for(int i=0; i<B.length; i++)
			System.out.print(A[i]+" ");
		System.out.println();
        
        test1();
        test2();

	}
	public static int[] Shuffle(int[] A)
	{
		Random ran = new Random();
		if( A != null) {
			int len=A.length;
			if(len > 1)
			for(int i=0; i<len; i++) {
				int r = ran.nextInt(len) % (len-i);
				int tmp = A[r]; A[r] = A[len-1-i]; A[len-1-i] = tmp;
			}
		}
		return A;
	}

    // given string s and t of the same length
    public static String PerfectShuffle(String s, String t)
    {
        int n = s.length();    
        if(n <= 1) return s + t;
        
        String a = PerfectShuffle(s.substring(0, n/2), t.substring(0, n/2));
        String b = PerfectShuffle(s.substring(n/2, n), t.substring(n/2, n));
        return a + b;
    }
    public static void test1()
    {
        String s = "abc";
        String t = "efg";
        System.out.print("\n test1() \n");
        System.out.print("\n s=" + s + "\n");
        System.out.print("\n t=" + t + "\n");
        System.out.print("\n PerfectShuffle()=" + PerfectShuffle(s, t) + "\n");
    }
    public static void test2()
    {
        String s = "a";
        String t = "e";
        System.out.print("\n test2() \n");
        System.out.print("\n s=" + s + "\n");
        System.out.print("\n t=" + t + "\n");
        System.out.print("\n PerfectShuffle()=" + PerfectShuffle(s, t) + "\n");
    }
}
public class SieveEratosthenes 
{
    public static void main(String[] args)
    {
        long startTime = System.currentTimeMillis();
        Prime(1000000);
        long endTime = System.currentTimeMillis();
        long diff = endTime - startTime;
        System.out.println("diff=" + diff);
    }

    //Find all the primes from 2 to n
    //Sieve of Eratosthenes Algorithm
    public static void Prime(int n)
    {
        boolean[] prime = new boolean[n+1];
        for(int i=0; i<n; i++)
            prime[i] = true;

        for(int i=2; i<Math.sqrt(n); i++)
        {
            int k=0;
            int index = i*i + k*i;
            if(prime[i])
            {
                while(index <= n)
                {
                    if(prime[index])
                        prime[index] = false;
                    index = i*i + k*i;
                    k++;
                }
            }
        }
        for(int i=2; i<n; i++)
        {
            System.out.println("[" + i + "]=" + prime[i]);
        }
    }
}
import java.util.*;
import java.io.*;
import classfile.*;

// 4:22, 5:41, 6:19
// Least Recent Used Cache
//

//[ file=simpleLRU.html title=""
// Least Recent Used Cache, LRU
class LNode {
    String key;
    Object data;
    public LNode(String key, Object data) {
        this.data = data;
        this.key = key;
    }
}

class LRU {
    final int max;
    int count;
    LinkedList<LNode> list = new LinkedList<LNode>();
    Map<String, LNode> map = new HashMap<String, LNode>();

    public LRU(int max) {
        this.max = max;
        this.count = 0;
    }
    public void insert(String key, LNode node) {
        LNode value = map.get(key);
        if(value != null) {
            list.remove(value);
            list.addLast(node);
            map.put(key, node);
        } else {
            if(count < max) {
                map.put(key, node);
                list.addLast(node);
                count++;
            }else{
                LNode reNode = list.removeFirst();
                list.addLast(node);
                map.remove(reNode.key);
                map.put(key, node);
            }
        }
    }
    public void remove(String key) {
        if(count > 0 && map.containsKey(key)){
            LNode node = map.get(key);
            if(node != null){
                list.remove(node);
                map.remove(key);
                count--;
            }
        }
    }

    public void print(){
        for(Map.Entry<String, LNode> entry : map.entrySet()){
            System.out.println("[" + entry.getKey() + " , " + entry.getValue().data + "]");
        } 
        Aron.line();

        for(LNode node : list){
            System.out.println("["+ node.data + "]");
        }
    }
}
//]

public class SimpleLRU{
    public static void main(String[] args) {
        test0();
        test1();
    }
    static void test0() {
        Aron.beg();
        LRU lru = new LRU(3);
        String k1 = "dog";
        String k2 = "cat";
        String k3 = "cow";
        LNode node1 = new LNode(k1, "Excuse, Technical, Technician, Torch");
        LNode node2 = new LNode(k2, "This is typical excuse for being late");
        LNode node3 = new LNode(k3, "Please elaborate your question, please clarify your intention, The wound will heal up");

        lru.insert(k1, node1);
        lru.insert(k2, node2);
        lru.insert(k3, node3);

        lru.print();

        Aron.end();
    }
    static void test1() {
        Aron.beg();
        LRU lru = new LRU(3);
        String k1 = "dog";
        String k2 = "cat";
        String k3 = "cow";
        String k4 = "pig";

        LNode node1 = new LNode(k1, "First, Excuse, Technical, Technician, Torch");
        LNode node2 = new LNode(k2, "Second, This is typical excuse for being late");
        LNode node3 = new LNode(k3, "Third, Please elaborate your question, please clarify your intention, The wound will heal up");
        LNode node4 = new LNode(k4, "Fourth, Injuring 100 people and wounding 20 people in the bombing near the market in Thailand");

        lru.insert(k1, node1);
        lru.insert(k2, node2);
        lru.insert(k3, node3);
        lru.insert(k4, node4);

        lru.print();

        Aron.end();
    }
}

import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.*;
import java.io.*;
import classfile.*;
import java.util.stream.*;

public class SingleLinkedList_test{
    public static void main(String[] args) {
        test0();
        test1();
        test2();
        test3();
        test4();
        test5();
        test6();
        test7();
    }
    public static void test0(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        sll.append(n1);
        sll.print();

        Aron.end();
    }

    public static void test1(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        sll.append(n1);
        sll.remove(n1);

        sll.print();

        Aron.end();
    }

    public static void test2(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

//        sll.remove(n1);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 2);
        Test.t(list.get(2).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test3(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n1);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 2);
        Test.t(list.get(1).data == 3);

        sll.print();

        Aron.end();
    }
    public static void test4(){
        Aron.beg();

        SingleLinkedList sll = new SingleLinkedList();
        Node n1 = new Node(1);
        Node n2 = new Node(2);
        Node n3 = new Node(3);
        sll.append(n1);
        sll.append(n2);
        sll.append(n3);

        sll.remove(n2);
        List<Node> list = sll.toList();
        Test.t(list.get(0).data == 1);
        Test.t(list.get(1).data == 3);

        sll.print();

        Aron.end();
