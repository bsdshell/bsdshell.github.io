Wed Aug 15 17:14:22 2018 
Get error start mysql server on MacOS, mysql 5.7 and mysql 8.0
/**
 * detect file types from file extensions: image(.png, .jpeg, .jpg) and PDF(.pdf)
 *
 * @param fName is name of file.
 * @return image file: "IMG" or pdf file: "PDF", empty otherwise
 *
 */
 static String fileType(String fName){
    String type = "";
    Pattern pdfPattern = Pattern.compile("\\.pdf$", Pattern.CASE_INSENSITIVE);
    Matcher pdfMatcher = pdfPattern.matcher(fName);

    Pattern pattern = Pattern.compile("\\.png|\\.jpeg|\\.jpg$", Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(fName);

    if(matcher.find()){
        Print.pbl("fName=" + fName);
        type = "IMG";
    }else if(pdfMatcher.find()){
        Print.pbl("fName=" + fName);
        type = "PDF";
    }
    return type;
}
==================================================================  
Remove all versions of MySQL (I had 5.7.21, 5.7.22, and 8.0.11) : brew uninstall --force mysql

Confirm Removal and Repair : brew services list and then brew doctor

Rename original MySQL : mv /usr/local/var/mysql /usr/local/var/old.mysql

Install latest MySQL (currently 8.0.11) : brew install mysql

MySQL Secure Install : /usr/local/bin/mysql_secure_installation
==================================================================  
*haskell file manager*  *h file manager*  *file manager* 
ghci add
:m +System.FilePath.Posix
------------------------------------------------------------------ 
A library for FilePath manipulations, using Posix style paths on all platforms. Importing System.FilePath is usually better.

Given the example FilePath: /directory/file.ext

We can use the following functions to extract pieces.

    takeFileName gives "file.ext"  *file_ext*
    takeFileName "dog/cat" => cat
    takeDirectory gives "/directory"  
    takeExtension gives ".ext"
    dropExtension gives "/directory/file"
    takeBaseName gives "file"

And we could have built an equivalent path with the following expressions:

    "/directory" </> "file.ext".
    "/directory/file" <.> "ext".
    "/directory/file.txt" -<.> "ext".
==================================================================  
Remove symbol links in Haskell
------------------------------------------------------------------ 
Hard links
createLink :: FilePath -> FilePath -> IO () Source#

createLink old new creates a new path, new, linked to an existing file, old.

Note: calls link.

removeLink :: FilePath -> IO () Source#

removeLink path removes the link named path.

Note: calls unlink.

Symbolic links
createSymbolicLink :: FilePath -> FilePath -> IO () Source#

createSymbolicLink file1 file2 creates a symbolic link named file2 which points to the file file1.

Symbolic links are interpreted at run-time as if the contents of the link had been substituted into the path being followed to find a file or directory.

Note: calls symlink.
==================================================================  
cabal update
cabal install OpenGL
or runall to see all the installed packages
------------------------------------------------------------------ 
http://hackage.haskell.org/package/OpenGL
OpenGL 3.0.2.2 is Haskell binding for OpenGL system(GL verision 4.6)
and its accompanying utility system GLU, version 1.3
------------------------------------------------------------------ 
cabal update
cabal install OpenGLRaw  (current version is 3.3.1.0)
OpenGLRaw is a raw Haskell binding for the OpenGL 4.6 graphics system and lots of OpenGL extensions. 
It is basically a 1:1 mapping of OpenGL's C API, intended as a basis for a nicer interface.
==================================================================  
Sat Aug 18 11:16:09 2018 
------------------------------------------------------------------ 
type FilePath = String Source#

File and directory names are values of type String, whose precise meaning is operating system dependent. Files can be opened, yielding a handle which can then be used to operate on the contents of that file.

readFile :: FilePath -> IO String Source#

The readFile function reads a file and returns the contents of the file as a string. The file is read lazily, on demand, as with getContents.

writeFile :: FilePath -> String -> IO () Source#

The computation writeFile file str function writes the string str, to the file file.

appendFile :: FilePath -> String -> IO () Source#

The computation appendFile file str function appends the string str, to the file file.

Note that writeFile and appendFile write a literal string to a file. To write a value of any printable type, as with print, use the show function to convert the value to a string first.

main = appendFile "squares" (show [(x,x*x) | x <- [0,0.1..2]])
readIO :: Read a => String -> IO a Source#

The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program.

readLn :: Read a => IO a Source#

The readLn function combines getLine and readIO.

Exception handling in the I/O monad
type IOError = IOException Source#

The Haskell 2010 type for exceptions in the IO monad. Any I/O operation may raise an IOError instead of returning a result. For a more general type of exception, including also those that arise in pure code, see Exception.

In Haskell 2010, this is an opaque type.

ioError :: IOError -> IO a Source#

Raise an IOError in the IO monad.

userError :: String -> IOError Source#
==================================================================  
Wed Aug 22 11:15:59 2018 
OpenGL push and pop matrix, changed to preservingMatrix in Haskell

preservingMatrix :: IO a -> IO a Source#

Push the current matrix stack down by one, duplicating the current matrix, excute the given action, and pop the current matrix stack, replacing the current matrix with the one below it on the stack (i.e. restoring it to its previous state). The returned value is that of the given action. Note that a round-trip to the server is probably required. For a more efficient version, see unsafePreservingMatrix.
==================================================================  
Wed Aug 22 22:09:40 2018 
Set, find the powerset, insert, delete element etc. 
http://hackage.haskell.org/package/containers-0.6.0.1/docs/Data-Set.html
------------------------------------------------------------------ 
Vim set search ignorecase  noignorecase
:set noignorecase
------------------------------------------------------------------ 
==================================================================  
Thu Aug 23 11:37:33 2018 
package linear, Linear is the linear algebra library for basic linear algebra operation,
I just try to play around with the library, and it seems to me it is pretty "easy to use" library,

1. Install the package
   cabal update
   cabal install linear (my current version is linear-1.20.8)

2. import the module
   import Linear
http://hackage.haskell.org/package/linear-1.20.8/docs/Linear-Matrix.html
------------------------------------------------------------------ 
current Haskell version on my system
/Library/Frameworks/GHC.framework/Versions
7.10.2-x86_64
7.10.3-x86_64
8.4.3-x86_64
Current
------------------------------------------------------------------ 
#Many GHC versions can cause trouble on your MacOS
After install the haddock with 
cabal unregister haddock-api
cabal unregister haddock-library
and sound some strangle issue with old version GHC-7.10.x sth, need to manually remove it, and run cabal install haddock-xxx again
close the shell and reopen the shell again, 
and use 'which' command to find the haddock to verify the haddock it works

It seems to me there are issues when I have many versions of GHC in my MacOS,(three versions now..) 
7.10.2-x86_64
7.10.3-x86_64
8.4.3-x86_64
it causes the haddock does't work initially
==================================================================  
Fri Aug 24 17:21:26 2018 
here-string here string is crazy awesome
Here is how to run GHCi in your command line
ghci -v0 <<< ':r map'
------------------------------------------------------------------ 
==================================================================  
Wed Aug 29 16:26:38 2018 
arrow with text above for function above
https://tex.stackexchange.com/questions/103988/rightarrow-with-text-above-it
------------------------------------------------------------------ 
Julia redirect output to file

You can use the @capture_out macro from Suppressor.jl 7, then write it to a file:

using Suppressor

output = @capture_out run(`ls`)

open("/var/log/myprogram.txt", "w") do io
    write(io, output)
end
==================================================================  
Thu Aug 30 17:53:00 2018 
file image file, png file, detect file type, filetype 
    /**
     * detect file types from file extensions: image(.png, .jpeg, .jpg) and PDF(.pdf)
     *
     * @param fName is name of file.
     * @return image file: "IMG" or pdf file: "PDF", empty otherwise
     *
     */
     static String fileType(String fName){
        String type = "";
        Pattern pdfPattern = Pattern.compile("\\.pdf$", Pattern.CASE_INSENSITIVE);
        Matcher pdfMatcher = pdfPattern.matcher(fName);

        Pattern pattern = Pattern.compile("\\.png|\\.jpeg|\\.jpg$", Pattern.CASE_INSENSITIVE);
        Matcher matcher = pattern.matcher(fName);

        if(matcher.find()){
            Print.pbl("fName=" + fName);
            type = "IMG";
        }else if(pdfMatcher.find()){
            Print.pbl("fName=" + fName);
            type = "PDF";
        }
        return type;
    }
==================================================================  
Fri Aug 31 13:33:30 2018, javadoc, generate javadoc, gene javadoc
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -Dshow=private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -Dshow=private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -private prefix_map.java
prefix_map.java  $tt/jdoc && cd $tt/jdoc && javadoc -private prefix_map.java
------------------------------------------------------------------ 
   /** 
    <pre>
    {@literal
        str = "vi cmd, vi help";
        [key =v]
        [key =vi]
        [key =c]
        [key =cm]
        [key =cmd]
        vi -> [vi cmd]
        c -> [cmd]
        v -> [vi cmd]
        cm -> [cmd]
        cmd -> [cmd]
        [key =v]
        [key =vi]
        [key =h]
        [key =he]
        [key =hel]
        [key =help]
        help -> [help]
        vi -> [vi help, vi cmd]
        c -> [cmd]
        v -> [vi help, vi cmd]
        h -> [help]
        cm -> [cmd]
        cmd -> [cmd]
        he -> [help]
        hel -> [help]
    }
    {@code 
        List<String> list = new ArrayList<>(Arrays.asList("vi cmd, vi help"));
        Map<String, Set<String>> map = new HashMap<>();
        prefixStringMap(list, map);
    }
    </pre>
    */
------------------------------------------------------------------ 
