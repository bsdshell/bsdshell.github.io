<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB">
<head>
    <title>$title</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <meta name="description" content="Xcode Change Build from iPhone to Universal iPad " />
    <meta name="keywords" content="Build iPhone and iPad, Change Xcode Build Target " />
    <meta name="robots" content="index, follow" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="../screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../highlight.css">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX","output/HTML-CSS"],
            tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
          });
    </script>
    <script type="text/javascript" src="../MathJax-2.6-latest/MathJax.js"></script>
</head>
<body>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66282017-2', 'auto');
  ga('send', 'pageview');
</script>
<div class="myclass">

                <div class="mytextbox">
                    <pre class="mytitle">
        Draw your first Triangle in IOS OpenGL
                    </pre>
                    
                    <pre class="mytext">
<span style="color:red;">OpenGL</span> is low level computer graphic API, it powers most of graphic intensive games and softwares in this universe.<br>
Ok, it is enough talk!, let's get into action and show some stuff!

First, we need to review the coordinates system
Normally, there are two coordinates systems in computer graphic

<span style="color:red;">OpenGL</span> uses [Right-Handed Coordinates System] and <span style="color:red;">Direct3D</span> uses [Left-Handed Coordinates System]<br>
<img src="../image/coorsystem.svg" width="100%" height="100%" /><br> 

We set z-axis=0 anyway since we only draw two dim triangle<br>
                    </pre>
                    <img src="../image/triangle.svg" width="100%" height="100%" /><br> 
                    <pre class="mytext">
                    1. Create an array with three vertices p=[x, y, z]
                    </pre>
                    <pre class="prettyprint">
static const GLfloat triangle[] = {
    0, 0, 0,
    1, 0, 0,
    0, 1, 0,
};

glVertexAttribPointer     - define an array of generic vertex attribute data
glEnableVertexAttribArray - enable a generic vertex attribute array
glDiableVertexAttribArray - diable a generic vertex attribute array
glDrawArrays              - render primitive from array data

glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, triangle);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_TRIANGLE_STRIP</span>, 0, 3);
                    </pre>
                    <div style="text-align:center"><img src="../image/triangle.png" width="20%" height="20%" /><br></div> 
                    <div class="mytext"> 
There are three functions that you need to called to draw a triangle in OpenGL 
When a triangle is drawn, there are three options can be used:

<span style="color:rgba(63, 185, 5, 0.91);">GL_TRIANGLE_STRIP GL_TRIANGLE_FAN GL_TRIANGLES</span>
What is <span style="color:rgba(63, 185, 5, 0.91);">GL_TRIANGLE_STRIP</span>
Let assume we have four points p0=[0,0,0] p1=[1,0,1] p2=[1,1,0] p3=[0,1,0] in order.

First three points: {p0, p1, p2} forms a triangle, easy!

Second triangle is formed from {p1, p2, p3}

So each consecutive pair of triangle shares two vertices
Each new vertex is added, a new triangle is formed
The numbers of triangle can be formed in n vertices is n-2  

What is <span style="color:rgba(63, 185, 5, 0.91);">GL_TRIANGLE_FAN</span>
GL_TRIANGLE_FAN use the first vertex and last two vertices to form a triangle
The numbers of triangle can be formed in n vertices is n-2  

What is <span style="color:rgba(63, 185, 5, 0.91);">GL_TRIANGLES</span>  
GL_TRIANGLES treats each triple of vertices as independent triangle.
If there are 3*n vertices, then there are n triangle can be drawn
                    </div>
                    <img src="../image/triangle_strip_fan.svg" width="100%" height="100%" /> 
                    <pre class="mytext">
                    Let draw some real stuff!
                    </pre>
                    <pre class="prettyprint">
static const GLfloat triangle[] = {
    0, 0, 0,
    1, 0, 0,
    1, 1, 0,
    0, 1, 0,
};
glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, triangle);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_TRIANGLE_STRIP</span>, 0, 4);
                    </pre>
                    <div style="text-align:center"><img src="../image/triangle_strip.png" width="20%" height="20%" /><br></div> 

                    <pre class="prettyprint">
                    static const GLfloat triangle[] = {
                        0, 0, 0,
                        1, 0, 0,
                        1, 1, 0,
                        0, 1, 0,
                    };
                    </pre>

                    <pre class="prettyprint">
glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, triangle);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_TRIANGLE_FAN</span>, 0, 4);
                    </pre>
                    <div style="text-align:center"><img src="../image/triangle_fan.png" width="20%" height="20%" /><br></div> 


                    <pre class="prettyprint">
static const GLfloat triangle[] = {
    0, 0, 0,
    1, 0, 0,
    1, 1, 0,
    
    0, 1, 0,
    0, 2, 0,
    1, 1.5, 0
};
                    </pre>

                    <pre class="prettyprint">
glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, triangle);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_TRIANGLES</span>, 0, 6);
                    </pre>
                    <div style="text-align:center"><img src="../image/triangle_list.png" width="20%" height="20%" /><br></div> 

                    <pre class="prettyprint">
static const GLfloat triangle[] = {
    0, 0, 0,
    1, 0, 0,
    1, 1, 0,
    0, 1, 0,
};
                    </pre>

                    <pre class="prettyprint">
glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, triangle);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_LINE_LOOP</span>, 0, 4);
                    </pre>
                    <div style="text-align:center"><img src="../image/line_loop.png" width="20%" height="20%" /><br></div> 

                    <pre class="prettyprint">
                    static const GLfloat triangle[] = {
                        0, 0, 0,
                        1, 0, 0,
                        0, 1, 0,
                        1, 1, 0,
                    };
                    </pre>

                    <pre class="prettyprint">
glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, triangle);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_TRIANGLE_STRIP</span>, 0, 4);
                    </pre>
                    <div style="text-align:center"><img src="../image/triangle_strip2.png" width="20%" height="20%" /><br></div> 

                    <pre class="prettyprint">
static const GLfloat box[] = {
    0, 0, 0,
    1, 0, 0,
    0, 1, 0,
    1, 1, 0,
    
    0, 1, -1,
    1, 1, -1,
    0, 0, -1,
    1, 0, -1,
    
    1, 1, 0,
    1, 0, 0,
    0, 0, -1,
    0, 0, 0,
    
    0, 1, -1,
    0, 1, 0,
};
                    </pre>

                    <pre class="prettyprint">
glVertexAttribPointer(ATTRIB_VERTEX, 3, GL_FLOAT, 0, 0, box);
glEnableVertexAttribArray(ATTRIB_VERTEX);
glDrawArrays(<span style="color:red;">GL_TRIANGLE_STRIP</span>, 0, 14);
                    </pre>
                    <div style="text-align:center"><img src="../image/box2.png" width="20%" height="20%" /><br></div> 
                    <div style="text-align:center"><img src="../image/boxbox.png" width="20%" height="20%" /><br></div><br>

                    <div class="mytitle">
                    Understand View Matrix in OpenGL
                    </div>
                    <div class="cen">
                    <img src="../image/lookat_left_handed_rule.svg" width="80%" height="80%" /><br>
                    </div> 

                    <div style="font-size:130%;" class="mytext">
                    \begin{aligned}
                         \vec{f} \otimes \overrightarrow{up}  &= \vec{s} \quad \mbox{Right-handed rule} \\
                         \vec{s} \otimes \vec{f}  &= \vec{u} \quad \mbox{Right-handed rule} \\
                         &\mbox{mapping } \vec{s}, \vec{u}, \vec{f} \mbox{ to } x, y, z \\
                         &\vec{s} \rightarrow +x \\
                         &\vec{u} \rightarrow +y \\
                         &\vec{f} \rightarrow -z \\
                    \end{aligned}
                    </div>

                    <div class="mytext">
<span id="red">View Matrix</span> can be constructed with gluLookAt in OpenGL
Specify the eye poistion, lookat position, and up Vector.<br>
</div>
                    <pre class="prettyprint">
gluLookAt(
    Eyex
    Eyey
    Eyez

    Atx
    Aty
    Atz

    Upx
    Upy
    Upz)
                    </pre><br>
                    <div class="mytext">
For example, if you want to change the eye position to $(0, 0, -2)$, two units away from the screen.
                    </div>
                    <pre class="prettyprint">
                    loadIdentity()
                    gluLookAt(0 0 -2, ...)
                    </pre>

                    <div class="mytext">
<span id="red">View Matrix</span> is essential the orthonormal matrix for the camera or eye.
1. Given up direction $up=(0, 1, 0)$ and lookAt direction[e.g. from eye to center] 
2. $\vec{s}$ can be computed with cross product
3. With $\vec{s}$ and lookAt direciton, $\vec{u}$ can be computed with cross product again
                    </div>

                    <div class="cen">
                    <img src="../image/righthand.png" width="40%" height="40%" /><br>
                    </div> 
                    <br>
                    <div class="cen">
                    <img src="../image/mapcoor.png" width="40%" height="40%" /><br>
                    </div> 
                    <div style="font-size:130%;" class="mytext">
                    Once $\text{side} = \vec{s}, \text{up}=\vec{u}, \text{forward}=\vec{f}$ are known, the <span id="red">View Matrix</span> can be constructed<br>
                    We use the above example, and compute the <span id="red">View Matrix</span>.<br>
                    $\vec{up} = (0, 1, 0)$<br>
                    the vector from eye to center is $\vec{f} = (0, 0, 0) - (0, 2, 3) = (0, -2, -3) $<br>
                    $\vec{s} = \vec{f} \times \vec{up} = (0, -2, -3) \times (0, 1, 0)$ [Since $\vec{up} \text{ and } \vec{u}$ are same direction]
                    \begin{align*} 
                        \vec{s} &= \vec{s} \times -\vec{f} = \vec{f} \times \vec{up} = \left| \begin{array}{ccc}
                        i & j & k \\
                        0 & -2 & -3 \\
                        0 & 1 & 0 \end{array} \right| \\
                        &= 
                        \left| \begin{array}{cc}
                        -2 & -3 \\
                        1 & 0 \end{array} \right|i(-1)^{1+1}
                        +
                        \left| \begin{array}{cc}
                        0 & -3 \\
                        0 & 0 \end{array} \right|j(-1)^{1+2}
                        +
                        \left| \begin{array}{cc}
                        0 & -2 \\
                        0 & 1 \end{array} \right|k(-1)^{1+3} \quad \text{Cofactor Expension} \\
                        &= 3i + 0j + 0k = 3i 
                    \end{align*} 
                    Since we want to map $\vec{u}$ to 
                    $
                        y = \left[ \begin{array}{c}  
                                0 \\
                                1 \\
                                0 \\
                                \end{array}
                            \right]
                    $ 
                    and one axis to 
                    $
                        z = \left[ \begin{array}{c}  
                                0 \\
                                0 \\
                                1 \\
                                \end{array}
                            \right]
                    $ 
                    and $\vec{s}$ to
                    $
                        x = \left[ \begin{array}{c}  
                                1 \\
                                0 \\
                                0 \\
                                \end{array}
                            \right]
                    $
                    $f$ point to the screen, and $+z$ is point outside of the screen in OpenGL.<br> 
                    $f$ changes to $-f$ so that $\vec{s}, \vec{u}, -\vec{f}$ map to $x, y, z$<br> 
                    From the picture above, 
                    $\vec{s} = \vec{u} \times - \vec{f} = \vec{f} \times \vec{u}$<br>
                    $\vec{u} = -\vec{f} \times \vec{s} = \vec{s} \times \vec{f}$<br>
                    $\vec{s} = (3, 0, 0) \quad \vec{f} = (0, -2, -3)$<br>
                    \begin{align*} 
                        \vec{u} &= \vec{s} \times \vec{f}
                        = 
                        \left| \begin{array}{ccc}
                        i & j & k \\
                        3 & 0 & 0 \\
                        0 & -2 & -3 \end{array} \right| \\
                        &=
                        \left| \begin{array}{cc}
                        0 & 0 \\
                        -2 & -3 \end{array} \right|i(-1)^{1+1}
                        +
                        \left| \begin{array}{cc}
                        3 & 0 \\
                        0 & -3 \end{array} \right|j(-1)^{1+2}
                        +
                        \left| \begin{array}{cc}
                        3 & 0 \\
                        0 & -2 \end{array} \right|k(-1)^{1+3}  \quad \text{Cofactor Expension} \\
                        &= 0i + 9j - 6k
                    \end{align*} 

                    $\vec{s} = (3, 0, 0) \quad \vec{u} = (0, 9, -6) \quad \vec{f} = (0, -2, -3) $<br> 
                    normalize three vectors<br>
                    \begin{align*}
                    \begin{split}
                        \vec{s}_{n} &= \frac{(3, 0, 0)}{\sqrt{\|\vec{s}\|}} &= (1, 0, 0) \\    
                        \vec{u}_{n} &= \frac{(0, 9, -6)}{\sqrt{\|\vec{u}\|}} &= (0, \frac{3}{\sqrt{13}}, \frac{-2}{\sqrt{13}}) \\  
                        \vec{f}_{n} &= \frac{(0, -2, -3)}{\sqrt{\|\vec{f}\|}} &= (0, \frac{-2}{\sqrt{13}}, \frac{-3}{\sqrt{13}}) \\
                    \end{split}
                    \end{align*}

                    

                    Since three $\vec{s}, \vec{u}, -\vec{f}$ are orthonormal vectors and they can forms a rotation matrix.<br> 
                    \begin{align*}
                    \begin{split}
                        \mathbf{R} &= \begin{bmatrix}
                        s_{n_x} & u_{n_x} & -f_{n_x} & 0 \\
                        s_{n_y} & u_{n_y} & -f_{n_y} & 0 \\
                        s_{n_z} & u_{n_z} & -f_{n_z} & 0 \\
                        0       & 0       & 0        & 1 \\
                        \end{bmatrix} \\
                        \mathbf{R} &= \begin{bmatrix}
                        1 & 0                    & 0                   & 0 \\
                        0 & \frac{3}{\sqrt{13}}  & \frac{2}{\sqrt{13}} & 0 \\
                        0 & \frac{-2}{\sqrt{13}} & \frac{3}{\sqrt{13}} & 0 \\
                        0 & 0                    & 0                   & 1 \\
                        \end{bmatrix} 
                    \end{split}
                    \end{align*}
                    We also translate the camera from center to 
                    \[
                        \vec{v} = \left[ \begin{array}{c} 
                        0 \\
                        2 \\
                        3 \\
                        1 \\
                        \end{array} \right] \\
                    \]
                    The translation matrix is
                    \[ 
                        \mathbf{T} = \begin{bmatrix}
                        1 & 0 & 0 & 0 \\
                        0 & 1 & 0 & 2 \\
                        0 & 0 & 1 & 3 \\
                        0 & 0 & 0 & 1 \\
                        \end{bmatrix} 
                    \]
                    Let $\mathbf{M}_{v} = \mathbf{RT}$ 
                    if we want to conver the points from World Coordinate to View Coordinates, we can multiply the point with $\mathbf{M}_{v}^{-1}$

                    \begin{align*}
                    \begin{split}
                        p_{view} &= \mathbf{M}_{v}^{-1} 
                        \left[ \begin{array}{c} 
                        x \\
                        y \\
                        z \\
                        1 \\
                        \end{array} \right] \\
                        \mathbf{M}_{v}^{-1} &= (\mathbf{TR})^{-1} \\
                        \mathbf{M}_{v}^{-1} &= \mathbf{R}^{-1} \mathbf{T}^{-1} \\
                        \mathbf{M}_{v}^{-1} &= \mathbf{R}^{T} \mathbf{T}^{-1} \qquad \because \mathbf{R} \text{ is orthonormal matrix}\\

                        % invert of rotation matrix
                        \mathbf{R}^{T} &= \begin{bmatrix}
                        1 & 0                   & 0                    & 0 \\
                        0 & \frac{3}{\sqrt{13}} & \frac{-2}{\sqrt{13}} & 0 \\
                        0 & \frac{2}{\sqrt{13}} & \frac{3}{\sqrt{13}}  & 0 \\
                        0 & 0                   & 0                    & 1 \\
                        \end{bmatrix} \\ 

                        % invert of translation matrx
                        \mathbf{T}^{-1} &= \begin{bmatrix}
                        1 & 0 & 0 & 0 \\
                        0 & 1 & 0 & -2 \\
                        0 & 0 & 1 & -3 \\
                        0 & 0 & 0 & 1 \\
                        \end{bmatrix} \\
                        
                        % View matrix
                        \mathbf{M}_{v}^{-1} &= \begin{bmatrix}
                        1 & 0                   & 0                    & 0 \\
                        0 & \frac{3}{\sqrt{13}} & \frac{-2}{\sqrt{13}} & 0 \\
                        0 & \frac{2}{\sqrt{13}} & \frac{3}{\sqrt{13}}  & -\sqrt{13} \\
                        0 & 0                   & 0                    & 1 \\
                        \end{bmatrix} \\ 
                    \text{The View Matrix is } \mathbf{M}_{v}^{-1}
                    \end{split}
                    \end{align*}
                    </div>

                    <div class="cen">
                    <img src="../image/lookatmatrix1.png" width="50%" height="50%" /><br>
                    </div> 
                    <div class="cen">
                    <img src="../image/matrix1.jpg" width="50%" height="50%" /><br>
                    </div> 

                    <div class="mytitle">
                    If column vectors are orthonormal, then they can form a rotation matrix. Why? let prove it
                    </div>
                    <div style="font-size:130%;" class="mytext">
                    let matrix $A$ and two columns are orthonormal.
                    \[                     
                        A= \begin{bmatrix}
                        a & b\\
                        c & d 
                        \end{bmatrix} 
                    \]<br>  
                    we have following
                    $ a b + c d = 0 \quad a^2 + c^2 = 1 \text{ and } b^2 + d^2 = 1$, given a vector 

                    \begin{align*}
                    \begin{split}
                        \vec{v} &= \left [ \begin{array}{c} 
                        x \\
                        y \\
                        \end{array}\right] \\

                           \vec{u} &=
                           \left[ \begin{array}{c} 
                            ax + by \\ 
                            cx + dy 
                            \end{array} \right] 
                            = \begin{bmatrix} 
                            a & b \\ 
                            c & d 
                            \end{bmatrix} 
                            \times 
                            \left[ 
                            \begin{array}{c} 
                            x \\ 
                            y 
                            \end{array} 
                            \right] \\ 

                         \| \vec{u} \| &= (ax + by)^2 + (cx + dy)^2 \\
                                       &= a^2 x^2 + b^2 y^2 + 2abxy + c^2 x^2 + d^2 y^2 + 2cdxy \\
                                       &= (a^2 + c^2) x^2 + (b^2 + d^2) y^2 + 2(ab + cd)xy \\
                                       &= x^2 + y^2 \because  a b + c d = 0 \quad a^2 + c^2 = 1 \quad b^2 + d^2 = 1 \\
                         &\Rightarrow \| \vec{u} \| = \| \vec{v} \| \\
                         &\Rightarrow A \text{ is rotation matrix}
                    \end{split}
                    \end{align*}
                </div>

                <div class="mytitle">
                Projection Matrix in OpenGL. 
                </div>
                <div class="mytext">
What is Projection Matrix in OpenGL.
Projection matrix maps frustum to cube[NDC] in Perspective projection
There are two type of Projection Matrix in OpenGL.
<span class="red">Perspective Projection</span> and <span class="red">Orthogonal Projection</span> 
We will derived Perspective Projection.
What does Perspective Projection do in OpenGL.
It projects points in eye/camera space to <span id="red">Normal Device Coordinates</span>[NDC]
                </div>

                <div class="cen">
                <img src="../image/ndc.png" width="50%" height="50%" /><br>
                <img src="../image/similartri.png" width="50%" height="50%" /><br>
                </div> 
                <div style="font-size:140%;" class="mytext">
                    \begin{align*}
                    \frac{x_p}{x_e} &= \frac{-n}{z_e} \Rightarrow  x_p = \frac{nx_e}{-z_e} \\
                    \frac{y_p}{y_e} &= \frac{-n}{z_e} \Rightarrow  y_p = \frac{ny_e}{-z_e} \\
                    \left[ \begin{array}{c} 
                    x_p \\ 
                    y_p \\
                    z_p \\
                    w_p \\
                    \end{array} \right] 
                    &= \begin{bmatrix} 
                    n & 0  & 0 & 0 \\ 
                    0 & n  & 0 & 0 \\
                    0 & 0  & A & B \\
                    0 & 0  & 0 & 1 \\
                    \end{bmatrix} \times
                   \left[ \begin{array}{c} 
                    x_e \\ 
                    y_e \\
                    z_e \\
                    w_e \\
                    \end{array} \right] \\
                    %
                    z_p &= Az_e + B w_e \\
                    \frac{z_p}{-z_e} &= -A + \frac{B w_e}{-z_e} \\
                    &\text{Since we want to have something like following form}  \\ 
                    z_p &= \frac{\sigma}{-z_e} \\
                    -z_p z_e &= \sigma \\
                    \sigma &= A z_e + B w_e \\
                    z_p &=  \frac{A z_e + B w_e}{-z_e} \\
                    w_e &= 1  \\
                    -n &= -A + \frac{B}{n} \quad \because  z_e = -n \\
                    -f &= -A + \frac{B}{f} \quad \because  z_e = -f \\
                    -n + f &= \frac{B}{n} - \frac{B}{f} \\
                    B &=  nf \\
                    A &= n + f \\
                    z_p &=  \frac{(n+f) z_e + nf}{-z_e} \\
                    

                   \left[ \begin{array}{c} 
                    x_p \\ 
                    y_p \\
                    z_p \\
                    w_p \\
                    \end{array} \right] 
                    &= \begin{bmatrix} 
                    n & 0 & 0   & 0 \\
                    0 & n & 0   & 0 \\
                    0 & 0 & n+f & nf \\
                    0 & 0 & -1   & 0 \\
                    \end{bmatrix}
                   \left[ \begin{array}{c} 
                    x_e \\ 
                    y_e \\
                    z_e \\
                    w_e \\
                    \end{array} \right] \\
                    &\text{Map A} [x_p, y_p, z_p, w_p] [x_n, y_n, z_n, w_n]
                    \end{align*}
                    </div>
                    <div class="cen">
                    <img src="../image/projection_to_ndc.png" width="40%" height="40%" /><br>
                    </div> 
                    <div  class="mytext">
We try to map the near plane to font plane of NDC, they are linear relationship<br>
                    </div>
                    <div class="cen">
                    <img src="../image/xe_to_ndc.png" width="40%" height="40%" /><br>
                    </div> 
                    <div style="font-size:140%;" class="mytext">
                    \begin{align*}
                    \begin{split}
                    
                    x_n &= \frac{1-(-1)}{r-l} x_p + \alpha \\
                    x_n &= \frac{2}{r - l} x_p + \alpha  \\
                      1 &= \frac{2}{r - l} r + \alpha  \\
                      \alpha &= 1 -   \frac{2}{r - l} r \\
                      \alpha &= -\frac{r + l}{r - l} \\ 
                    x_n &= \frac{2}{r - l} x_p - \frac{r + l}{r - l} \\ 
                    x_n &= \frac{2}{r - l} \frac{nx_e}{-z_e} - \frac{r + l}{r - l} \quad \because x_p = \frac{nx_e}{-z_e} \\ 
                    x_n &= \frac{ \frac{2n}{r-l}x_e +  \frac{r + l}{r - l}z_e }{-z_e} \\ \\

                    \end{split}
                    \end{align*}
                    </div>

                    <div class="cen">
                    <img src="../image/yeyn.png" width="40%" height="40%" /><br>
                    </div> 

                    <div style="font-size:140%;" class="mytext">
                    \begin{align*}
                    \begin{split}
                    y_n &= \frac{1-(-1)}{t - b} y_p + \beta \\
                    y_n &= \frac{2}{t - b} y_p + \beta \\
                      1 &= \frac{2}{t - b} r + \beta \\
                   \beta &=  -\frac{t + b}{t - b} \\
                    y_n &= \frac{2}{t - b} y_p - \frac{t + b}{t - b} \\ 
                    y_n &= \frac{2}{t - b} \frac{ny_e}{-z_e} - \frac{t + b}{t - b} \quad \because y_p = \frac{ny_e}{-z_e} \\ 
                    y_n &= \frac{ \frac{2n}{t - b}y_e +  \frac{t + b}{t - b}z_e }{-z_e} \\ \\

                    \end{split}
                    \end{align*}
                    </div>

                    <div class="cen">
                    <img src="../image/zezn.png" width="40%" height="40%" /><br>
                    </div> 
                    <div style="font-size:140%;" class="mytext">
                    \begin{align*}
                    \begin{split}

                   \text{Similary} \\

                   z_n    &= \frac{1-(-1)}{n - f} z_p + \gamma \\
                   z_n    &= \frac{2}{n - f} z_p + \gamma \\
                   z_n    &= -1 \quad z_p = -n \\
                   -1     &= \frac{2}{n-f} - n + \gamma \\
                   \gamma &= \frac{n + f}{n - f} \\
                   z_n    &= \frac{2}{n-f} z_p + \frac{n+f}{n-f} \quad \because z_p =  \frac{(n+f) z_e + nf}{-z_e} \\
                   z_n    &= \frac{2}{n-f} \frac{[(n+f) z_e + nf]}{-z_e} + \frac{n+f}{n-f} \\
                   z_n    &= \frac{2}{n-f} \frac{[(n+f) z_e + nf]}{-z_e} + \frac{(n+f)(-z_e)}{(n-f)(-z_e)} \\
                   z_n    &= \frac{(n+f)z_e + 2nf}{(n-f)(-z_e)} \\
                   z_n    &= \frac{\frac{n+f}{n-f}z_e}{-z_e} + \frac{ \frac{2nf}{n-f}}{-z_e} \\
                    \end{split}
                    \end{align*}
                    </div>
                    
                    <div class="mytitle">
                    Projection matrix maps Frustum to View Volume, or map Frustum to Cube
                    </div>
                    <div class="cen">
                    <img src="../image/ndc_cube.svg" width="60%" height="60%" /><br>
                    <img src="../image/mapforumtondc.png" width="40%" height="40%" /><br>
                    </div> 

                    <div style="font-size:140%;" class="mytext">
                    \begin{align*}
                    \begin{split}

                   \left[ \begin{array}{c} 
                    x_n \\ 
                    y_n \\
                    z_n \\
                    w_n \\
                    \end{array} \right] 
                    &= \begin{bmatrix} 
                    \frac{2n}{r-l} & 0              & \frac{r+l}{r-l} & 0 \\
                    0              & \frac{2n}{t-b} & \frac{t+b}{t-b} & 0 \\
                    0              & 0              & \frac{n+f}{n-f}  & \frac{2nf}{n-f} \\
                    0              & 0              & -1                & 0 \\
                    \end{bmatrix} 
                   \left[ \begin{array}{c} 
                    x_e \\ 
                    y_e \\
                    z_e \\
                    w_e \\
                    \end{array} \right] \\

                    \end{split}
                    \end{align*}
                    </div>
                    <pre class="prettyprint">
                    glFrustum(left, right, bottom, top, near, far)
                    glFrustum(l, r, b, t, n, f)
                    </div>

                    <div class="mytitle">
                    Orthogonal Matrix 
                    </div>
                    <div class="mytext">
                    gluOrtho2D[left, right, bottom, top];
                    </div>

                    <div class="cen">
                    <img src="../image/glortho.png" width="40%" height="40%" /><br>
                    </div> 

                    <div class="mytitle">
                    Lighting in OpenGL 
                    </div>
                    <div class="mytext">
1. Enable Lighting in OpenGL
    glEnable[GL_LIGHTING]

2. Setup Light position in OpenGL
    glEnable[GL_LIGHT0] // enable light0

3. Setup Normal for Light in OpenGL
    compute the normal of vertex, OpenGL uses normal to compute the light

4. Setup material for Light in OpenGL
   In OpenGL, there are something call "Material Properties" 
   GL_DIFFUSE   - there are two characteristics: Diffuse reflection and Specular reflection.
                - Diffuse reflection reflects light in different directions.
                - Specular reflection reflects more light in mirror direction.
   GL_AMBIENT   - Ambient light is the light come from different direction.
   GL_SPECULAR  - The property sets the specular color. Note that the specular color for most surface is white, event if the surface is a different color.
   GL_EMISSION  - The emission property is how much the surface generates its own light 
   GL_SHININESS - This determine how much shiny a surface is. Values from 0 to 128
                    </div>
                    <pre class="prettyprint">
// enable light
glEnable(GL_LIGHTING)

// enable GL_LIGHT0
glEnable(GL_LIGHT0)

// setup normal
glNormal3d(0, 1, 0)

// setup material
glfloat cyan[] = {0.0f, 0.8f, 0.8f, 1.f}
glMaterialfv(GL_FRONT, GL_DIFFUSE, cyan);
                   </pre>
                    <div class="mytitle">
                    Transparent or Blender 
                    </div>
                    <div class="mytext">
                    1. Enable Blender in OpenGL
                    2. Use glColor4f instead of glColor3f
                    3. set each vertex for different colors
                    </div>
                    <pre class="prettyprint">
                    glEnable(GL_BLEND);
                    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

                    glColor4f(0, 0, 1, 0.5) // alpha = 0.5
                    </pre>
                    <div class="cen">
                    <img src="../image/blender.png" width="40%" height="40%" /><br>
                    </div> 

</div>
</body>
</html>

