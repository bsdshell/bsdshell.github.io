<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB">
<head>
    <title>What is Monad in Haskell</title>
    <meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
    <meta name="description" content="Xcode Change Build from iPhone to Universal iPad " />
    <meta name="keywords" content="Build iPhone and iPad, Change Xcode Build Target " />
    <meta name="robots" content="index, follow" />
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="stylesheet" type="text/css" href="../screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../highlight.css">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX","output/HTML-CSS"],
            tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
          });
    </script>
    <script type="text/javascript" src="../MathJax-2.6-latest/MathJax.js"></script>
</head>
<body>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66282017-2', 'auto');
  ga('send', 'pageview');
</script>

<div class="myclass">

<div class="mytitle">
What is Monad in Haskell
</div>
<p class="art">
There are hundreds of thousands of posts about Monad in Google search.
Many people just threw out endofunctor, morphism and nature transformation and so on. 
If you read more posts, you will get more confusing about <strong>Monad</strong>
In fact, Monad is very simple definition in term of abstract algebra.
Monad can be understood in three steps: 
\[
\text{ Group } \mathbf{G} => \text{ Monoid } \mathbf{S} => \text{ Monad } \mathbf{M}
\]
</p>

<p class="art">
What is semigroup <br>
Semigroup is like a group without inverse and identity. It is Associativity only.
</p>
\begin{align*}
\forall a, b, c &\in S \\
a \otimes b \otimes c &= a \otimes b \otimes c \\
\end{align*}

<p class="art">
What is Group?<br>
Here is the informal definition of Group:<br>
Given a set $S$, all the elements are closed under a binary operation denoted as $\otimes$ and  
the binary operation $\otimes$ is associative. Each elements has its own inverse and there is identity in the set $S$.

\begin{align*}
    \forall a, b, c &\in S \\
    (a \otimes b) \otimes c                   &= a (\otimes b \otimes c) &\quad \text{Associative}\tag{1} \\
    \exists I, I \otimes a                    &= a \otimes I = a         &\quad \text{Identity} \tag{2} \\
    \exists a' \in S, a \otimes a' &= a' \otimes a = I                   &\quad \text{Inverse}  \tag{3} \\
\end{align*}
<h3>Concret example</h3>
Given a $S = \{0, 1, 2, \dots \}$ and let $a = 1,  b = 2, c = 3, \quad I = 0, a' = -1, \quad \otimes = +$
\begin{align*}
    (1 + 2) + 3  &= 1 + (2 + 3) \quad &\text{ satisfy } (1) \\
    0 + 1        &= 1 + 0 = 1 \quad &\text{ satisfy } (2)  \\
    -1 + 1       &= 1 + (-1) = 0 \quad &\text{ satisfy } (3)  \\
\end{align*}

</p>


<div style="font-size:130%">
What is Monoid? <br>
Monoid is a group without the third condition (3), it means each element does not need to have inverse in Monoid.

</div><br>
<img src="../image/semigroup_group.jpg" width="100%" height="100%" /><br>
</div> 

\begin{align*}
    \forall a, b, c &\in S \\
    (a \otimes b) \otimes c                   &= a \otimes (b \otimes c) \tag{1} \\
    \exists I, I \otimes a                    &= a \otimes I = a          \tag{2} \\
\end{align*}
<h3>Example 1: List concatenation can be defined as Monoid</h3>
What are the elements in Monoid?<br>
If we define $\Sigma = \{a, b, c, \dots , z\}$ all the strings in $\Sigma^{*}$ are elements. <br> <br> 
What is the operation? <br>  
The operation can be defined as <strong>string concatenation</strong> or ++ in <strong>Haskell</strong> <br> <br>  
What is the identity? <br> 
The <strong>identity</strong> can be defined as empty string, e.g. [] in <strong>Haskell</strong> <br> 
\begin{align*} 
    \otimes &= \text{ ++ }, \quad I = [] \\
    \text{ Given }a &= [a], \quad b =[e, f], \quad c = [h, i] \\ 
    a \text{ ++ } b \text{ ++ } c     &= [a, e, f, h, i] \\ 
    a \text{ ++ } (b \text{ ++ } c)   &= [a] \text{ ++ } [e, f, h, i] = [a, e, f, h, i] \\ 
    => a \text{ ++ } b \text{ ++ } c  &= a \text{ ++ } (b \text{ ++ } c)  \quad   \text{ Associativity } (1) \\ 
    [] \text{ ++ } [a]       &= [a] \text{ ++ } []           = [a]      \quad   \text{ Identity } (2) \\ 
\end{align*}

<h3>Example 2: $\gcd(,)$ is a Monoid</h3>
What is the operator?<br>
The operation is $\gcd(, )$<br>

What is the identity?<br>
The identity is $0$ since $\gcd(0, x) = x$ assume $x \neq 0$<br>

Associtivity:<br>
$\gcd(\gcd(a, b), c) = \gcd(a, \gcd(b, c))$<br>

In Haskell: Use the Monoid properties: <br>
find the gcd of list of Integer in Haskell<br>
foldr(gcd) 0 [10, 8, 20] = 2 

</div>

<p class="art">What is morphism?<br>
Morphism is preserving structure in mathematic objects such as Set, Group, Ring, Vector Space, Topology Space an so on.<br>
The morphism for Set are functions. <br>
The morphism for Group is homorphisms, isomorphism.  <br> 
The morphism for Ring is homorphisms, isomorphism. <br> 
The morphism for Vector Space is linear transformation. <br> 
The morphism for Topology Space is Continuous functions. <br>
</p>

<h3>Informal definition of Category</h3>
<div style="font-size:130%">
Categories is defined as following: <br>
1. Objects - it likes integer in $\mathbf{N}$ <br>
2. Arrows -  it likes function that we are already known <br> 
3. There is Morphism/Arrow between any two Objects. <br>
4. Each Object has Arrow to its self. (like identity function)<br>
5. The composition of Morphism/Arrows are associative<br> <br> 

Concrete example: [Arrow == Morphism]<br>
Vector Space $\mathscr{V}$ with a set of linear maps $\mathscr{L}$ is a Category<br>
1. Objects - vectors in $\mathscr{V}$ <br>
2. Arrows - matrices in $\mathscr{L}$ <br>
3. Each pair of vectors, $u, v$ we can find a matrix such as $A u = v$<br>
4. Each vector, we can find an identity matrix to transform the vector to its self. $I v = I A = v$ <br>
5. Matrix composition(multiplicaiton) is associative, e.g. $A B C = A (B C)$<br> <br> 
</div>

<div class="cen">
<img src="../image/vector_space_to_category.jpg" width="50%" height="50%" /><br>
</div> 

<h3>What is Functor</h3>
<div style="font-size:130%">
<strong>Functor</strong> is mapping both objects to objects and morphisms to morphisms in Categories.<br><br>
Abstractly defined, a <strong>functor</strong> is a homomorphism between two categories: 
Given two Categories $A, B$, 
a functor $F: A \rightarrow B$ consists two mapppings:<br>
<strong>one maps objects to objects,</strong>
<strong>the other maps arrows to arrows.</strong><br>
Both maps are not always though denoted by the same letter $F$<br>

The two components mappings of a functor $F$ are required to satisfy the property<br>
    \[ F(f) : F(A)\rightarrow F(B) \text{ whenever } f: A \rightarrow B \] <br>
They are also to required to preserve identities and composition: <br>
    \[ F(id_{A}) = id_{F(A)} \text{ and } F(f \circ g) = F(f) \circ F(g) \] <br> 


The definition of Functor can be confusing without some abstract algebra concept such as homomorphism or isomorphism.<br>
In abstract algebra, if two groups are homomorphic, then two group need to satisfy the following conditions: <br>   
Given two groups: 
\begin{align*} 
&(G, \oplus), (H, \otimes) \text{ and } g_1, g_2 \in G  \\
&\text{ If there exists } \phi: G \rightarrow H, \text{ such as } \\ 
    &\phi(g_1 \oplus g_2) = \phi(g_1) \otimes \phi(g_2)  \tag{1} \\
    &\phi(1_g) = 1_h \tag{2} \\
    &\text{ then } \phi \text{ is the homomorphism from } (G, \oplus) \text{ to } (H, \otimes)  \\
    &\text{Or } (G, \oplus) \text{ and } (H, \otimes) \text{ are homomorphic}
\end{align*}

The homomorphism $\phi$ is like a map $F$: mapping $(f = \oplus)$ to multiplicaiton $(g = \otimes)$ <br>  
Example: Given two groups  $G(+, \Re), H(*, \Re)$ and function $\phi(x) = e^x$, it is easy to show $\phi$ is homomorphism from $G$ to $H$
\begin{align*} 
    G(+, \Re)            & \xrightarrow{\phi(x)} G(*, \Re) \\
    \text{Let } x, y     & \in \Re  \\
    \phi(x + y)          & = e^{x + y} \\
    \phi(x) * \phi(y)    & = e^x * e^y = e^{x + y} \\
    \implies \phi(x + y) & = \phi(x) * \phi(y)  \\ \\
\end{align*}
Let the inverse of $\phi(x) = e^x$ is $\phi^{-1}(x) = \log x$ <br>

\begin{align*} 
    G(*, \Re)                   & \xrightarrow{\phi^{-1}(x)} G(+, \Re) \\
    \text{Let } x, y            & \in \Re  \\
    \phi^{-1}(x*y)              & = \log(x*y) = \log x + \log y \\
    \phi^{-1}(x) + \phi^{-1}(y) & = \log x + \log y \\
    \implies \phi^{-1}(x*y)     & = \phi^{-1}(x) + \phi^{-1}(y) \\
\end{align*}

<strong>Identical Morphism</strong><br>
For every object $X \in \mathcal{C}$, there is identity morphism $1_X : X \rightarrow X$ by definition of Category. It satisfies:
<script type="math/tex; mode=display">
\begin{align*}
    1_x \circ f = f, \text{ for all objects } Y \in \mathcal{C} \quad \text{ where morphism } \quad f:Y \rightarrow X \\
    f \circ 1_x = f, \text{ for all objects } X \in \mathcal{C} \quad \text{ where morphism } \quad f:X \rightarrow Y
\end{align*}
</script>

<strong>Identical Functor</strong><br>
There is functor $I_C : \mathcal{C} \rightarrow \mathcal{C}$ with properties: <br>
\begin{align*}
    I_C(X) &= X, \forall X \in \mathcal{C} \\
    I_C(f) &= f, \text{ for every pair of } X, Y \in \mathcal{C} \text{ and morphism } f: X \rightarrow Y
\end{align*}

<strong>Functor is similar to homomorphism in Groups, but it is defined in Category</strong><br> 
and the two conditions are almost identical from (1) and (2) <br> <br> 
Given two Categories $C$ and $D$,  $X \in Obj(C), Y \in Obj(D)$ <br> 
A Functor $F: C \rightarrow D$ is defined as following: <br> 
For each object $X \in C$, there is associatived object $F(X) \in D$ <br>
For each map $f \in C$, there is associatived map $F(f) \in D$ <br><br>

</div>

<div class="cen">
<img src="../image/functor_image.jpg" width="60%" height="60%" /><br>
</div> 

<div style="font-size:130%">
<strong>The two conditions are similar to Group Homomorphism</strong><br> 
\begin{align*}
&\text{left and right identity} \\
&id:x \rightarrow x, F:X \rightarrow Y, x \in X, y \in Y \\
&id(x) = x, F(id(x)) = y \\
&F(x) = y, id(F(x)) = y \\
&\implies F(id(x)) = id(F(x)) \text{ or } F(id_x) = id(F_x)\\
&\text{ Morphism has to admit associative composition} \\
&\text{If } f \in C(X, Y), g \in D(Z, Y), \text{ then }, f \circ g \in C \text{ and } F (f \circ g) = F(f) \circ F(g) \in D \\ 
\end{align*}

Build on top of the definitions of Monoid and Functor above, we can define what is <strong>Monad</strong><br>
If you understand (+ $\Re$) is a <strong>Group</strong>, then Monad is just a Monoid and the elements are functors. <br><br>

Formal definition of Monad that No one understand:
Monad is endofunctor equipped two nature transformation $\eta$ and $\mu$
\begin{align*}
    \eta : I & \rightarrow T \\
    \mu : T . T & \rightarrow T \\
\end{align*}
translate above definition to Haskell: <br>
nature transformation is just Polymorphic Function in Haskell <br>
functor is just Type Constructor, e.g. ([]):: a -> [a], input type a and return new type [a] <br>
\begin{align*}
    return :: a &\rightarrow m \, a \\
    join T . T &\rightarrow T  \\
\end{align*}

$(+, \Re)$ is => <strong>Group</strong>, the <strong>operation</strong> is $+$, the elements are real numbers <br>
Monad      is => <strong>Monoid</strong>, the <strong>operation</strong> is Functor composition, the elements are just Functors<br>

Monad is analogic to (+ $\Re$), Monoid has two axioms: (1) (2) from definition. <br>
Monad is Monoid so it need to satisfy two axioms: Associativity and Identity 

\begin{align*}
    \forall a, b, c &\in S \\
    (a \otimes b) \otimes c                   &= a \otimes (b \otimes c) \tag{1} \\
    \exists I, I \otimes a                    &= a \otimes I = a          \tag{2} \\
\end{align*}

Now $S$ is the set of functors, $a, b, c$ are functors, $\otimes$ is functor composition<br><br>
In Haskell
>>= is used for functor composition <br>
<strong>return</strong> is used for identity functor <br><br>

<strong>Functor</strong> is modelled with <strong>Type Constructor</strong> in Haskell

$T$ is functor or some nerds call it endofunctor<br> 
endofunctor - $F : \mathcal{C} \rightarrow \mathcal{C}$, the domain and image are the same <strong>Category</strong>
\begin{align*}
    \mu &: T \times T \rightarrow T  \quad \text{ where } T \text{ is endofunctor}     \\ 
    \mu T &: (T \times T) \times T \rightarrow T^2  \\
    T \mu &: T \times (T \times T) \rightarrow T^2  \quad \text{Associativity law in Monoid}\\
    \mu T &= T \mu  \quad \text{from commutative diagram} \\
    T \mu \mu   &= T \\
    \mu T \mu &= T \\
    T \mu \mu &= \mu T \mu \\
    \eta &: I  \rightarrow T              \\ 
    \mu_a &: T \times T a \rightarrow T a \\ 
    \eta_a &: I a \rightarrow T a     \quad \text{ where } I \text{ identity endofunctor }    \\ 
\end{align*}
In Haskell:<br>
join::m(m a) $\rightarrow$ m a <br>
join [[1]] $\rightarrow$ [1] <br><br>

return::(Monad m)=> a $\rightarrow$ m a <br>
return 3 $\rightarrow$ m 3 <br>

There is some interested fact about the two <strong>nature transformation</strong> <br> 
e.g. commutative diagram: <br>
\begin{align*}
    T \circ \mu &: T^3 \rightarrow T^2  \\
    T \circ T \circ \mu &: T^3 \rightarrow T^2 \rightarrow T \\
    \mu \circ T &: T^3 \rightarrow T^2  \\
    T \circ \mu \circ T &: T^3 \rightarrow T^2 \rightarrow T \\
\end{align*}
</p>

</div>


</div>

</body>
</html>
