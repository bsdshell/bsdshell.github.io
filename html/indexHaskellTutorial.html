<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB">
<head>
	<title>What is Moand?</title>
	<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
	<meta name="description" content="Haskell Snippet" />
	<meta name="keywords" content="Haskell example, Haskell Hello World, Haskell Binding, Haskell Typeclass, Foldable" />
	<meta name="robots" content="index, follow" />
	<link rel="shortcut icon" href="/favicon.ico" type="../image/x-icon" />
	<link rel="stylesheet" type="text/css" href="../screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../highlight.css">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Google prettify.  Sun Sep 11 00:57:25 PDT 2016 -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX","output/HTML-CSS"],
            tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
          });
        </script>
    <script type="text/javascript" src="../MathJax-2.6-latest/MathJax.js"></script>
</head>
<body>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66282017-2', 'auto');
  ga('send', 'pageview');
</script>

            <div class="mytitle">
            Transpose a matrix 
            </div>
            <pre class="prettyprint">
            transpose::[[a]] -> [[a]]
            transpose [] = repeat []
            transpose (x:cx) = zipWith(:) x $ transpose cx

            transpose [[1, 2]
                       [3, 4]]

             zipWith(:) [1, 2] $ transpose [[3, 4]]
                 [[3],[4] <= zipWith(:) [3, 4] $ transpose [[], []..]

             zipWith(:) [1, 2] [[3], [4]] => [[1, 3], [2, 4]]
            </pre>
            
            <div class="mytitle">
            The difference among of data, type and newtype 
            </div>
            <pre class="prettyprint">
            data MyClass = Type1 | Type2 String | Type3 Int

            class MyClass{
                public Type1(){}
                public Type2(String s){}
                public Type3(Integer s){}
            }

            type Str = String

            // typedef in C
            typedef Str String; 

            // typedef in C
            typedef struct Persons{
                char[] name;
                int age;
            } Person;

            Person p;

            There is not type alias in Java unfortunately

            newtype NewType a = NewType{name::String -> a}
            </pre>

            <div class="mytitle">
            Haskell Array 
            </div>

            <pre class="prettyprint">
            import Data.Array
            import Data.Text.TDFA

            let ar = array(0, 10) [(i, i*i) | i <- [0..10]]
            ar ! 1 => 1
            </pre>

            <div class="mytitle">
            Factorial Function in Haskell 
            </div>
            <pre class="prettyprint">
            fac::Integer -> Integer
            fac 0 = 1
            fac n = n * fac (n - 1)
            fac n = if n == 0 then 1 else n*fac (n - 1)
            </pre>


            <div class="mytitle">
            Find all prime number in Haskell
            </div>
            <pre class="prettyprint">
            prime = sieve[2..]
                    where sieve(p:xs) = p:sieve[ x | x <- xs, mod x p /= 0] 

            -- sieve[2, 3, 4, 5, 6]
            --    2:sieve([3, 5]) 
            --        2:3:sieve([5])
            --            2:3:5:sieve([])
            </pre> 

            <div class="mytitle">
            Split String in Haskell 
            </div>
            <pre class="prettyprint">
            break(\x -> isDigit x == False) "123dog"
            -- ("123", "dog")

            break(\x -> isSpace x) "123  dog"
            -- ("123", " dog")

            filter(\x -> isDigit x) "123dog" 
            -- "123" 

            let reg = mkRegex "[[:space:]]+"
            splitRegex r "Agentina Switzerland Sweden"
            -- ["Agentia", "Switzerland", "Sweden"]

            -- split string at a particular position 
            splitAt 3 "Agentina" -- ["Age", "ntina"]
            </pre>

            <div class="mytitle">
            Haskell class and instance
            </div>
            <pre>
            Haskell class and instance are very similar to template/generic, interface in Java/C++
            1. Create interface with generic
            2. Implement it with concrete type
            </pre>
            <pre>
            class Test a where
                tme::a -> a -> Bool 

            data Dump = Dump{int::Int, str::String} 

            instance Test Dump where
                tme d1 d2 = int d1 == int d2 
            
            -- test it
            let d1 = Dump{int=3, str="dog"}
            let d2 = Dump{int=3, str="dog"}
            print $ tme d1 d2   -- True
            </pre>

            <div class="mytitle">Functor in Haskell</div>
            <div class="cen">
                <img src="../image/functor1.png" width="40%" height="40%" />
            </div>
            <div style="font-size:140%;" class="mytext">
            Functor is like a box contains something inside such as Maybe or [1, 2].<br> 
            A function called <strong>fmap</strong> which takes a function and abox, <strong>fmap</strong>
            applies the function to the value inside thebox and return abox contains the result. <br><br>
            
            Functor can be formally defined by a pair of functions $f_1 \mbox{ and } f_0$<br> 
            so that $f_0:Ob(Hask) \rightarrow Ob(Hask)$ and $f_1:Hom(Hask) \rightarrow Hom(Hask)$<br>
            where $Hom(Hask)$ refers to the union of all sets $a \rightarrow b$ where $a, b \in Ob(Hask)$<br>
            so that the following holds<br><br>

             0. $id::a \rightarrow a $<br>
             1. If $g::a \rightarrow b $ then $f_1(g)::f_0(a) \rightarrow f_0(b)$<br> 
             2. For all $a \in \mbox{Ob(Hask)}, \quad f_1(id_a) = id_{f_0(a)} $<br>
             3. If $g,h \in \mbox{Hom(Hask)} \mbox{ then } \quad f_1(g \circ h) = f_1(g) \circ f_1(h)$<br><br>
             Given $f_0(a) = \mbox{List } a \quad f_1(g) = \mbox{ map } g   $<br><br>  
             Prove $f_0$ and $f_1$ is a Functor<br>
             
            \begin{equation}
            \begin{aligned}
              &f_0(a) \Rightarrow \mbox{ List } a \quad f_0(b) \Rightarrow \mbox{ List } b \quad \mbox{ [from 1] }  \\
              &\Rightarrow \quad f_1(g):: \mbox{ List }a \rightarrow \mbox{ List }b \\
              &\because \quad id_{f_0(a)}:: f_0(a) \rightarrow f_0(a)  \\
              &\therefore \quad id_{f_0(a)}:: \mbox{ List }a \rightarrow \mbox{ List }a   \\
              &\therefore \quad f_1(id_a):: \mbox{ List }a  \rightarrow \mbox{ List }a  \quad [\mbox{ from 1 } , \mbox{ sub } g::a \rightarrow b \mbox{ with } id::a \rightarrow a] \\
              &\Rightarrow  f_1(id_a) = id_{f_0(a)} \\~\\ 
              &f_1( g \circ h) \Rightarrow \mbox{ map } g \circ h \Rightarrow \mbox{ map } g \circ \mbox{ map } h \quad \mbox{ [from def. of map]} \\
              &f_1(g) \circ f_1(h) \Rightarrow \mbox{ map } g \circ \mbox{ map } h\\
              &\Rightarrow f_1( g \circ h) = f_1(g) \circ f_1(h)\\
              &\Rightarrow f_0 \mbox{ and } f_1 \mbox{ is a Functor} \\
            \end{aligned}
            \end{equation} 
            </div>

            <div class="mytitle">
            Picture of Functor 
            </div>
            <div class="cen">
            <img src="../image/monadpic.png" width="40%" height="40%" /><br>
            </div> 

            <div class="mytitle">
            Not everything is Functor
            </div>
            <div class="mytext">
            MyMaybe is not a Functor since it does't satify the SECOND rule given from above<br>
            </div>
            <pre class="prettyprint">
            data MyMaybe a = MNothing | MyJust Int a deriving(Show)

            instance Functor MyMaybe where
                fmap f MNothing = MNothing
                fmap f (MyJust counter a) = MyJust (counter + 1)  (f a) 

            main = do 
                    print "Hello World"
                    print $ fmap (+1) MNothing
                    print $ fmap (+1) (MyJust 0 2) 
                    print $ fmap (+1) $ fmap (+1) (MyJust 0 2) 
                    print $ fmap id (MyJust 0 2)
                    print $ id (MyJust 0 2)
                    -- fmap id (MyJust 0 2) != id (MyJust 0 2)
                    -- MyMaybe is not a Functor
            </pre>

            <div class="mytitle">Haskell IO action</div>
            <div class="mytext">
            Haskell separates pure functions from computations where side effects must be considered 
            by encoding those side effects as values of a particular type. 
            Specifically, a values of type [IO a] is an action, which if executed would product a value type of a
            </div>

            <div class="mytitle">[IO a] is an action</div>
            <pre class="prettyprint">
            getLine::IO String
            putStrLn::String-> IO()
            randomRIO::(Random a) => (a, a) -> IO a
            </pre>

            <div class="mytext">Some IO goodness</div>   
            <pre class="prettyprint">
            -- define a function to print out "Hello World"
            fun::IO()
            fun = putStrLn "Hello World"

            -- IO action is like a type.  
            putStrLn::String->IO ()  -- input is String, output is IO()
            
            fun::String->String      -- input is String, output is String
            </pre>

            <div class="mytitle">Chain the IO actions</div>
            <pre class="prettyprint">
            (>>)::IO a -> IO b -> IO b
            where if x and y are IO actions, then (x >> y) is the action performs x, dropping the result
            and then performs y and return its result. Great, we can now write programs which do multiple things

            main = putStrLn "Hello" >> putStrLn "World"
            </pre>

            <div class="mytitle">How to use the result of first action</div>
            <pre class="prettyprint">
            (>>=)::IO a -> (a -> IO b) -> IO b
            Now, (x >>= y) is the action first perform x, and capture its result, passing the result to f, 
            which then computes a second actions to be performed. The action is then carried out, 
            and its result is the result of overall computation.
            </pre>
            It does seem to make sense, but what is the concrete example
            
            <div class="mytitle">The definition of readFile and print are as following</div>
            <pre class="prettyprint">
            readFile::FilePath->IO String
            print::String->IO ()
            -- Chain readFile to print with >>=  
            readFile filePath >>=\file -> print file 
            </pre>

            <div class="mytitle">What you can come up a picture about IO monad</div>

            <div class="cen">
            <img src="../image/monadpic3.png" width="40%" height="40%" /><br>
            </div> 
            <pre class="prettyprint">
    <span class="bo">Definition of const</span> 
    const::a -> b -> a  [keep the first argument and throw away the second argument]
    It does't look that good from outside but some inside and be surprised [surprisedly]

    const 3 4 -- output 3

    >> <span class="bo">can be defined in term of</span> >>=
    x >> y == x >>= const y 
    or
    x >> y == x >>= \_ -> y

    How to turn a value to an IO action which do nothing
    return:: a -> IO a

    <span class="bo">Use IO in function</span>
    myReadFile::FilePath->IO String
    myReadFile f = readFile f >>=\contents -> return(contents)

    <span class="bo">How to use myReadFile ?</span>
    contents <- myReadFile "file.txt" 
    print contents

    <span class="bo">IO are first class</span>
    create control structure with IO
    
    repeat'::Int->IO () -> IO ()
    repeat' n a = a >> repeat'(n-1) a

    repeat' 3 putStr('x')   -- output xxx

    <span class="bo">create for loop</span>
    for::[a]->(a -> IO()) -> IO ()
    for [] f = return ()
    for (x:xs) f = f x >> for xs f

    for [1..10] (\x -> putStrLn x)
    
    for [1..10] (\x -> do
                putStrLn x
                putStrLn x
                )
    

    <span class="bo">Similarly </span>
    forM::(Traversable t, Monad m)=> t a -> (a -> m b) -> t(m b)

    let s = ["dog", "cat"]
    forM s $ \x -> print x
    dog 
    cat
    [(), ()]

        </pre>
            <pre class="prettyprint">
            -- get two Chars
            getTwoChars::IO (Char, Char) 
            getTwoChars   = getChar >>= \c1-> 
                            getChar >>= \c2 -> 
                            return (c1, c2) 
            -- do statement
            getTwoCharsDo::IO(Char, Char)
            getTwoCharsDo = do {
                                c1 <- getChar;
                                c2 <- getChar;
                                return (c1, c2) }

            -- get line with nested do
            getMyLine::IO [Char]
            getMyLine = do {
                            x <- getChar;
                            if x == '\n' then
                                return []
                            else do{
                                xs <- getMyLine;
                                return (x:xs)
                            }
                        }
            </pre>

            <span class="bo">Three weird primitives for composing and chaining together IO actions</span> 
            (>>)::IO a -> IO b -> IO b    [kill the first action's result and return the second action's result]
            (>>=)::IO a -> (a -> IO b) -> IO b   
            return::a -> IO a             [wrap a with IO and return it]

            class Monad a where
            (>>=)::IO a ->(a -> IO b) -> IO b
            return::IO a -> (a -> IO b) -> IO b

            class Monad m where
            (>>=)::m a ->(a -> m b) -> m b
            return::a -> m a 

            fun::[(Integer, Integer)]
            fun n = do
                x <- [-10..10]
                if x > 0 
                then []
                else return (n, n+1)

            Monad [] is the instance of Monad

            </pre>


            <div class="cen">
                <img src="../image/chain1.png" width="40%" height="40%" />
            </div>

            <div class="mytitle">Weird Haskell const</div>
            <pre class="mycode">
            <span class="bo">Definition of const in GHC</span> 
            const::a -> b -> a  [keep the first argument and throw away the second argument]
            
            const 1 2  -- output 1
            map(const 3) [1..4] -- output [3, 3, 3]

            <span class="bo">Implement repeat function</span>
            repeat'::Int->a->[a]
            repeat' n a = map(const a) [1..n]

            repeat' 3 "x" -- output ["x", "x", "x"]

            <span class="bo">Implement length function</span>
            let length' = foldr(\_ acc -> 1 + acc) 0

            let length' = foldr(const(1+)) 0

            <span class="bo">Three weird ways to define</span> >> 
            (>>)::IO a -> IO b -> IO b     [this is normal]
            x >> y = x >>= const y         [const is here to save you] 
            x >> y = x >>= \_ -> y         [lambda! Ok, it does make sense] 
            x >> y = (. const) . (>>=)     [that doesn't make sense for me at least]
            </pre>
            <div class="mytitle">let binder inside the map</div>
            <pre class="mycode">
            // let .. in .. => let something then return something
            let list = [1..10]
            map(\x -> let square = x*x in square `mod` 3 == 0) list

            -- let binding in Haskell
            -- ax^2 + bx + c = 0
            -- Find the root of the quadratic equation
            roots a b c =
                    let discriminant= sqrt(b^2 - 4*a*c)
                    in ( (-b + discriminant)/(2*a), (-b - discriminant)/(2*a))

            main =  do 
                    print (roots 3 9 1)
            </pre>

            <div class="mytitle">Haskell Binary Tree</div>
<pre class="prettyprint smallfont">
-- binary tree in Haskell
data Tree a = Empty 
            | Node a (Tree a) (Tree a) deriving (Show)

binsert::Tree Integer->Tree Integer->Tree Integer 
binsert Empty (Node a Empty Empty) = (Node a Empty Empty)
binsert (Node a l r) (Node b Empty Empty) = if b < a 
                                    then Node a (binsert l (Node b Empty Empty)) r 
                                    else Node a l (binsert r (Node b Empty Empty))   


-- build Binary Tree from preorder and inorder
buildTree::[Char]->[Char]->Tree Char 
buildTree _ [] = Empty
buildTree [] _ = Empty
buildTree preorder inorder = Node h  (buildTree leftPre leftIn) (buildTree rightPre  rightIn) 
                            where
                                h = head preorder
                                leftIn  = filter(\x->x < h) inorder
                                rightIn = filter(\x->x > h) inorder
                                leftPre = take (length rightIn) $ tail preorder 
                                rightPre = subList preorder (length leftIn) $ length preorder

-- In order traversal in Binary Tree
inorder::Tree a->[a]
inorder Empty = []
inorder (Node a l r) = (inorder l) ++ [a] ++ (inorder r) 

-- check whether a Binary Tree is symmetric 
sym::Tree a ->Bool
sym Empty = True
sym (Node a Empty Empty) = True
sym (Node a l Empty) = False 
sym (Node a Empty r) = False 
sym (Node a l r) = sym l && sym r 

-- find the maximum number of nodes in a Binary Tree
maxlen::Tree a->Integer
maxlen Empty = 0 
maxlen (Node a l r) = 1 + max (maxlen l) (maxlen r)

-- find the maximum height of a Binary Tree
maxheight = maxlen - 1

</pre><br>

<div class="mytitle">
What is difference between <span style="color:red;">Expr</span> and <span style="color:red;">Expr a</span>
</div>
<pre class="mytext">
It is hard to figure out the difference between Expr and Expr a in Haskell
data Expr is type Int only
data Expr a can be any type as 'a' 
</pre> 

<pre class="prettyprint">
data Expr = Expr Int 
            | Add Expr Expr
            | Mul Expr Expr
data Expr a = Con a 
            | Add (Expr a) (Expr a)
            | Mul (Expr a) (Expr a)
</pre><br>
    
    <div class="mytitle">
    If you implement Monoid in the modern GHC, you need to implement Semigroup
    </div>
    <div style="font-size:130%;" class="mytext">
    Semigroup $(\otimes, S)$: 
    let $a, b, c, d \in S$
        \[ 
            a \otimes b \otimes c = a \otimes (b \otimes c) \in S
        \] 
    <br>
    Monoid $(\otimes, S, I)$: 
    let $a, b, c \in S$
        \begin{equation}
        \begin{aligned}
            a \otimes b \otimes c &= a \otimes (b \otimes c) \in S \\
            I \otimes a &= a \otimes I
        \end{aligned}
        \end{equation} 
    Group $(\otimes, S, I)$
    let $a, b, c \in S$
        \begin{equation}
        \begin{aligned}
            a \otimes b \otimes c &= a \otimes (b \otimes c) \in S \\
            I \otimes a &= a \otimes I \\
            \forall a \in S, \exists a^{-1} \mid a \otimes a^{-1} &= I \\
        \end{aligned}
        \end{equation} 
    </div>
    <pre class="prettyprint">
    newtype Sum = Sum{getSum::Int} where deriving (Show)
    
    class Semigroup a where
        (<>):: a -> a -> a

    instance Semigroup Sum where
        (<>)::(Sum x) (Sum y) = Sum (x + y)

    instance Monoid Sum where
        mappend = (<>)
        mempty = Sum 0

    foldr((<>)) (Sum 0) [(Sum 1), (Sum 2)] => Sum{getSum = 3}

    </pre><br>

<div class="mytitle">
Why Haskell <span style="color:red;">Record</span> is so BAD 
</div>
<pre class="prettyprint">
data Person = Person{
        name::String,
        age::Int
        }

data Dog = Dog{
        name::String,
        age:Int
        }

-- Record is just like function
name::Person -> String 
age::Person -> Int

let rec = Person {name ="David", age = 3}
name rec -- return David
age rec  -- return 3

</pre>
<div class="mytitle">
You will get compiler error with two differnet records
</div>
<pre class="mytext">
From above two records: Person and Dog.
They both have name::Text 
In Haskell, name is just a function, it is global. 
This is why you can NOT have the same name and in different records. 
</pre><br>
<pre class="mytext">
Haskell record is similar to Java Class without methods.
You can not have function inside record in Haskell.
-- | If you are Java or C++ guys, you might do something like that:
-- | There are lots of typing without doing anything useful here:)
Java needs 23 lines of code
Haskell needs 4 lines of code
Of couse there are Setter and Getter generator like Lombok to do that work in Java
but you need to import the libraries and manage the dependency.
</pre>
<pre class="prettyprint">

public class{
    String firstName;
    String lastName;
    Int    age;
    public String getFirstName(){
        return firstName;
    }
    public String getLastName(){
        return lastName;
    }
    public Int getAge(){
        return age;
    }
    public void setFirstName(String firstName){
        this.firstName = firstName;
    }
    public void setLastName(String lastName){
        this.lastName = lastName;
    }
    public void setAge(Int age){
        this.age = age;
    }
}


-- | /Users/cat/myfile/bitbucket/haskell/Record.hs
-- 
-- | create record called Person with three fields:
-- | firstName, lastName and age
data Person = Person {
    firstName::String, 
    lastName::String, 
    age::Int} deriving (Eq)

-- | Set some values for the Person, it is very simple, 
-- | You do not need Setter.
-- | -------------------------------------------------------------------------------- 
let person = Person{firstName = "Jonathan", lastName = "Michell", age = 20}
let animal = Person{firstName = "Nonhuman", lastName = "Michell", age = 20}

-- | How to access the fields, there are Getters for us by default 
-- | -------------------------------------------------------------------------------- 
pp $ "firstName=" ++ firstName person  -- Jonathan
pp $ "lastName =" ++ lastName person   -- Michell 
pp $ "age      =" ++ show(age person)  -- 20 
-- | -------------------------------------------------------------------------------- 
</pre>
<pre class="mytitle">
Haskell Record with <span style="color:red;">IORef</span>
</pre>
<pre class="mytext">
IORef is tricky to use initially if you are from Java or C++, If you combine Record with IORef
then it is harder to figure out how the syntax work
1. We want to create a Counter with two fields, both fields are Int type, nothing is revolutionary 
2. Increate each fields by certain number
3. Show the certain field
</pre><br>
<div style="font-size:120%;" class="mytext">
Create Record with two fields:<br>
    1. Pos::IORef Int => $Pos \in \{IORef Int\}$<br>
    2. Up::IORef Int => $Up \in \{IORef Int\}$<br>
</div>
<pre class="prettyprint">
data Count = Count{
    pos :: IORef Int,
    up :: IORef Int
    }
</pre>
<pre class="mytext">
1. Create Counter 
2. Create incremental functions 
3. Create the show function
</pre>
<pre class="prettyprint">
    makeCounter::Int->Int-> IO Count
    makeCounter c u = do 
            c' <- newIORef c  
            u' <- newIORef u  
            return (Count c' u')  

    intPosCounter::Int->Count->IO() 
    intPosCounter n (Count c _) = modifyIORef c (+n) 

    intUpCounter::Int->Count->IO() 
    intUpCounter n (Count _ u) = modifyIORef u (+n) 

    showCounter::Count->IO()
    showCounter (Count c u) = do   
                         c' <- readIORef c
                         u' <- readIORef u 
                         pp (show c' ++ " " ++ show u') 

</pre>
<pre class="mytitle">
What does <span style="color:red;">do-statement</span> do in Haskell
</pre>
<pre class="mytext">
do-statement is syntax sugar for Monad Computation??
</pre>
<pre class="prettyprint">
    readFileToList path >>= \x -> reverse x
    do {
        s <- readFileToList path
        let s = reverse s  
    }
</pre>

<pre class="prettyprint">
    nameDo::IO String
    nameDo = do putStr "What is your first name: "
                first <- getLine
                putStr "What is your last name: "
                last  <- getLine
                let full = first ++ " " ++ last
                putStrLn("full name " ++ full ++ " ")
                return full

    main = nameDo >>= \name -> print name

    -- alternative
    main = do
        name <- nameDo
        print name
</pre>
<pre class="mytitle">
How <span style="color:red;">liftM</span> can help you to simplify your IO code
</pre>
<pre class="mytext">
liftM defintion:
liftM::(Monad m)=>(a -> b) -> m a -> m b

not::Bool -> Bool
not true = false
not false = true

liftM not
liftM::(Monad m)=>(Bool -> Bool) -> m Bool -> m Bool

</pre>
<pre class="mytitle">
Real world example with <span style="color:red;">liftM</span>
</pre>
<pre class="prettyprint">
-- find all the file that does not exist from a list
filterM(\x -> doesFileExist x >>= \y -> return y == false) ["f1.x", "f2.x"]

-- if we find all the files DOES exist in the list, it is easy
filterM(doesFileExist) ["f1.x", "f2.x"]

-- better way to do with liftM
filterM((liftM not) . doesFileExist) ["list files"]
</pre><br>

<div class="mytitle">
How to exit Haskell program 
</div>
<pre class="prettyprint">
Single Thread:

main = do 
    print "start"
    exitFailure
    print "nothing to show"

That code will set exit code to 0
e.g. echo $? => 0 

main = do 
    print "start"
    exitWith(ExitFailure 3)
    print "nothing to show"

e.g. echo $? => 3
You can use exitWith(...) to set exit code whatever you want

Multiple Thread is different story.

import Control.Exception.Safe
import System.Exit
import Control.Concurrent

main = do 
    print "start"
    forkIO(exitWith(ExitFailure 3))
    print "nothing to show"

echo $? => 0
You do not get 3 now, 
plz take a look at exitWith::ExitCode -> IO a
forkIO creates worker thread, and 
the exit code does not propagate to the parent thread

main = do 
    print "start"
    concurrently (exitWith(ExitFailure 3)) $ do
    print "nothing to show"

echo $? => 0
The exit code propagates to parent thread with concurrently, 

</pre>

<div class="mytitle">
zip and unzip in Haskell
</div>
<pre class="prettyprint">
zip ["dog", "cat"] [1, 2] => [("dog", 1"), ("cat", 2)]
unzip [("dog", 1"), ("cat", 2)] => ["dog", "cat"] [1, 2]
</pre>
<div class="cen">
<img src="../image/zip_unzip.jpg" width="80%" height="80%" />
</div> 

<div class="mytitle">
Simple Typeclass in Haskell
</div>
<pre class="mytext">
1. define a typeclass Shape with two constructors
Shape a is type class or type constructor
Circle Float Float Float is one constructor with three floats or value constructor
Rectangle Float Float Float Float is value constructor with four floats
</pre>
<pre class="prettyprint">
-- Typeclass in Haskell
-- Shape is similar to interface in Java(but it is different)
-- Circle and Rectangle are similar to class in Java

-- sum type
data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)

area::Shape->Float
area(Circle _ _ r) = pi*r^2
area(Rectangle topx topy bottomx bottomy) = abs(bottomy - topy)*abs(bottomx - topx)

-- or
data Shape a = Circle a a a | Rectangle a a a a deriving (Show)
area::Shape Float -> Float
area (Circle _ _ r) = pi*r^2
area (Rectangle topx topy bottomx bottomy) = abs(bottomy - topy)*abs(bottomx - topx)

main = do 
        print("Typeclass in Haskell")
        print(area $ Circle 3 4 5)
        print(area $ Rectangle 3 4 5 8)
</pre>

            <div class="mytitle">Sum all integers in a list in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- Sum all the integer in a list</span>
<span class="nf">sumlist</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">sumlist</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sumlist</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span><span class="o">+</span><span class="n">sumlist</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">Palindrome in Haskell</div>
            <div class="highlight"><pre><span class="nl">isPalindrome:</span><span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span><span class="o">=&gt;[</span><span class="n">a</span><span class="o">]-&gt;</span><span class="n">Bool</span>
<span class="n">isPalindrome</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">True</span>
<span class="n">isPalindrome</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="nf">isPalindrome</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="o">(</span><span class="n">last</span> <span class="n">xs</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">init</span><span class="o">(</span><span class="n">xs</span><span class="o">))</span>

<span class="n">main</span> <span class="o">=</span> <span class="k">do</span>
        <span class="n">print</span> <span class="o">(</span><span class="s">&quot;aba=&quot;</span><span class="o">++</span> <span class="n">show</span><span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="s">&quot;aaa&quot;</span><span class="o">)))</span>
</pre></div>

            <div class="mytitle">Maximum of a list</div>
            <div class="highlight"><pre><span class="c1">--find the maximum of a list</span>
<span class="nf">maximum1&#39;</span><span class="ow">::</span><span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="ow">-&gt;</span><span class="n">a</span>
<span class="nf">maximum1&#39;</span> <span class="kt">[]</span>  <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;empty list&quot;</span> 
<span class="nf">maximum1&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum1&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> 
        <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">x</span> 
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">maxTail</span>
        <span class="kr">where</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">maximum1&#39;</span> <span class="n">xs</span>
<span class="c1">--find the maximum of a list without where</span>
<span class="nf">maximum2&#39;</span><span class="ow">::</span><span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="ow">-&gt;</span><span class="n">a</span>
<span class="nf">maximum2&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;empty list&quot;</span>
<span class="nf">maximum2&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum2&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">max</span> <span class="n">x</span> <span class="p">(</span><span class="n">maximum2&#39;</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">If else in Haskell</div>
            <div class="highlight"><pre><span class="c1">--if else in Haskell</span>
<span class="nf">mySign</span> <span class="n">x</span> <span class="ow">=</span> 
        <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="kr">then</span> <span class="o">-</span><span class="mi">1</span>
        <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="kr">then</span> <span class="mi">1</span>
        <span class="kr">else</span> <span class="mi">0</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">mySign</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
            <div class="mytitle">Equation Guarding in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Guards in Haskell</span>
<span class="nf">myGuards</span> <span class="n">x</span> 
        <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="mi">0</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">myGuards</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
            <div class="cen">
                <img src="../image/guards.svg" width="40%" height="40%" />
            </div>
            <div class="mytitle">let binding in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- let binding in Haskell</span>
<span class="c1">-- ax^2 + bx + c = 0</span>
<span class="c1">-- Find the root of the quadratic equation</span>
<span class="nf">roots</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span>
        <span class="kr">let</span> <span class="n">discriminane</span><span class="ow">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
        <span class="kr">in</span> <span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">roots</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">Print all permutation in Haskell</div>
            <div class="highlight"><pre><span class="nl">myperm:</span><span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="o">=&gt;[</span><span class="n">a</span><span class="o">]-&gt;[[</span><span class="n">a</span><span class="o">]]</span>
<span class="n">myperm</span> <span class="o">[]</span> <span class="o">=</span> <span class="o">[[]]</span>
<span class="n">myperm</span> <span class="n">xs</span> <span class="o">=</span> <span class="o">[</span> <span class="n">x</span><span class="o">:</span><span class="n">ys</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span> <span class="o">,</span> <span class="n">ys</span> <span class="o">&lt;-</span> <span class="n">myperm</span><span class="o">(</span><span class="n">delete</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)]</span>
</pre></div>
            <div class="mytitle">Tree Traversal: Preorder Inorder Postorder/DFS in Haskell</div>
            <pre class="mycode">
            There are preorder inorder and postorder traversals
            preorder: + a b
            inorder:  a + b
            postorder: a b + 

            There are many applications from these traversals
            1. We can rebuild the tree with preorder and inorder
            2. inorder is the sorted order in Binary Search Tree
            3. Quick sort is related to preorder
            4. inorder can be used to check whether a BT is BST
            5. postorder can be implemented with two stacks with recursion
            6. Merge sort is essential the postorder 
            7. Quick sort is essential the preorder 
            8. preorder and postorder can be used in serialization and deseriazation
            </pre>
            <div class="highlight"><pre><span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Empty</span> 
            <span class="o">|</span> <span class="n">Node</span> <span class="nf">a</span> <span class="o">(</span><span class="n">Tree</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">Tree</span> <span class="n">a</span><span class="o">)</span> <span class="n">deriving</span> <span class="n">Show</span>

<span class="n">mytree</span> <span class="o">=</span> <span class="n">Node</span> <span class="sc">&#39;R&#39;</span> 
            <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;S&#39;</span> 
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;T&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;U&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
            <span class="o">)</span> 
            <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;T&#39;</span> 
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;V&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;W&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
            <span class="o">)</span> 

<span class="nl">preorderTraversal:</span><span class="o">:</span><span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;[</span><span class="n">a</span><span class="o">]</span>
<span class="n">preorderTraversal</span> <span class="n">Empty</span> <span class="o">=</span> <span class="o">[]</span> 
<span class="n">preorderTraversal</span> <span class="o">(</span><span class="n">Node</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">:(</span><span class="n">preorderTraversal</span> <span class="n">l</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">preorderTraversal</span> <span class="n">r</span><span class="o">)</span>
 
<span class="nl">inorderTraversal:</span><span class="o">:</span><span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;[</span><span class="n">a</span><span class="o">]</span>
<span class="n">inorderTraversal</span> <span class="n">Empty</span> <span class="o">=</span> <span class="o">[]</span> 
<span class="n">inorderTraversal</span> <span class="o">(</span><span class="n">Node</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">inorderTraversal</span> <span class="n">l</span><span class="o">)</span> <span class="o">++[</span><span class="n">a</span><span class="o">]++(</span><span class="n">inorderTraversal</span> <span class="n">r</span><span class="o">)</span>
 
<span class="nl">postorderTraversal:</span><span class="o">:</span><span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;[</span><span class="n">a</span><span class="o">]</span>
<span class="n">postorderTraversal</span> <span class="n">Empty</span> <span class="o">=</span> <span class="o">[]</span> 
<span class="n">postorderTraversal</span><span class="o">(</span><span class="n">Node</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">postorderTraversal</span> <span class="n">l</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">postorderTraversal</span> <span class="n">r</span><span class="o">)</span> <span class="o">++</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
</pre></div>

            <div class="mytitle">More Typeclass 2 in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Typeclass 2 in Haskell</span>
<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">area</span><span class="ow">::</span><span class="kt">Shape</span><span class="ow">-&gt;</span><span class="kt">Float</span>
<span class="nf">area</span><span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">r</span><span class="o">^</span><span class="mi">2</span> 
<span class="nf">area</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">topx</span> <span class="n">topy</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">bottomx</span> <span class="n">bottomy</span><span class="p">))</span> <span class="ow">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">bottomy</span> <span class="o">-</span> <span class="n">topy</span><span class="p">)</span><span class="o">*</span><span class="n">abs</span><span class="p">(</span><span class="n">bottomx</span> <span class="o">-</span> <span class="n">topx</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">area</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">area</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">2</span> <span class="mi">7</span><span class="p">))</span>
</pre></div>
            <div class="mytitle">More Typeclass 3 in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- Library/WebServer/Documents/zsurface/github/haskell/typeclass3.hs</span>
<span class="c1">-- Typeclass in Haskell</span>
<span class="c1">-- Shape is similar to interface in Java</span>
<span class="c1">-- Circle and Rectangle are similar to class in Java</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="c1">--call constructor</span>
<span class="nf">circleShape</span><span class="ow">::</span><span class="kt">Shape</span>
<span class="nf">circleShape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="nf">rectangleShape</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> 

<span class="c1">--list of typeclasses</span>
<span class="nf">listShape</span><span class="ow">::</span><span class="p">[</span><span class="kt">Shape</span><span class="p">]</span>
<span class="nf">listShape</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Circle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">Rectangle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">circleShape</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">rectangleShape</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">listShape</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">More Typeclass 4 in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Library/WebServer/Documents/zsurface/github/haskell/typeclass4.hs</span>
<span class="c1">--Deconstructing type in Haskell</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>


<span class="nf">showShape</span><span class="ow">::</span><span class="kt">Shape</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">showShape</span><span class="p">(</span><span class="kt">Circle</span> <span class="n">x</span> <span class="n">y</span> <span class="n">radial</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;  &quot;</span><span class="o">++</span><span class="n">show</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">++</span> <span class="s">&quot;  &quot;</span> <span class="o">++</span> <span class="n">show</span><span class="p">(</span><span class="n">radial</span><span class="p">)</span> 
<span class="nf">showShape</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span> <span class="p">)</span> <span class="ow">=</span> <span class="n">show</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;  &quot;</span><span class="o">++</span><span class="n">show</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span><span class="o">++</span> <span class="s">&quot;  &quot;</span> <span class="o">++</span> <span class="n">show</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">++</span><span class="s">&quot; &quot;</span><span class="o">++</span><span class="n">show</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span> 

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">showShape</span><span class="p">(</span><span class="kt">Circle</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">print</span><span class="p">(</span><span class="n">showShape</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
            <div class="mytitle">More Typeclass 5 in Haskell</div>
            <div class="highlight"><pre><span class="n">data</span> <span class="n">Foo</span> <span class="o">=</span> <span class="n">Bar</span> <span class="o">|</span> <span class="n">Baz</span> <span class="n">Int</span>
<span class="nl">myfun:</span><span class="o">:</span><span class="n">Foo</span><span class="o">-&gt;</span><span class="n">Int</span>
<span class="n">myfun</span>   <span class="n">Bar</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">myfun</span>   <span class="o">(</span><span class="n">Baz</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
            <div class="mytitle">More Typeclass 6 in Haskell</div>
            <div class="highlight"><pre><span class="n">data</span> <span class="n">Person</span> <span class="o">=</span> <span class="n">Person</span> <span class="n">String</span> <span class="n">Integer</span> <span class="n">String</span> <span class="n">deriving</span> <span class="n">Show</span>
        
<span class="nl">getAge:</span><span class="o">:</span><span class="n">Person</span><span class="o">-&gt;</span><span class="n">Integer</span>
<span class="nf">getAge</span><span class="o">(</span><span class="n">Person</span> <span class="n">_</span> <span class="n">n</span> <span class="n">_</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span>

<span class="nl">getName:</span><span class="o">:</span><span class="n">Person</span><span class="o">-&gt;</span><span class="n">String</span>
<span class="nf">getName</span><span class="o">(</span><span class="n">Person</span> <span class="n">name</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">=</span> <span class="n">name</span>

<span class="nl">getInfo:</span><span class="o">:</span><span class="n">Person</span><span class="o">-&gt;</span><span class="n">String</span>
<span class="n">getInfo</span> <span class="n">p</span><span class="err">@</span><span class="o">(</span><span class="n">Person</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">=</span> <span class="s">&quot;(&quot;</span> <span class="o">++</span> <span class="n">show</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">++</span> <span class="s">&quot;)&quot;</span>
</pre></div>
            <div class="mytitle">More Typeclass 7 in Haskell</div>
            <div class="highlight"><pre><span class="kr">data</span> <span class="kt">Point</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Pt</span> <span class="n">a</span> <span class="n">a</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">dist</span><span class="ow">::</span><span class="kt">Point</span> <span class="kt">Int</span><span class="ow">-&gt;</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">dist</span> <span class="p">(</span><span class="kt">Pt</span> <span class="n">x0</span> <span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pt</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y0</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y0</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">print</span> <span class="p">(</span><span class="kt">Pt</span> <span class="mi">1</span> <span class="mi">3</span> <span class="ow">::</span> <span class="kt">Point</span> <span class="kt">Int</span><span class="p">)</span> 
        <span class="n">print</span> <span class="o">$</span> <span class="n">dist</span><span class="p">(</span><span class="kt">Pt</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pt</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">data type in Haskell</div>
            <pre>
            data Point a = Pt a a
            norm::(Point Int)->(Point Int)->Int
            norm(Pt a1 b1) (Pt a2 b2)  = a1*a2 + b1*b2 

            dist::(Point Int)->(Point Int)->Int
            dist (Pt a1 b1) (Pt a2 b2) = norm (Pt a1 b1) (Pt a2 b2) 
            
            // in Java 
            class Point&lt;T&gt;{
                Point(T t1, T t2){}
            }
            </pre>
            <div class="mytitle">Following is java interface and two classes</div>
            <div class="highlight"><pre><span class="kd">interface</span> <span class="nc">Shape</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getArea</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">implements</span> <span class="n">Shape</span>
<span class="o">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">radial</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Circle</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">,</span> <span class="kt">double</span> <span class="n">radial</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">radial</span> <span class="o">=</span> <span class="n">radial</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getArea</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="mf">3.14</span><span class="o">*</span><span class="n">radial</span><span class="o">*</span><span class="n">radial</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">implements</span> <span class="n">Shape</span>
<span class="o">{</span>
    <span class="kt">double</span> <span class="n">topx</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">topy</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">bottomx</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">bottomy</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">(</span><span class="kt">double</span> <span class="n">topx</span><span class="o">,</span> <span class="kt">double</span> <span class="n">topy</span><span class="o">,</span> <span class="kt">double</span> <span class="n">bottomx</span><span class="o">,</span> <span class="kt">double</span> <span class="n">bottomy</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">topx</span> <span class="o">=</span> <span class="n">topx</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">topy</span> <span class="o">=</span> <span class="n">topy</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bottomx</span><span class="o">=</span> <span class="n">bottomx</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bottomy</span><span class="o">=</span> <span class="n">bottomy</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getArea</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">bottomx</span> <span class="o">-</span> <span class="n">topx</span><span class="o">)*</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">bottomy</span> <span class="o">-</span> <span class="n">topy</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

            <div class="mytitle">Crazy function in Haskell</div>
            <div class="highlight"><pre><span class="nf">f</span><span class="ow">::</span><span class="nb">()</span><span class="ow">-&gt;</span><span class="nb">()</span>
<span class="nf">f</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span> 

<span class="nf">f1</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f1</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span> <span class="o">==</span> <span class="nb">()</span> 

<span class="nf">f2</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f2</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="kt">True</span> 

<span class="nf">f3</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f3</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span> 

<span class="nf">f4</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f4</span> <span class="n">undefined</span> <span class="ow">=</span> <span class="kt">False</span> 

<span class="nf">f5</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f5</span> <span class="n">undefined</span> <span class="ow">=</span> <span class="n">undefined</span> 

<span class="nf">f6</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f6</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">undefined</span> 

<span class="nf">f7</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f7</span> <span class="ow">=</span> <span class="n">undefined</span> 

<span class="nf">f8</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f8</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">undefined</span>

<span class="nf">f9</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f9</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> 

<span class="nf">f10</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f10</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f9</span> <span class="n">x</span> 

<span class="nf">f11</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f11</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">f9</span> <span class="mi">1</span><span class="p">)</span> 

<span class="nf">f12</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f12</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">Composite function in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- function composition foldable</span>
<span class="nf">f1</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f1</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">10</span> 

<span class="nf">f2</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f2</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">10</span> 
<span class="nf">compose</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">f2</span><span class="p">)</span> <span class="mi">10</span>
</pre></div>

            <div class="mytitle">Foldable in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- identity = [] </span>
<span class="nf">concat2</span><span class="ow">::</span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="ow">-&gt;</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">concat2</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">val</span> <span class="n">acc</span><span class="ow">-&gt;</span><span class="n">val</span> <span class="o">++</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">vals</span>
<span class="c1">-- concat2 [[1, 2], [3, 4]] =  [1, 2] ++ ([3, 4] ++ []) = [1, 2, 3, 4]</span>

<span class="nf">fo</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">((</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> 
<span class="c1">-- output [1, 2, 3]</span>

<span class="c1">-- alternative definition of map </span>
<span class="nf">map&#39;</span><span class="ow">::</span><span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span><span class="ow">-&gt;</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="ow">-&gt;</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">((</span><span class="kt">:</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="kt">[]</span> 
<span class="c1">-- map&#39; (1+) 1 [1, 2, 3] = [2, 3, 4]</span>


<span class="c1">-- identity = 0</span>
<span class="nf">sum1</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">sum1</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">0</span> <span class="n">vals</span> 

<span class="c1">-- identity = 1 </span>
<span class="nf">product1</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">product1</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="mi">1</span> <span class="n">vals</span> 

<span class="c1">-- identity = [] </span>
<span class="nf">concat1</span><span class="ow">::</span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">concat1</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span><span class="n">concat</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="kt">[]</span> <span class="n">vals</span>
</pre></div>

            <div class="mytitle">instance and class in Haskell</div>
            <div class="highlight"><pre><span class="c1">--class  Eq a  where</span>
   <span class="c1">--(==), (/=) :: a -&gt; a -&gt; Bool</span>
   <span class="c1">--x /= y     =  not (x == y)</span>
   <span class="c1">--x == y     =  not (x /= y)</span>

<span class="c1">-- instance class</span>
<span class="kr">data</span> <span class="kt">Myfoo</span> <span class="ow">=</span> <span class="kt">Myfoo</span><span class="p">{</span><span class="n">int</span><span class="ow">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">str</span><span class="ow">::</span><span class="kt">String</span><span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Myfoo</span> <span class="kr">where</span> 
    <span class="p">(</span><span class="kt">Myfoo</span> <span class="n">int1</span> <span class="n">str1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">Myfoo</span> <span class="n">int2</span> <span class="n">str2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">int1</span> <span class="o">==</span> <span class="n">int2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span>
</pre></div>

            <div class="mytitle">Functor in Haskell</div>
            <div class="highlight"><pre><span class="kr">data</span> <span class="kt">MyMaybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MyJust</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">MyNothing</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
 
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">MyMaybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">MyNothing</span> <span class="ow">=</span> <span class="kt">MyNothing</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">MyJust</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">MyJust</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>


            <div class="mytitle">Algebraic Data Type in Haskell</div>
            <pre class="mycode">
            <span class="bo">Algebraic Data type - Algebraic refers to the property that an algebraic data type is created</span> 
                                  by algebraic operations such as <span class="bo">sum</span> and <span class="bo">product</span>. There 
            <span class="bo">Sum</span> is alternation[logic OR operator][A | B, meaning A or B but not both, e.g. enum in Java/C++]
            <span class="bo">Product</span> is combination[logic AND operator][A B, meaning A and B together, e.g. tuple, record]

            data Maybe a = Just a | Nothing 
            There are two constructors:
            Just is one constructor with one parameter a 
            Nothing is other constrcutor with no parameter
            
            -- Try to simulate Maybe in Java
            interface Maybe<T>{ }
            class Just implements Maybe<String>{
                public Just(String s){ }
            }
            class Nothing implements Maybe{
                public Nothing(){}
            }
            </pre>
            <div class="highlight"><pre><span class="c1">-- City is similar to Enum in Java/C++</span>
<span class="c1">-- public enum City </span>
<span class="c1">-- {</span>
<span class="c1">--  PaloAlto, </span>
<span class="c1">--  MountainView </span>
<span class="c1">--  Sunnyvale</span>
<span class="c1">-- }</span>
<span class="c1">-- City city = MountainView</span>
<span class="c1">--</span>
<span class="kr">data</span> <span class="kt">City</span> <span class="ow">=</span> <span class="kt">PaloAlto</span>
            <span class="o">|</span> <span class="kt">MountainView</span>
            <span class="o">|</span> <span class="kt">Sunnyvale</span>
    <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
            

<span class="nf">city</span><span class="ow">::</span><span class="kt">City</span>
<span class="nf">city</span> <span class="ow">=</span> <span class="kt">MountainView</span>

<span class="nf">listofCity</span><span class="ow">::</span><span class="p">[</span><span class="kt">City</span><span class="p">]</span>
<span class="nf">listofCity</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">PaloAlto</span><span class="p">,</span> <span class="kt">Sunnyvale</span><span class="p">,</span> <span class="kt">MountainView</span><span class="p">]</span>

<span class="nf">isGoodCity</span><span class="ow">::</span><span class="kt">City</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isGoodCity</span> <span class="kt">PaloAlto</span>     <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isGoodCity</span> <span class="kt">MountainView</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isGoodCity</span> <span class="kt">Sunnyvale</span>    <span class="ow">=</span> <span class="kt">False</span>

<span class="kr">data</span> <span class="kt">MyType</span> <span class="ow">=</span> <span class="kt">Failture</span>
            <span class="o">|</span> <span class="kt">OK</span> <span class="p">(</span><span class="kt">Double</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="nf">fa</span> <span class="ow">=</span> <span class="kt">Failture</span>
<span class="nf">ok</span> <span class="ow">=</span> <span class="kt">OK</span> <span class="mf">3.31</span>

<span class="nf">safeDiv</span><span class="ow">::</span><span class="kt">Double</span><span class="ow">-&gt;</span><span class="kt">Double</span><span class="ow">-&gt;</span><span class="kt">MyType</span>
<span class="nf">safeDiv</span> <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Failture</span>
<span class="nf">safeDiv</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">OK</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>

<span class="nf">f</span><span class="ow">::</span><span class="kt">String</span><span class="ow">-&gt;</span><span class="kt">MyType</span>
<span class="nf">f</span>   <span class="s">&quot;&quot;</span>    <span class="ow">=</span> <span class="kt">Failture</span>
<span class="nf">f</span>   <span class="s">&quot;cat&quot;</span> <span class="ow">=</span> <span class="kt">OK</span> <span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="nf">f</span>   <span class="s">&quot;dog&quot;</span> <span class="ow">=</span> <span class="kt">OK</span> <span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="nf">f</span>   <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">OK</span> <span class="mf">3.3</span>


<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">isGoodCity</span> <span class="kt">PaloAlto</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">isGoodCity</span> <span class="kt">Sunnyvale</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="s">&quot;cat&quot;</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="s">&quot;dog&quot;</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">safeDiv</span> <span class="mi">3</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">safeDiv</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">foldr and foldl in Haskell</div>
            <div class="cen">
            <img src="../image/fold.svg" width="50%" height="50%" /><br> 
            </div>
            <div class="highlight"><pre><span class="c1">-- folding examples</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">foldr</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">-- output 2</span>
        <span class="n">print</span><span class="p">(</span><span class="n">foldl</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">-- output -8 </span>

        <span class="kr">let</span> <span class="n">fr</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span><span class="n">concat</span><span class="p">[</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&quot;)&quot;</span><span class="p">])</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">map</span> <span class="n">show</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
        <span class="c1">--output &quot;(2-(3-(4-1)))&quot;</span>

        <span class="kr">let</span> <span class="n">fl</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span><span class="n">concat</span><span class="p">[</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&quot;)&quot;</span><span class="p">])</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">map</span> <span class="n">show</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
        <span class="n">print</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
        <span class="c1">--output &quot;(((1-2)-3)-4)&quot;</span>
</pre></div>
 <br>
            <div class="highlight"><pre><span class="c1">// foldr (-) 1 [2, 3, 4]  output = 2 </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">foldr</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">foldr</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// foldl (-) 1 [2, 3, 4] output = -8 </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">foldl</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="k">return</span> <span class="n">foldl</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>
 <br>
            <div class="cen">
            <img src="../image/fold2.svg" width="50%" height="50%" /><br> 
            </div>

            <div class="mytitle">
            Map and Foldr in Haskell<br>
            </div>
            <div class="mytext">
            Map can be defined by foldr, let's look at the definition of map in Haskell
            </div>
            <pre class="mycode">
            map::(a->b)->[a]->[b]
            map f (x:xs) = f x : map f xs

            foldr f a [n1, n2, n3] = n1 `f` (n2 `f` (a `f` n3))

            -- e.g.
            foldr (+) 1 [2, 3, 4] = 2 + (3 + (4 + 1))
            
            foldr ((:)) [] [2, 3, 4] = 2:3:4:[] = [2, 3, 4]

            map'::(a->b)->[a]->[b]
            map' f = foldr((:)) []

            -- remove brackets
            foldr (++) [] [["a", "b"], ["c"]]
            -- output ["a", "b", "c"]

            </pre>

            <div class="mytitle">let expressions and where causes local variable binding in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- where cause and let binding in Haskell</span>
<span class="c1">--</span>
<span class="c1">-- let binding in Haskell</span>
<span class="c1">-- ax^2 + bx + c = 0</span>
<span class="c1">-- Find the root of the quadratic equation</span>

<span class="nf">roots</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span>
        <span class="kr">let</span> <span class="n">discriminant</span><span class="ow">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
        <span class="kr">in</span> <span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>

<span class="nf">longest</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">longest</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">length</span> <span class="p">(</span><span class="n">longest</span> <span class="n">xs</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="p">(</span><span class="n">longest</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">newlongest</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">newlongest</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">length</span> <span class="n">max</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">max</span> 
    <span class="kr">where</span> <span class="n">max</span> <span class="ow">=</span> <span class="n">newlongest</span> <span class="n">xs</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">roots</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">longest</span> <span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">newlongest</span> <span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
</pre></div>

            <div class="mytitle">simple case in Haskell</div>
            <div class="mytext">
            Case in Haskell is like switch statement in Java, except it is more beautiful! 
            </div>
            <div class="highlight"><pre><span class="nf">suffixed</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="kr">where</span> 
        <span class="n">suffix</span>
            <span class="o">|</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">100</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">=</span> <span class="s">&quot;th&quot;</span>
            <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">10</span> <span class="kr">of</span> 
                <span class="mi">1</span> <span class="ow">-&gt;</span> <span class="s">&quot;st&quot;</span>
                <span class="mi">2</span> <span class="ow">-&gt;</span> <span class="s">&quot;nd&quot;</span>
                <span class="mi">3</span> <span class="ow">-&gt;</span> <span class="s">&quot;rd&quot;</span>
                <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;th&quot;</span>

<span class="nf">result</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">suffixed</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">40</span><span class="p">]</span>
</pre></div>
            <div class="mytitle">practical case in Haskell</div>
            <div class="highlight"><pre><span class="nf">fun</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="kr">of</span>
            <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="s">&quot;even&quot;</span>
            <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;odd&quot;</span>

<span class="nf">fun&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">answer</span> 
            <span class="kr">where</span> <span class="n">answer</span> 
                    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="ow">=</span> <span class="s">&quot;less then 10&quot;</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">10</span> <span class="ow">=</span> <span class="s">&quot;equal 10&quot;</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="kr">of</span> 
                                        <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="s">&quot;greater than 10 even&quot;</span> 
                                        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;greater than 10 and odd&quot;</span>
</pre></div>

            <div class="mytitle">First OpenGL Hello World in Haskell</div>
            <div class="highlight"><pre><span class="kn">import</span> <span class="nn">Graphics.UI.GLUT</span>

<span class="nl">myPoints:</span><span class="o">:[(</span><span class="n">GLfloat</span><span class="o">,</span> <span class="n">GLfloat</span><span class="o">,</span> <span class="n">GLfloat</span><span class="o">)]</span>
<span class="n">myPoints</span> <span class="o">=</span> <span class="o">[(</span><span class="n">sin</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="mi">12</span><span class="o">),</span> <span class="n">cos</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="mi">12</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">|</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="o">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">12</span><span class="o">]]</span>

<span class="nl">main:</span><span class="o">:</span><span class="n">IO</span><span class="o">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">_progName</span><span class="o">,</span> <span class="n">_args</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">getArgsAndInitialize</span>
    <span class="n">_window</span> <span class="o">&lt;-</span> <span class="n">createWindow</span> <span class="s">&quot;Hello World&quot;</span>
    <span class="n">displayCallback</span> <span class="n">$</span><span class="o">=</span> <span class="n">display</span>
    <span class="n">mainLoop</span>

<span class="nl">display:</span><span class="o">:</span><span class="n">DisplayCallback</span>
<span class="n">display</span> <span class="o">=</span> <span class="k">do</span>
    <span class="n">clear</span> <span class="o">[</span> <span class="n">ColorBuffer</span><span class="o">]</span>
    <span class="n">renderPrimitive</span> <span class="n">Triangles$</span> <span class="nf">mapM_</span> <span class="o">(</span><span class="err">\</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">vertex</span> <span class="n">$</span> <span class="n">Vertex3</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="n">myPoints</span>
    <span class="n">flush</span>
</pre></div>

            <div class="cen">
                <img src="../image/firstOpenGL.png" width="30%" height="30%" />
            </div>
            <div class="mytitle">OpenGL Vertex and Color in Haskell</div>
            <div class="highlight"><pre><span class="kn">import</span> <span class="nn">Graphics.UI.GLUT</span>

<span class="nl">main:</span><span class="o">:</span><span class="n">IO</span><span class="o">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">_progName</span><span class="o">,</span> <span class="n">_args</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">getArgsAndInitialize</span>
    <span class="n">_window</span> <span class="o">&lt;-</span> <span class="n">createWindow</span> <span class="s">&quot;OpenGL Vertex and Color in Haskell&quot;</span>
    <span class="n">displayCallback</span> <span class="n">$</span><span class="o">=</span> <span class="n">display</span>
    <span class="n">mainLoop</span>

<span class="nl">display:</span><span class="o">:</span><span class="n">DisplayCallback</span>
<span class="n">display</span> <span class="o">=</span> <span class="k">do</span>
    <span class="n">let</span> <span class="n">color3f</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="o">=</span> <span class="n">color</span> <span class="n">$</span> <span class="n">Color3</span> <span class="n">r</span> <span class="nf">g</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">GLfloat</span><span class="o">)</span>
        <span class="n">vertex3f</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span> <span class="n">$</span> <span class="n">Vertex3</span> <span class="n">x</span> <span class="nf">y</span> <span class="o">(</span><span class="n">z</span><span class="o">::</span><span class="n">GLfloat</span><span class="o">)</span>
    <span class="n">clear</span> <span class="o">[</span><span class="n">ColorBuffer</span><span class="o">]</span>
    <span class="n">renderPrimitive</span> <span class="n">Quads</span> <span class="n">$</span>  <span class="k">do</span>
        <span class="n">color3f</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="mf">0.2</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="mi">0</span> <span class="mi">0</span> 

        <span class="n">color3f</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mf">0.5</span> 
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="mi">0</span> <span class="mi">0</span>

        <span class="n">color3f</span> <span class="mi">0</span> <span class="mf">0.5</span>  <span class="mi">1</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> <span class="mi">0</span> 

        <span class="n">color3f</span> <span class="mf">0.3</span> <span class="mf">0.3</span> <span class="mf">0.3</span> 
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mf">0.2</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> <span class="mi">0</span> 
    <span class="n">flush</span>
</pre></div>
            <div class="cen">
                <img src="../image/openGLColor.png" width="30%" height="30%" />
            </div>
            <div class="mytitle">Map Examples in Haskell</div>
            <div class="mytext">
            Haskell Map Example<br>
            map::(a->b) -> [a] -> [b]<br>
            map f xs is the list obtained by apply f to each element of xs<br>
            map f [1..3] = [f(1) f(2) f(3)]<br>
            map f [x1, x2, ...] = [f(x1), f(x2), ...]<br>
            </div>
            <div class="highlight"><pre><span class="nf">f</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="mi">2</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 + 1) (2 + 2) (2 + 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 - 1) (2 - 2) (2 - 2)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">((</span><span class="o">-</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>   <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 - 1) (2 - 2) (2 - 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">mod</span> <span class="mi">2</span><span class="p">)</span>   <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 mod 1) (2 mod 2) (2 mod 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (1 mod 2) (2 mod 2) (3 mod 2)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 / 1) (2 / 2) (2 / 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span> <span class="mi">2</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 * 1) (2 * 2) (2 * 3)</span>

        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">f</span> <span class="mi">10</span><span class="p">)</span>    <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (10 - 1) (10 - 2) (10 - 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(`</span><span class="n">f</span><span class="p">`</span> <span class="mi">10</span><span class="p">)</span>  <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (1 - 10) (2 - 10) (3 - 10)</span>
</pre></div>
            <div class="mytitle">Unwrap Monad, Find Index and SubString in Haskell</div>
            <div class="mytext">
            1. Unwrap the Maybe Monad<br>
            2. Find the Index of Char in a String<br>
            3. SubString of two Indexes of string<br><br>
            Similar Haskell functions<br>
            </div>
            <div class="mytext">
            "abc" !! 1               -> 'b'<br>
            elemIndex 'a' "ba"       -> Just 1<br>
            isInfixOf "ab" "efab"    -> True<br>
            findIndex (== 'a') "bac" -> 1<br>
            findIndex (> 'a')  "bac" -> 2<br>
            </div>
            <div class="highlight"><pre><span class="c1">--unwrap Maybe</span>
<span class="nf">open</span><span class="ow">::</span><span class="kt">Maybe</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span>
<span class="nf">open</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;error&quot;</span>
<span class="nf">open</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>

<span class="c1">-- find the index of Char</span>
<span class="nf">findChar</span><span class="ow">::</span><span class="kt">Char</span><span class="ow">-&gt;</span><span class="kt">String</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">findChar</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="nf">findChar</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="o">/=</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">((</span><span class="n">findChar</span> <span class="n">a</span> <span class="n">xs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">else</span> <span class="mi">0</span>

<span class="c1">-- substring from l to r</span>
<span class="nf">range</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">String</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">range</span> <span class="n">l</span> <span class="n">r</span> <span class="n">str</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="n">str</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="n">str</span> <span class="kr">then</span> <span class="kt">[]</span> <span class="kr">else</span> <span class="p">(</span><span class="kr">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="kr">then</span> <span class="n">str</span> <span class="o">!!</span> <span class="n">l</span> <span class="kt">:[]</span> <span class="o">++</span> <span class="n">range</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">r</span> <span class="n">str</span> <span class="kr">else</span> <span class="kt">[]</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">Regular Expression in Haskell</div>
            <div class="highlight"><pre><span class="nf">mymatch</span> <span class="n">regex</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> 
        <span class="kr">case</span> <span class="n">matchRegexAll</span> <span class="n">regex</span> <span class="n">s</span> <span class="kr">of</span> 
            <span class="kt">Nothing</span><span class="ow">-&gt;</span><span class="n">s</span>
            <span class="kt">Just</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">matched</span><span class="p">,</span> <span class="n">after</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span><span class="ow">-&gt;</span><span class="n">before</span> <span class="o">++</span> <span class="n">f</span> <span class="n">l</span> <span class="o">++</span> <span class="n">after</span>

<span class="nf">t1</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">=~</span> <span class="s">&quot;is&quot;</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;this is it&quot;</span><span class="p">]</span> 
<span class="c1">-- [&quot;this is it&quot;]</span>
<span class="nf">ignoreCase</span> <span class="ow">=</span> <span class="n">makeRegexOpts</span><span class="p">(</span><span class="n">defaultCompOpt</span> <span class="o">.|.</span> <span class="n">compIgnoreCase</span><span class="p">)</span> <span class="n">defaultExecOpt</span>
<span class="nf">t3</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="n">matchTest</span> <span class="o">$</span> <span class="n">ignoreCase</span> <span class="s">&quot;apple&quot;</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;My Apple&quot;</span><span class="p">]</span> 
<span class="c1">-- [&quot;My Apple&quot;]</span>
<span class="nf">t4</span> <span class="ow">=</span> <span class="n">subRegex</span><span class="p">(</span><span class="n">mkRegex</span> <span class="s">&quot;p+&quot;</span><span class="p">)</span> <span class="s">&quot;apple sucks&quot;</span> <span class="s">&quot;PP&quot;</span> 
<span class="c1">-- aPPle sucks</span>
<span class="nf">t5</span> <span class="ow">=</span> <span class="n">mymatch</span><span class="p">(</span><span class="n">mkRegex</span> <span class="s">&quot;man([0-9])&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="ow">-&gt;</span><span class="s">&quot;woman&quot;</span> <span class="o">++</span> <span class="n">n</span><span class="p">)</span> <span class="s">&quot;/cat/man3/dog.txt&quot;</span>
<span class="c1">-- &quot;/cat/woman3/dog.txt&quot;</span>
</pre></div>
</div>

</body>
</html>

