<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-GB">
<head>
	<title>What is Moand?</title>
	<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=utf-8" />
	<meta name="description" content="Haskell Snippet" />
	<meta name="keywords" content="Haskell example, Haskell Hello World, Haskell Binding, Haskell Typeclass, Foldable" />
	<meta name="robots" content="index, follow" />
	<link rel="shortcut icon" href="/favicon.ico" type="../image/x-icon" />
	<link rel="stylesheet" type="text/css" href="../screen.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="../highlight.css">
    <link rel="stylesheet" type="text/css" href="../style.css">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    <!-- Google prettify.  Sun Sep 11 00:57:25 PDT 2016 -->
    <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>

    <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js"],
            jax: ["input/TeX","output/HTML-CSS"],
            tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
          });
        </script>
    <script type="text/javascript" src="../MathJax-2.6-latest/MathJax.js"></script>
</head>
<body>
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66282017-2', 'auto');
  ga('send', 'pageview');
</script>

        
            <div class="myclass">
            
            <div class="mytitle">
            What is Monad in Haskell  
            </div>
            <p class="art">
            Monad is very simple definition. It is nothing more complicated than Ring $\mathbf{I}$, Field $\mathbf{R}$
            Group $\mathbf{G}$ or Monoid $\mathbf{M}$.  
            If you google it, you will find hundreds of thousands of posts about Monad. Many people just threw out endofunctor, 
            nature transformation, morphism, category to category etc. You will get more confusing if you read more posts online. <br>

            Instead of explaining what is Monad directly, we can just use our known knowledge and twist a bit. <br><br>
            </p>
            <h3>Let us review the definition of Group. </h3>
            Group is just a binary operation over a set of elements, e.g. <br>
            binary operation: + <br>
            set of elements: $S = \{0, 1, 2, \dots \}$ <br>
            associativity: $(2 + 3) + 4 = 2 + (3 + 4) $ <br>
            identity: $0 + 2 = 2 + 0 $ <br>
            inverse: $2 + (-2) = 0 $<br><br>
            <h3>What is Monoid?</h3>
            Monoid is same as Group without inverse, e.g. <br>
            $(+, \{0, 1, 2, \dots \})$ <br><br>
            
            String concatenation: <br>
            $"" + "dog" = "dog" + ""$ <br>
            $"dog" + "cat" + "cow" = "dog" + ("cat" + "cow") = "dogcatcow"$<br><br>

            <h3>What is Monad?</h3>
            Monad is just like a Monoid. <br>
            The binary operation is functor composition(it is just function composition in Haskell) <br>
            The set of elements is the element in Category.<br>

            </div>
            <div class="myclass">
            <div class="mytitle">
            Find all prime number in Haskell
            </div>
            <pre class="prettyprint">
            prime = sieve[2..]
                    where sieve(p:xs) = p:sieve[ x | x <- xs, mod x p /= 0] 

            -- sieve[2, 3, 4, 5, 6]
            --    2:sieve([3, 5]) 
            --        2:3:sieve([5])
            --            2:3:5:sieve([])
            </pre> 
            </div>
            </div>

            <div class="myclass">
            <div class="mytitle">
            Split String in Haskell 
            </div>
            <pre class="prettyprint">
            break(\x -> isDigit x == False) "123dog"
            -- ("123", "dog")

            break(\x -> isSpace x) "123  dog"
            -- ("123", " dog")

            filter(\x -> isDigit x) "123dog" 
            -- "123" 

            let reg = mkRegex "[[:space:]]+"
            splitRegex r "Agentina Switzerland Sweden"
            -- ["Agentia", "Switzerland", "Sweden"]

            -- split string at a particular position 
            splitAt 3 "Agentina" -- ["Age", "ntina"]
            </pre>

            <div class="mytitle">
            Haskell class and instance
            </div>
            <pre>
            Haskell class and instance are very similar to template/generic, interface in Java/C++
            1. Create interface with generic
            2. Implement it with concrete type
            </pre>
            <pre>
            class Test a where
                tme::a -> a -> Bool 

            data Dump = Dump{int::Int, str::String} 

            instance Test Dump where
                tme d1 d2 = int d1 == int d2 
            
            -- test it
            let d1 = Dump{int=3, str="dog"}
            let d2 = Dump{int=3, str="dog"}
            print $ tme d1 d2   -- True
            </pre>

            <div class="mytitle">Functor in Haskell</div>
            <div class="cen">
                <img src="../image/functor1.png" width="40%" height="40%" />
            </div>
            <div class="mytext">
            Functor is like a box contains something inside such as Maybe or [1, 2]<br> 
            with a function call fmap which take a function and map the stuff inside the box,<br> 
            then return a new box with new stuff<br><br>
            
            Functor can be formally defined by a pair of functions $f_1 \mbox{ and } f_0$<br> 
            so that $f_0:Ob(Hask) \rightarrow Ob(Hask)$ and $f_1:Hom(Hask) \rightarrow Hom(Hask)$<br>
            where $Hom(Hask)$ refers to the union of all sets $a \rightarrow b$ where $a, b \in Ob(Hask)$<br>
            so that the following holds<br><br>

             0. $id::a \rightarrow a $<br>
             1. If $g::a \rightarrow b $ then $f_1(g)::f_0(a) \rightarrow f_0(b)$<br> 
             2. For all $a \in \mbox{Ob(Hask)}, \quad f_1(id_a) = id_{f_0(a)} $<br>
             3. If $g,h \in \mbox{Hom(Hask)} \mbox{ then } \quad f_1(g \circ h) = f_1(g) \circ f_1(h)$<br><br>
             Given $f_0(a) = \mbox{List } a \quad f_1(g) = \mbox{ map } g   $<br><br>  
             Prove $f_0$ and $f_1$ is a Functor<br>
             
            \begin{equation}
            \begin{aligned}
              &f_0(a) \Rightarrow \mbox{ List } a \quad f_0(b) \Rightarrow \mbox{ List } b \quad \mbox{ [from 1] }  \\
              &\Rightarrow \quad f_1(g):: \mbox{ List }a \rightarrow \mbox{ List }b \\
              &\because \quad id_{f_0(a)}:: f_0(a) \rightarrow f_0(a)  \\
              &\therefore \quad id_{f_0(a)}:: \mbox{ List }a \rightarrow \mbox{ List }a   \\
              &\therefore \quad f_1(id_a):: \mbox{ List }a  \rightarrow \mbox{ List }a  \quad [\mbox{ from 1 } , \mbox{ sub } g::a \rightarrow b \mbox{ with } id::a \rightarrow a] \\
              &\Rightarrow  f_1(id_a) = id_{f_0(a)} \\~\\ 
              &f_1( g \circ h) \Rightarrow \mbox{ map } g \circ h \Rightarrow \mbox{ map } g \circ \mbox{ map } h \quad \mbox{ [from def. of map]} \\
              &f_1(g) \circ f_1(h) \Rightarrow \mbox{ map } g \circ \mbox{ map } h\\
              &\Rightarrow f_1( g \circ h) = f_1(g) \circ f_1(h)\\
              &\Rightarrow f_0 \mbox{ and } f_1 \mbox{ is a Functor} \\
            \end{aligned}
            \end{equation} 
            </div>

            <div class="mytitle">
            Picture of Functor 
            </div>
            <div class="cen">
            <img src="../image/monadpic.png" width="40%" height="40%" /><br>
            </div> 




            <div class="mytitle">
            Not everything is Functor
            </div>
            <div class="mytext">
            MyMaybe is not a Functor since it does't satify the SECOND rule given from above<br>
            </div>
            <pre class="mycode">
            <pre class="cc">
            data MyMaybe a = MNothing | MyJust Int a deriving(Show)

            instance Functor MyMaybe where
                fmap f MNothing = MNothing
                fmap f (MyJust counter a) = MyJust (counter + 1)  (f a) 

            main = do 
                    print "Hello World"
                    print $ fmap (+1) MNothing
                    print $ fmap (+1) (MyJust 0 2) 
                    print $ fmap (+1) $ fmap (+1) (MyJust 0 2) 
                    print $ fmap id (MyJust 0 2)
                    print $ id (MyJust 0 2)
                    -- fmap id (MyJust 0 2) != id (MyJust 0 2)
                    -- MyMaybe is not a Functor
            </pre>
            </pre>

            <div class="mytitle">Haskell IO action</div>
            <div class="mytext">
            Haskell separates pure functions from computations where side effects must be considered 
            by encoding those side effects as values of a particular type. 
            Specifically, a values of type [IO a] is an action, which if executed would product a value type of a
            </div>
            <!-- <pre class="prettyprint lang-haskell"> -->
            <pre class="mycode">
            <span class="bo">[IO a] is an action</span>
            getLine::IO String
            putStrLn::String-> IO()
            randomRIO::(Random a) => (a, a) -> IO a

            <span class="bo">Some IO goodness</span>   
            -- define a function to print out "Hello World"
            fun::IO()
            fun = putStrLn "Hello World"

            -- IO action is like a type.  
            putStrLn::String->IO ()  -- input is String, output is IO()
            
            fun::String->String      -- input is String, output is String

            <span class="bo">Chain the IO actions</span>
            (>>)::IO a -> IO b -> IO b
            where if x and y are IO actions, then (x >> y) is the action performs x, dropping the result
            and then performs y and return its result. Great, we can now write programs which do multiple things

            main = putStrLn "Hello" >> putStrLn "World"

            <span class="bo">How to use the result of first action</span>
            (>>=)::IO a -> (a -> IO b) -> IO b
            Now, (x >>= y) is the action first perform x, and capture its result, passing the result to f, 
            which then computes a second actions to be performed. The action is then carried out, 
            and its result is the result of overall computation.

            It does seem to make sense, but what is the concrete example
            
            <span class="bo">The definition of readFile and print are as following</span>
            readFile::FilePath->IO String
            print::String->IO ()

            <span class="bo">Chain readFile to print with</span> >>=  
            readFile >>=\contents -> print contents

            <span class="bo">What you can come up a picture about IO monad</span>
            <div class="cen">
            <img src="../image/monadpic3.png" width="40%" height="40%" /><br>
            </div> 

            <span class="bo">Definition of const</span> 
            const::a -> b -> a  [keep the first argument and throw away the second argument]
            It does't look that good from outside but some inside and be surprised [surprisedly]

            const 3 4 -- output 3

            >> <span class="bo">can be defined in term of</span> >>=
            x >> y == x >>= const y 
            or
            x >> y == x >>= \_ -> y

            How to turn a value to an IO action which do nothing
            return:: a -> IO a

            <span class="bo">Use IO in function</span>
            myReadFile::FilePath->IO String
            myReadFile f = readFile f >>=\contents -> return(contents)

            <span class="bo">How to use myReadFile ?</span>
            contents <- myReadFile "file.txt" 
            print contents

            <span class="bo">IO are first class</span>
            create control structure with IO
            
            repeat'::Int->IO () -> IO ()
            repeat' n a = a >> repeat'(n-1) a

            repeat' 3 putStr('x')   -- output xxx

            <span class="bo">create for loop</span>
            for::[a]->(a -> IO()) -> IO ()
            for [] f = return ()
            for (x:xs) f = f x >> for xs f

            for [1..10] (\x -> putStrLn x)
            
            for [1..10] (\x -> do
                        putStrLn x
                        putStrLn x
                        )

            <pre class="cc">
            -- get two Chars
            getTwoChars::IO (Char, Char) 
            getTwoChars   = getChar >>= \c1-> 
                            getChar >>= \c2 -> 
                            return (c1, c2) 
            -- do statement
            getTwoCharsDo::IO(Char, Char)
            getTwoCharsDo = do {
                                c1 <- getChar;
                                c2 <- getChar;
                                return (c1, c2) }

            -- get line with nested do
            getMyLine::IO [Char]
            getMyLine = do {
                            x <- getChar;
                            if x == '\n' then
                                return []
                            else do{
                                xs <- getMyLine;
                                return (x:xs)
                            }
                        }
            </pre>

            <span class="bo">Three weird primitives for composing and chaining together IO actions</span> 
            (>>)::IO a -> IO b -> IO b    [kill the first action's result and return the second action's result]
            (>>=)::IO a -> (a -> IO b) -> IO b   
            return::a -> IO a             [wrap a with IO and return it]

            class Monad a where
            (>>=)::IO a ->(a -> IO b) -> IO b
            return::IO a -> (a -> IO b) -> IO b

            class Monad m where
            (>>=)::m a ->(a -> m b) -> m b
            return::a -> m a 

            fun::[(Integer, Integer)]
            fun n = do
                x <- [-10..10]
                if x > 0 
                then []
                else return (n, n+1)

            Monad [] is the instance of Monad

            </pre>


            <div class="cen">
                <img src="../image/chain1.png" width="40%" height="40%" />
            </div>

            <div class="mytitle">Weird Haskell const</div>
            <pre class="mycode">
            <span class="bo">Definition of const in GHC</span> 
            const::a -> b -> a  [keep the first argument and throw away the second argument]
            
            const 1 2  -- output 1
            map(const 3) [1..4] -- output [3, 3, 3]

            <span class="bo">Implement repeat function</span>
            repeat'::Int->a->[a]
            repeat' n a = map(const a) [1..n]

            repeat' 3 "x" -- output ["x", "x", "x"]

            <span class="bo">Implement length function</span>
            let length' = foldr(\_ acc -> 1 + acc) 0

            let length' = foldr(const(1+)) 0

            <span class="bo">Three weird ways to define</span> >> 
            (>>)::IO a -> IO b -> IO b     [this is normal]
            x >> y = x >>= const y         [const is here to save you] 
            x >> y = x >>= \_ -> y         [lambda! Ok, it does make sense] 
            x >> y = (. const) . (>>=)     [that doesn't make sense for me at least]
            </pre>
            <div class="mytitle">let binder inside the map</div>
            <pre class="mycode">
            // let .. in .. => let something then return something
            let list = [1..10]
            map(\x -> let square = x*x in square `mod` 3 == 0) list

            -- let binding in Haskell
            -- ax^2 + bx + c = 0
            -- Find the root of the quadratic equation
            roots a b c =
                    let discriminant= sqrt(b^2 - 4*a*c)
                    in ( (-b + discriminant)/(2*a), (-b - discriminant)/(2*a))

            main =  do 
                    print (roots 3 9 1)
            </pre>


            <div class="mytitle">What is do statement in Haskell</div>
            <div class="highlight"><pre><span class="nf">nameDo</span><span class="ow">::</span><span class="kt">IO</span> <span class="kt">String</span>
<span class="nf">nameDo</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">putStr</span> <span class="s">&quot;What is your first name: &quot;</span>
            <span class="n">first</span> <span class="ow">&lt;-</span> <span class="n">getLine</span>
            <span class="n">putStr</span> <span class="s">&quot;What is your last name: &quot;</span>
            <span class="n">last</span>  <span class="ow">&lt;-</span> <span class="n">getLine</span>
            <span class="kr">let</span> <span class="n">full</span> <span class="ow">=</span> <span class="n">first</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">last</span>
            <span class="n">putStrLn</span><span class="p">(</span><span class="s">&quot;full name &quot;</span> <span class="o">++</span> <span class="n">full</span> <span class="o">++</span> <span class="s">&quot; &quot;</span><span class="p">)</span>
            <span class="n">return</span> <span class="n">full</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">nameDo</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">name</span> <span class="ow">-&gt;</span> <span class="n">print</span> <span class="n">name</span>

<span class="c1">-- alternative</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
    <span class="n">name</span> <span class="ow">&lt;-</span> <span class="n">nameDo</span>
    <span class="n">print</span> <span class="n">name</span>
</pre></div>

            <div class="mytitle">Regular Expression in Haskell</div>
            <div class="highlight"><pre><span class="nf">re1</span> <span class="ow">=</span> <span class="s">&quot;my food&quot;</span>         <span class="o">=~</span> <span class="s">&quot;foo&quot;</span><span class="ow">::</span><span class="kt">Bool</span>                      <span class="c1">-- True</span>
<span class="nf">re2</span> <span class="ow">=</span> <span class="s">&quot;my food foo&quot;</span>     <span class="o">=~</span> <span class="s">&quot;foo&quot;</span><span class="ow">::</span><span class="kt">String</span>                    <span class="c1">-- &quot;foo&quot;</span>
<span class="nf">re3</span> <span class="ow">=</span> <span class="s">&quot;my foolish fool&quot;</span> <span class="o">=~</span> <span class="s">&quot;foo.&quot;</span><span class="ow">::</span><span class="p">[[</span><span class="kt">String</span><span class="p">]]</span>               <span class="c1">-- [[&quot;fool&quot;],[&quot;fool&quot;]]</span>
<span class="nf">re4</span> <span class="ow">=</span> <span class="s">&quot;my foolish fool&quot;</span> <span class="o">=~</span> <span class="s">&quot;foo.&quot;</span><span class="ow">::</span><span class="p">(</span><span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span> <span class="c1">-- (&quot;my &quot;,&quot;fool&quot;,&quot;ish fool&quot;)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="c1">-- /Users/cat/myfile/github/haskell/regexExample.hs </span>
        <span class="c1">-- </span>
        <span class="c1">-- replace pattern </span>
        <span class="c1">--</span>
        <span class="c1">-- pattern = mkRegex &quot;pattern&quot;</span>
        <span class="c1">--</span>
        <span class="c1">-- subRegex pattern inputString replaceString =&gt; output text </span>
        <span class="c1">--</span>
        <span class="c1">-- </span>
        <span class="c1">-- gx http://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html#t:Regex</span>
        <span class="c1">-- </span>
        <span class="kr">let</span> <span class="n">r1</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;google&quot;</span>
        <span class="kr">let</span> <span class="n">input</span> <span class="ow">=</span> <span class="s">&quot;http://google.com&quot;</span>
        <span class="kr">let</span> <span class="n">replace1</span> <span class="ow">=</span> <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0]&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">r1</span> <span class="n">input</span> <span class="n">replace1</span>            <span class="c1">-- http://[google].com</span>

        <span class="kr">let</span> <span class="n">r3</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;(na)*&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">r3</span> <span class="s">&quot;banana&quot;</span> <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0] {</span><span class="se">\\</span><span class="s">1}&quot;</span>    <span class="c1">-- [] {}b5. [] {}a5. [nana] {na}</span>

        <span class="kr">let</span> <span class="n">r4</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;(void)+&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">r4</span> <span class="s">&quot;voidvoid&quot;</span> <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0] {</span><span class="se">\\</span><span class="s">1}&quot;</span>  <span class="c1">-- [voidvoid] {void}</span>

                                                         <span class="c1">-- use POSIX regex  &quot;/pat/i&quot; ignore case</span>
        <span class="kr">let</span> <span class="n">r5</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;.*</span><span class="se">\\</span><span class="s">.pdf&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">r5</span> <span class="s">&quot;http://file.pdf&quot;</span> <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0]&quot;</span> <span class="c1">-- [http://file.PDF]</span>

        <span class="c1">-- capture group, capture email address</span>
        <span class="kr">let</span> <span class="n">r6</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;([A-Za-z._-]+)+@(([a-z])+</span><span class="se">\\</span><span class="s">.([a-z]{2,4}))&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">r6</span> <span class="s">&quot;root_admin.last-name@gmail.com&quot;</span>   <span class="s">&quot;7. [</span><span class="se">\\</span><span class="s">0] {</span><span class="se">\\</span><span class="s">1}{</span><span class="se">\\</span><span class="s">2}&quot;</span>

        <span class="c1">-- capture phone number</span>
        <span class="kr">let</span> <span class="n">p1</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;[0-9]{3}[ -]?[0-9]{3}[ -]?[0-9]{4}&quot;</span> 

        <span class="c1">-- https://hackage.haskell.org/package/regex-compat-0.95.1/docs/Text-Regex.html</span>
        <span class="kr">let</span> <span class="n">r7</span> <span class="ow">=</span> <span class="n">mkRegexWithOpts</span> <span class="s">&quot;(</span><span class="se">\\</span><span class="s">.pdf)&quot;</span> <span class="kt">True</span> <span class="kt">False</span>
        <span class="kr">let</span> <span class="n">input</span> <span class="ow">=</span> <span class="s">&quot;/home/user/file/mybook.PDF&quot;</span>
        <span class="kr">let</span> <span class="n">callMeMaybe</span> <span class="ow">=</span> <span class="n">matchRegex</span> <span class="n">r7</span> <span class="n">input</span>
        <span class="n">print</span> <span class="o">$</span> <span class="n">show</span><span class="p">(</span><span class="n">callMeMaybe</span><span class="p">)</span>

        <span class="c1">-- replace string</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">p1</span> <span class="s">&quot;416-123-4483&quot;</span>  <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0]&quot;</span>    <span class="c1">-- [416-123-4483]</span>

        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">p1</span> <span class="s">&quot;4161234483&quot;</span>    <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0]&quot;</span>    <span class="c1">-- [4161234483]</span>

        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">p1</span> <span class="s">&quot;416 123 4483&quot;</span>  <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0]&quot;</span>    <span class="c1">-- [416 123 4483]</span>
        
        <span class="n">print</span> <span class="o">$</span> <span class="n">splitRegex</span><span class="p">(</span><span class="n">mkRegex</span> <span class="s">&quot;:&quot;</span><span class="p">)</span> <span class="s">&quot;PaloAlto:MountainView&quot;</span> <span class="c1">-- [&quot;PaloAlto&quot;,&quot;MountainView&quot;]</span>

        <span class="c1">-- capture function in ObjectiveC</span>
        <span class="kr">let</span> <span class="n">me</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;(-|</span><span class="se">\\</span><span class="s">+)[[:space:]]*</span><span class="se">\\</span><span class="s">([[:space:]]*[[:print:]]+[[:space:]]*</span><span class="se">\\</span><span class="s">)[[:space:]]*[[:graph:]]+</span><span class="se">\</span>
<span class="se">        \</span><span class="s">[[:space:]]*:?[[:space:]]*([[:space:]]*[[:graph:]]+[[:space:]]*:[[:space:]]*[[:graph:]]+[[:space:]]*)*&quot;</span>

        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">me</span> <span class="s">&quot;- (NSstring*) swap :&quot;</span> <span class="s">&quot;[</span><span class="se">\\</span><span class="s">0]&quot;</span> <span class="c1">-- [- (NSstring*) swap :]</span>

        <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">subRegex</span> <span class="n">me</span> <span class="s">&quot;- (NSstring*) method:(Integer)num width:(Integer)width</span><span class="se">\ </span>
<span class="se">        \</span><span class="s"> height:(NSString*)str&quot;</span> <span class="s">&quot;12. [</span><span class="se">\\</span><span class="s">0]&quot;</span>
        <span class="c1">-- [- (NSstring*) method:(Integer)num width:(Integer)width  height:(NSString*)str]</span>

        <span class="c1">-- https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexLike</span>
        <span class="kr">let</span> <span class="n">r7</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;([A-Za-z]+)&quot;</span> 
        <span class="kr">let</span> <span class="n">count</span> <span class="ow">=</span> <span class="n">matchCount</span> <span class="n">r7</span> <span class="s">&quot;haskell java C++ ObejctiveC aa#&quot;</span> 
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;count = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">count</span>

        <span class="c1">-- https://hackage.haskell.org/package/regex-base-0.93.2/docs/Text-Regex-Base-RegexLike.html#t:RegexLike</span>
        <span class="kr">let</span> <span class="n">r8</span> <span class="ow">=</span> <span class="n">mkRegex</span> <span class="s">&quot;[a-z]+&quot;</span>
        <span class="kr">let</span> <span class="n">bo</span> <span class="ow">=</span> <span class="n">matchTest</span> <span class="n">r8</span> <span class="s">&quot;22323&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Is matched = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">bo</span> <span class="c1">-- return True</span>
        
        <span class="kr">let</span> <span class="n">bo</span> <span class="ow">=</span> <span class="n">matchTest</span> <span class="n">r8</span> <span class="s">&quot;Sunnyvale&quot;</span>
        <span class="n">putStrLn</span> <span class="o">$</span> <span class="s">&quot;Is matched = &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">bo</span> <span class="c1">-- return False</span>
</pre></div>
            <div class="mytitle">Hello World in Haskell</div>
            <div class="highlight"><pre><span class="n">main</span> <span class="o">=</span> <span class="n">print</span><span class="o">(</span><span class="s">&quot;Hello World&quot;</span><span class="o">)</span>
</pre></div>
            <div class="mytitle">Factorial function in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Factorial function</span>
<span class="nf">factorial</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">factorial</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">factorial</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">Sum all integers in a list in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- Sum all the integer in a list</span>
<span class="nf">sumlist</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">sumlist</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="mi">0</span>
<span class="nf">sumlist</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span><span class="o">+</span><span class="n">sumlist</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">Palindrome in Haskell</div>
            <div class="highlight"><pre><span class="nl">isPalindrome:</span><span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span><span class="o">=&gt;[</span><span class="n">a</span><span class="o">]-&gt;</span><span class="n">Bool</span>
<span class="n">isPalindrome</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span> <span class="o">=</span> <span class="n">True</span>
<span class="n">isPalindrome</span> <span class="o">[</span><span class="n">x</span><span class="o">,</span><span class="n">y</span><span class="o">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
<span class="nf">isPalindrome</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="n">xs</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">==</span> <span class="o">(</span><span class="n">last</span> <span class="n">xs</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">init</span><span class="o">(</span><span class="n">xs</span><span class="o">))</span>

<span class="n">main</span> <span class="o">=</span> <span class="k">do</span>
        <span class="n">print</span> <span class="o">(</span><span class="s">&quot;aba=&quot;</span><span class="o">++</span> <span class="n">show</span><span class="o">(</span><span class="n">isPalindrome</span><span class="o">(</span><span class="s">&quot;aaa&quot;</span><span class="o">)))</span>
</pre></div>

            <div class="mytitle">Maximum of a list</div>
            <div class="highlight"><pre><span class="c1">--find the maximum of a list</span>
<span class="nf">maximum1&#39;</span><span class="ow">::</span><span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="ow">-&gt;</span><span class="n">a</span>
<span class="nf">maximum1&#39;</span> <span class="kt">[]</span>  <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;empty list&quot;</span> 
<span class="nf">maximum1&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum1&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> 
        <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">x</span> 
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="n">maxTail</span>
        <span class="kr">where</span> <span class="n">maxTail</span> <span class="ow">=</span> <span class="n">maximum1&#39;</span> <span class="n">xs</span>
<span class="c1">--find the maximum of a list without where</span>
<span class="nf">maximum2&#39;</span><span class="ow">::</span><span class="p">(</span><span class="kt">Ord</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="ow">-&gt;</span><span class="n">a</span>
<span class="nf">maximum2&#39;</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;empty list&quot;</span>
<span class="nf">maximum2&#39;</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">maximum2&#39;</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">max</span> <span class="n">x</span> <span class="p">(</span><span class="n">maximum2&#39;</span> <span class="n">xs</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">If else in Haskell</div>
            <div class="highlight"><pre><span class="c1">--if else in Haskell</span>
<span class="nf">mySign</span> <span class="n">x</span> <span class="ow">=</span> 
        <span class="kr">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span>
            <span class="kr">then</span> <span class="o">-</span><span class="mi">1</span>
        <span class="kr">else</span> <span class="kr">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="kr">then</span> <span class="mi">1</span>
        <span class="kr">else</span> <span class="mi">0</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">mySign</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
            <div class="mytitle">Equation Guarding in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Guards in Haskell</span>
<span class="nf">myGuards</span> <span class="n">x</span> 
        <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="o">|</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
        <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="mi">0</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">myGuards</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
            <div class="cen">
                <img src="../image/guards.svg" width="40%" height="40%" />
            </div>
            <div class="mytitle">let binding in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- let binding in Haskell</span>
<span class="c1">-- ax^2 + bx + c = 0</span>
<span class="c1">-- Find the root of the quadratic equation</span>
<span class="nf">roots</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span>
        <span class="kr">let</span> <span class="n">discriminant</span><span class="ow">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
        <span class="kr">in</span> <span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">roots</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">Print all permutation in Haskell</div>
            <div class="highlight"><pre><span class="nl">myperm:</span><span class="o">:</span> <span class="n">Eq</span> <span class="n">a</span> <span class="o">=&gt;[</span><span class="n">a</span><span class="o">]-&gt;[[</span><span class="n">a</span><span class="o">]]</span>
<span class="n">myperm</span> <span class="o">[]</span> <span class="o">=</span> <span class="o">[[]]</span>
<span class="n">myperm</span> <span class="n">xs</span> <span class="o">=</span> <span class="o">[</span> <span class="n">x</span><span class="o">:</span><span class="n">ys</span> <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">xs</span> <span class="o">,</span> <span class="n">ys</span> <span class="o">&lt;-</span> <span class="n">myperm</span><span class="o">(</span><span class="n">delete</span> <span class="n">x</span> <span class="n">xs</span><span class="o">)]</span>
</pre></div>
            <div class="mytitle">Tree Traversal: Preorder Inorder Postorder/DFS in Haskell</div>
            <pre class="mycode">
            There are preorder inorder and postorder traversals
            preorder: + a b
            inorder:  a + b
            postorder: a b + 

            There are many applications from these traversals
            1. We can rebuild the tree with preorder and inorder
            2. inorder is the sorted order in Binary Search Tree
            3. Quick sort is related to preorder
            4. inorder can be used to check whether a BT is BST
            5. postorder can be implemented with two stacks with recursion
            6. Merge sort is essential the postorder 
            7. Quick sort is essential the preorder 
            8. preorder and postorder can be used in serialization and deseriazation
            </pre>
            <div class="highlight"><pre><span class="n">data</span> <span class="n">Tree</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Empty</span> 
            <span class="o">|</span> <span class="n">Node</span> <span class="nf">a</span> <span class="o">(</span><span class="n">Tree</span> <span class="n">a</span><span class="o">)</span> <span class="o">(</span><span class="n">Tree</span> <span class="n">a</span><span class="o">)</span> <span class="n">deriving</span> <span class="n">Show</span>

<span class="n">mytree</span> <span class="o">=</span> <span class="n">Node</span> <span class="sc">&#39;R&#39;</span> 
            <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;S&#39;</span> 
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;T&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;U&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
            <span class="o">)</span> 
            <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;T&#39;</span> 
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;V&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
                <span class="o">(</span><span class="n">Node</span> <span class="sc">&#39;W&#39;</span> <span class="n">Empty</span> <span class="n">Empty</span><span class="o">)</span>
            <span class="o">)</span> 

<span class="nl">preorderTraversal:</span><span class="o">:</span><span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;[</span><span class="n">a</span><span class="o">]</span>
<span class="n">preorderTraversal</span> <span class="n">Empty</span> <span class="o">=</span> <span class="o">[]</span> 
<span class="n">preorderTraversal</span> <span class="o">(</span><span class="n">Node</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="n">a</span><span class="o">:(</span><span class="n">preorderTraversal</span> <span class="n">l</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">preorderTraversal</span> <span class="n">r</span><span class="o">)</span>
 
<span class="nl">inorderTraversal:</span><span class="o">:</span><span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;[</span><span class="n">a</span><span class="o">]</span>
<span class="n">inorderTraversal</span> <span class="n">Empty</span> <span class="o">=</span> <span class="o">[]</span> 
<span class="n">inorderTraversal</span> <span class="o">(</span><span class="n">Node</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">inorderTraversal</span> <span class="n">l</span><span class="o">)</span> <span class="o">++[</span><span class="n">a</span><span class="o">]++(</span><span class="n">inorderTraversal</span> <span class="n">r</span><span class="o">)</span>
 
<span class="nl">postorderTraversal:</span><span class="o">:</span><span class="n">Tree</span> <span class="n">a</span> <span class="o">-&gt;[</span><span class="n">a</span><span class="o">]</span>
<span class="n">postorderTraversal</span> <span class="n">Empty</span> <span class="o">=</span> <span class="o">[]</span> 
<span class="n">postorderTraversal</span><span class="o">(</span><span class="n">Node</span> <span class="n">a</span> <span class="n">l</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="o">(</span><span class="n">postorderTraversal</span> <span class="n">l</span><span class="o">)</span> <span class="o">++</span> <span class="o">(</span><span class="n">postorderTraversal</span> <span class="n">r</span><span class="o">)</span> <span class="o">++</span> <span class="o">[</span><span class="n">a</span><span class="o">]</span>
</pre></div>
            <div class="mytitle">Typeclass Record in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- /Users/cat/myfile/github/haskell/Record.hs</span>
<span class="c1">-- ref: http://learnyouahaskell.com/making-our-own-types-and-typeclasses </span>
<span class="c1">-- -------------------------------------------------------------------------------- </span>
<span class="c1">-- 1. how to create record</span>
<span class="c1">-- 2. how to access field from typeclass, e.g. person.lastName in java</span>
<span class="c1">-- 3. how to override == without doing anything with deriving(Eq)</span>
<span class="c1">-- -------------------------------------------------------------------------------- </span>
<span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="p">{</span><span class="n">firstName</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span> <span class="n">lastName</span><span class="ow">::</span><span class="kt">String</span><span class="p">,</span> <span class="n">age</span><span class="ow">::</span><span class="kt">Int</span><span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">)</span>

<span class="c1">-- Person derives from Eq, Haskell generates (==) and (/=) for us automatically,</span>
<span class="c1">-- the catch is String and Int also have to be part of (Eq) typeclass </span>
<span class="c1">-- access field from typeclass with record</span>
<span class="nf">showPerson</span><span class="ow">::</span><span class="kt">Person</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">showPerson</span> <span class="kt">Person</span><span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="n">firstName</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="n">lastName</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="n">age</span><span class="p">}</span> 
                        <span class="ow">=</span> <span class="s">&quot;[&quot;</span> <span class="o">++</span> <span class="n">firstName</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">lastName</span> <span class="o">++</span> <span class="s">&quot; &quot;</span> <span class="o">++</span> <span class="n">show</span><span class="p">(</span><span class="n">age</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;]&quot;</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="kr">let</span> <span class="n">person</span> <span class="ow">=</span> <span class="kt">Person</span><span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Jonathan&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Michell&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">20</span><span class="p">}</span>
        <span class="kr">let</span> <span class="n">animal</span> <span class="ow">=</span> <span class="kt">Person</span><span class="p">{</span><span class="n">firstName</span> <span class="ow">=</span> <span class="s">&quot;Nonhuman&quot;</span><span class="p">,</span> <span class="n">lastName</span> <span class="ow">=</span> <span class="s">&quot;Michell&quot;</span><span class="p">,</span> <span class="n">age</span> <span class="ow">=</span> <span class="mi">20</span><span class="p">}</span>
        <span class="n">print</span> <span class="o">$</span> <span class="n">showPerson</span> <span class="n">person</span>
        <span class="n">print</span> <span class="o">$</span> <span class="n">showPerson</span> <span class="p">(</span><span class="kt">Person</span> <span class="s">&quot;Steven&quot;</span> <span class="s">&quot;Jobs&quot;</span> <span class="mi">30</span><span class="p">)</span>
        <span class="n">print</span> <span class="o">$</span> <span class="n">person</span> <span class="o">==</span> <span class="n">person</span>  <span class="c1">-- True</span>
        <span class="n">print</span> <span class="o">$</span> <span class="n">person</span> <span class="o">==</span> <span class="n">animal</span>  <span class="c1">-- False </span>
        <span class="n">print</span> <span class="o">$</span> <span class="n">person</span> <span class="o">/=</span> <span class="n">animal</span>  <span class="c1">-- True </span>
        <span class="n">fl</span>
        <span class="c1">-- person.firstName in java</span>
        <span class="n">print</span> <span class="o">$</span> <span class="s">&quot;firstName=&quot;</span> <span class="o">++</span> <span class="n">firstName</span> <span class="n">person</span>  <span class="c1">-- Jonathan</span>
        <span class="n">print</span> <span class="o">$</span> <span class="s">&quot;lastName =&quot;</span> <span class="o">++</span> <span class="n">lastName</span> <span class="n">person</span>   <span class="c1">-- Michell </span>
        <span class="n">print</span> <span class="o">$</span> <span class="s">&quot;age      =&quot;</span> <span class="o">++</span> <span class="n">show</span><span class="p">(</span><span class="n">age</span> <span class="n">person</span><span class="p">)</span>  <span class="c1">-- 20</span>
</pre></div>

            <div class="mytitle">Typeclass 1 in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- Typeclass in Haskell</span>
<span class="c1">-- Shape is similar to interface in Java</span>
<span class="c1">-- Circle and Rectangle are similar to class in Java</span>

<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">area</span><span class="ow">::</span><span class="kt">Shape</span><span class="ow">-&gt;</span><span class="kt">Float</span>
<span class="nf">area</span><span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">r</span><span class="o">^</span><span class="mi">2</span>
<span class="nf">area</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="n">topx</span> <span class="n">topy</span> <span class="n">bottomx</span> <span class="n">bottomy</span><span class="p">)</span> <span class="ow">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">bottomy</span> <span class="o">-</span> <span class="n">topy</span><span class="p">)</span><span class="o">*</span><span class="n">abs</span><span class="p">(</span><span class="n">bottomx</span> <span class="o">-</span> <span class="n">topx</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Typeclass in Haskell&quot;</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">area</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">area</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">More Typeclass 2 in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Typeclass 2 in Haskell</span>
<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">area</span><span class="ow">::</span><span class="kt">Shape</span><span class="ow">-&gt;</span><span class="kt">Float</span>
<span class="nf">area</span><span class="p">(</span><span class="kt">Circle</span> <span class="kr">_</span> <span class="n">r</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pi</span><span class="o">*</span><span class="n">r</span><span class="o">^</span><span class="mi">2</span> 
<span class="nf">area</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">topx</span> <span class="n">topy</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="n">bottomx</span> <span class="n">bottomy</span><span class="p">))</span> <span class="ow">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">bottomy</span> <span class="o">-</span> <span class="n">topy</span><span class="p">)</span><span class="o">*</span><span class="n">abs</span><span class="p">(</span><span class="n">bottomx</span> <span class="o">-</span> <span class="n">topx</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">area</span> <span class="o">$</span> <span class="kt">Circle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">area</span> <span class="o">$</span> <span class="kt">Rectangle</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">Point</span> <span class="mi">2</span> <span class="mi">7</span><span class="p">))</span>
</pre></div>
            <div class="mytitle">More Typeclass 3 in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- Library/WebServer/Documents/zsurface/github/haskell/typeclass3.hs</span>
<span class="c1">-- Typeclass in Haskell</span>
<span class="c1">-- Shape is similar to interface in Java</span>
<span class="c1">-- Circle and Rectangle are similar to class in Java</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="c1">--call constructor</span>
<span class="nf">circleShape</span><span class="ow">::</span><span class="kt">Shape</span>
<span class="nf">circleShape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span>
<span class="nf">rectangleShape</span> <span class="ow">=</span> <span class="kt">Rectangle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> 

<span class="c1">--list of typeclasses</span>
<span class="nf">listShape</span><span class="ow">::</span><span class="p">[</span><span class="kt">Shape</span><span class="p">]</span>
<span class="nf">listShape</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Circle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">,</span> <span class="kt">Rectangle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">circleShape</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">rectangleShape</span><span class="p">)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">listShape</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">More Typeclass 4 in Haskell</div>
            <div class="highlight"><pre><span class="c1">--Library/WebServer/Documents/zsurface/github/haskell/typeclass4.hs</span>
<span class="c1">--Deconstructing type in Haskell</span>

<span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">Point</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
<span class="kr">data</span> <span class="kt">Shape</span> <span class="ow">=</span> <span class="kt">Circle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="o">|</span> <span class="kt">Rectangle</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kt">Float</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>


<span class="nf">showShape</span><span class="ow">::</span><span class="kt">Shape</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">showShape</span><span class="p">(</span><span class="kt">Circle</span> <span class="n">x</span> <span class="n">y</span> <span class="n">radial</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;  &quot;</span><span class="o">++</span><span class="n">show</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">++</span> <span class="s">&quot;  &quot;</span> <span class="o">++</span> <span class="n">show</span><span class="p">(</span><span class="n">radial</span><span class="p">)</span> 
<span class="nf">showShape</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="n">x1</span> <span class="n">y1</span> <span class="n">x2</span> <span class="n">y2</span> <span class="p">)</span> <span class="ow">=</span> <span class="n">show</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">++</span> <span class="s">&quot;  &quot;</span><span class="o">++</span><span class="n">show</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span><span class="o">++</span> <span class="s">&quot;  &quot;</span> <span class="o">++</span> <span class="n">show</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span><span class="o">++</span><span class="s">&quot; &quot;</span><span class="o">++</span><span class="n">show</span><span class="p">(</span><span class="n">y2</span><span class="p">)</span> 

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">showShape</span><span class="p">(</span><span class="kt">Circle</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
        <span class="n">print</span><span class="p">(</span><span class="n">showShape</span><span class="p">(</span><span class="kt">Rectangle</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">))</span>
</pre></div>
            <div class="mytitle">More Typeclass 5 in Haskell</div>
            <div class="highlight"><pre><span class="n">data</span> <span class="n">Foo</span> <span class="o">=</span> <span class="n">Bar</span> <span class="o">|</span> <span class="n">Baz</span> <span class="n">Int</span>
<span class="nl">myfun:</span><span class="o">:</span><span class="n">Foo</span><span class="o">-&gt;</span><span class="n">Int</span>
<span class="n">myfun</span>   <span class="n">Bar</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">myfun</span>   <span class="o">(</span><span class="n">Baz</span> <span class="n">x</span><span class="o">)</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>
            <div class="mytitle">More Typeclass 6 in Haskell</div>
            <div class="highlight"><pre><span class="n">data</span> <span class="n">Person</span> <span class="o">=</span> <span class="n">Person</span> <span class="n">String</span> <span class="n">Integer</span> <span class="n">String</span> <span class="n">deriving</span> <span class="n">Show</span>
        
<span class="nl">getAge:</span><span class="o">:</span><span class="n">Person</span><span class="o">-&gt;</span><span class="n">Integer</span>
<span class="nf">getAge</span><span class="o">(</span><span class="n">Person</span> <span class="n">_</span> <span class="n">n</span> <span class="n">_</span><span class="o">)</span> <span class="o">=</span> <span class="n">n</span>

<span class="nl">getName:</span><span class="o">:</span><span class="n">Person</span><span class="o">-&gt;</span><span class="n">String</span>
<span class="nf">getName</span><span class="o">(</span><span class="n">Person</span> <span class="n">name</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">=</span> <span class="n">name</span>

<span class="nl">getInfo:</span><span class="o">:</span><span class="n">Person</span><span class="o">-&gt;</span><span class="n">String</span>
<span class="n">getInfo</span> <span class="n">p</span><span class="err">@</span><span class="o">(</span><span class="n">Person</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span><span class="o">)</span> <span class="o">=</span> <span class="s">&quot;(&quot;</span> <span class="o">++</span> <span class="n">show</span><span class="o">(</span><span class="n">p</span><span class="o">)</span> <span class="o">++</span> <span class="s">&quot;)&quot;</span>
</pre></div>
            <div class="mytitle">More Typeclass 7 in Haskell</div>
            <div class="highlight"><pre><span class="kr">data</span> <span class="kt">Point</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Pt</span> <span class="n">a</span> <span class="n">a</span> <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>

<span class="nf">dist</span><span class="ow">::</span><span class="kt">Point</span> <span class="kt">Int</span><span class="ow">-&gt;</span> <span class="kt">Point</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">dist</span> <span class="p">(</span><span class="kt">Pt</span> <span class="n">x0</span> <span class="n">y0</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pt</span> <span class="n">x1</span> <span class="n">y1</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x0</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y0</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">y0</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">print</span> <span class="p">(</span><span class="kt">Pt</span> <span class="mi">1</span> <span class="mi">3</span> <span class="ow">::</span> <span class="kt">Point</span> <span class="kt">Int</span><span class="p">)</span> 
        <span class="n">print</span> <span class="o">$</span> <span class="n">dist</span><span class="p">(</span><span class="kt">Pt</span> <span class="mi">1</span> <span class="mi">4</span><span class="p">)</span> <span class="p">(</span><span class="kt">Pt</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">data type in Haskell</div>
            <pre>
            data Point a = Pt a a
            norm::(Point Int)->(Point Int)->Int
            norm(Pt a1 b1) (Pt a2 b2)  = a1*a2 + b1*b2 

            dist::(Point Int)->(Point Int)->Int
            dist (Pt a1 b1) (Pt a2 b2) = norm (Pt a1 b1) (Pt a2 b2) 
            
            // in Java 
            class Point&lt;T&gt;{
                Point(T t1, T t2){}
            }
            </pre>
            <div class="mytitle">Following is java interface and two classes</div>
            <div class="highlight"><pre><span class="kd">interface</span> <span class="nc">Shape</span>
<span class="o">{</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getArea</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Circle</span> <span class="kd">implements</span> <span class="n">Shape</span>
<span class="o">{</span>
    <span class="kt">double</span> <span class="n">x</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">y</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">radial</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Circle</span><span class="o">(</span><span class="kt">double</span> <span class="n">x</span><span class="o">,</span> <span class="kt">double</span> <span class="n">y</span><span class="o">,</span> <span class="kt">double</span> <span class="n">radial</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">radial</span> <span class="o">=</span> <span class="n">radial</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getArea</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="mf">3.14</span><span class="o">*</span><span class="n">radial</span><span class="o">*</span><span class="n">radial</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Rectangle</span> <span class="kd">implements</span> <span class="n">Shape</span>
<span class="o">{</span>
    <span class="kt">double</span> <span class="n">topx</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">topy</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">bottomx</span><span class="o">;</span>
    <span class="kt">double</span> <span class="n">bottomy</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">Rectangle</span><span class="o">(</span><span class="kt">double</span> <span class="n">topx</span><span class="o">,</span> <span class="kt">double</span> <span class="n">topy</span><span class="o">,</span> <span class="kt">double</span> <span class="n">bottomx</span><span class="o">,</span> <span class="kt">double</span> <span class="n">bottomy</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">topx</span> <span class="o">=</span> <span class="n">topx</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">topy</span> <span class="o">=</span> <span class="n">topy</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bottomx</span><span class="o">=</span> <span class="n">bottomx</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">bottomy</span><span class="o">=</span> <span class="n">bottomy</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kt">double</span> <span class="nf">getArea</span><span class="o">()</span>
    <span class="o">{</span>
        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">bottomx</span> <span class="o">-</span> <span class="n">topx</span><span class="o">)*</span><span class="n">Math</span><span class="o">.</span><span class="na">abs</span><span class="o">(</span><span class="n">bottomy</span> <span class="o">-</span> <span class="n">topy</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

            <div class="mytitle">Crazy function in Haskell</div>
            <div class="highlight"><pre><span class="nf">f</span><span class="ow">::</span><span class="nb">()</span><span class="ow">-&gt;</span><span class="nb">()</span>
<span class="nf">f</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span> 

<span class="nf">f1</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f1</span> <span class="kr">_</span> <span class="ow">=</span> <span class="nb">()</span> <span class="o">==</span> <span class="nb">()</span> 

<span class="nf">f2</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f2</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="kt">True</span> 

<span class="nf">f3</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f3</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span> 

<span class="nf">f4</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f4</span> <span class="n">undefined</span> <span class="ow">=</span> <span class="kt">False</span> 

<span class="nf">f5</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f5</span> <span class="n">undefined</span> <span class="ow">=</span> <span class="n">undefined</span> 

<span class="nf">f6</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f6</span> <span class="kr">_</span> <span class="ow">=</span> <span class="n">undefined</span> 

<span class="nf">f7</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f7</span> <span class="ow">=</span> <span class="n">undefined</span> 

<span class="nf">f8</span><span class="ow">::</span><span class="kt">Bool</span><span class="ow">-&gt;</span><span class="kt">Bool</span>
<span class="nf">f8</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">undefined</span>

<span class="nf">f9</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f9</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> 

<span class="nf">f10</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f10</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f9</span> <span class="n">x</span> 

<span class="nf">f11</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f11</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">f9</span> <span class="mi">1</span><span class="p">)</span> 

<span class="nf">f12</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f12</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">Composite function in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- function composition foldable</span>
<span class="nf">f1</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f1</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mi">10</span> 

<span class="nf">f2</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f2</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">10</span> 
<span class="nf">compose</span> <span class="ow">=</span> <span class="p">(</span><span class="n">f1</span><span class="o">.</span><span class="n">f2</span><span class="p">)</span> <span class="mi">10</span>
</pre></div>

            <div class="mytitle">Foldable in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- identity = [] </span>
<span class="nf">concat2</span><span class="ow">::</span><span class="p">[[</span><span class="kt">Int</span><span class="p">]]</span><span class="ow">-&gt;</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">concat2</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">val</span> <span class="n">acc</span><span class="ow">-&gt;</span><span class="n">val</span> <span class="o">++</span> <span class="n">acc</span><span class="p">)</span> <span class="kt">[]</span> <span class="n">vals</span>
<span class="c1">-- concat2 [[1, 2], [3, 4]] =  [1, 2] ++ ([3, 4] ++ []) = [1, 2, 3, 4]</span>

<span class="nf">fo</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">((</span><span class="kt">:</span><span class="p">))</span> <span class="kt">[]</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> 
<span class="c1">-- output [1, 2, 3]</span>

<span class="c1">-- alternative definition of map </span>
<span class="nf">map&#39;</span><span class="ow">::</span><span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span><span class="ow">-&gt;</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="ow">-&gt;</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map&#39;</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">((</span><span class="kt">:</span><span class="p">)</span><span class="o">.</span><span class="n">f</span><span class="p">)</span> <span class="kt">[]</span> 
<span class="c1">-- map&#39; (1+) 1 [1, 2, 3] = [2, 3, 4]</span>


<span class="c1">-- identity = 0</span>
<span class="nf">sum1</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">sum1</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="mi">0</span> <span class="n">vals</span> 

<span class="c1">-- identity = 1 </span>
<span class="nf">product1</span><span class="ow">::</span><span class="p">[</span><span class="kt">Int</span><span class="p">]</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">product1</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span> <span class="mi">1</span> <span class="n">vals</span> 

<span class="c1">-- identity = [] </span>
<span class="nf">concat1</span><span class="ow">::</span><span class="p">[[</span><span class="kt">Char</span><span class="p">]]</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">concat1</span> <span class="n">vals</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span><span class="n">concat</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span> <span class="kt">[]</span> <span class="n">vals</span>
</pre></div>

            <div class="mytitle">instance and class in Haskell</div>
            <div class="highlight"><pre><span class="c1">--class  Eq a  where</span>
   <span class="c1">--(==), (/=) :: a -&gt; a -&gt; Bool</span>
   <span class="c1">--x /= y     =  not (x == y)</span>
   <span class="c1">--x == y     =  not (x /= y)</span>

<span class="c1">-- instance class</span>
<span class="kr">data</span> <span class="kt">Myfoo</span> <span class="ow">=</span> <span class="kt">Myfoo</span><span class="p">{</span><span class="n">int</span><span class="ow">::</span><span class="kt">Integer</span><span class="p">,</span> <span class="n">str</span><span class="ow">::</span><span class="kt">String</span><span class="p">}</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Myfoo</span> <span class="kr">where</span> 
    <span class="p">(</span><span class="kt">Myfoo</span> <span class="n">int1</span> <span class="n">str1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="kt">Myfoo</span> <span class="n">int2</span> <span class="n">str2</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">int1</span> <span class="o">==</span> <span class="n">int2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">str1</span> <span class="o">==</span> <span class="n">str2</span>
</pre></div>

            <div class="mytitle">Functor in Haskell</div>
            <div class="highlight"><pre><span class="kr">data</span> <span class="kt">MyMaybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MyJust</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">MyNothing</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
 
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">MyMaybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">MyNothing</span> <span class="ow">=</span> <span class="kt">MyNothing</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">MyJust</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">MyJust</span> <span class="p">(</span><span class="n">f</span> <span class="n">a</span><span class="p">)</span>
</pre></div>


            <div class="mytitle">Algebraic Data Type in Haskell</div>
            <pre class="mycode">
            <span class="bo">Algebraic Data type - Algebraic refers to the property that an algebraic data type is created</span> 
                                  by algebraic operations such as <span class="bo">sum</span> and <span class="bo">product</span>. There 
            <span class="bo">Sum</span> is alternation[logic OR operator][A | B, meaning A or B but not both, e.g. enum in Java/C++]
            <span class="bo">Product</span> is combination[logic AND operator][A B, meaning A and B together, e.g. tuple, record]

            data Maybe a = Just a | Nothing 
            There are two constructors:
            Just is one constructor with one parameter a 
            Nothing is other constrcutor with no parameter
            
            -- Try to simulate Maybe in Java
            interface Maybe<T>{ }
            class Just implements Maybe<String>{
                public Just(String s){ }
            }
            class Nothing implements Maybe{
                public Nothing(){}
            }
            </pre>
            <div class="highlight"><pre><span class="c1">-- City is similar to Enum in Java/C++</span>
<span class="c1">-- public enum City </span>
<span class="c1">-- {</span>
<span class="c1">--  PaloAlto, </span>
<span class="c1">--  MountainView </span>
<span class="c1">--  Sunnyvale</span>
<span class="c1">-- }</span>
<span class="c1">-- City city = MountainView</span>
<span class="c1">--</span>
<span class="kr">data</span> <span class="kt">City</span> <span class="ow">=</span> <span class="kt">PaloAlto</span>
            <span class="o">|</span> <span class="kt">MountainView</span>
            <span class="o">|</span> <span class="kt">Sunnyvale</span>
    <span class="kr">deriving</span><span class="p">(</span><span class="kt">Show</span><span class="p">)</span>
            

<span class="nf">city</span><span class="ow">::</span><span class="kt">City</span>
<span class="nf">city</span> <span class="ow">=</span> <span class="kt">MountainView</span>

<span class="nf">listofCity</span><span class="ow">::</span><span class="p">[</span><span class="kt">City</span><span class="p">]</span>
<span class="nf">listofCity</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">PaloAlto</span><span class="p">,</span> <span class="kt">Sunnyvale</span><span class="p">,</span> <span class="kt">MountainView</span><span class="p">]</span>

<span class="nf">isGoodCity</span><span class="ow">::</span><span class="kt">City</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">isGoodCity</span> <span class="kt">PaloAlto</span>     <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isGoodCity</span> <span class="kt">MountainView</span> <span class="ow">=</span> <span class="kt">True</span>
<span class="nf">isGoodCity</span> <span class="kt">Sunnyvale</span>    <span class="ow">=</span> <span class="kt">False</span>

<span class="kr">data</span> <span class="kt">MyType</span> <span class="ow">=</span> <span class="kt">Failture</span>
            <span class="o">|</span> <span class="kt">OK</span> <span class="p">(</span><span class="kt">Double</span><span class="p">)</span>
    <span class="kr">deriving</span> <span class="kt">Show</span>

<span class="nf">fa</span> <span class="ow">=</span> <span class="kt">Failture</span>
<span class="nf">ok</span> <span class="ow">=</span> <span class="kt">OK</span> <span class="mf">3.31</span>

<span class="nf">safeDiv</span><span class="ow">::</span><span class="kt">Double</span><span class="ow">-&gt;</span><span class="kt">Double</span><span class="ow">-&gt;</span><span class="kt">MyType</span>
<span class="nf">safeDiv</span> <span class="kr">_</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">Failture</span>
<span class="nf">safeDiv</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kt">OK</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">y</span><span class="p">)</span>

<span class="nf">f</span><span class="ow">::</span><span class="kt">String</span><span class="ow">-&gt;</span><span class="kt">MyType</span>
<span class="nf">f</span>   <span class="s">&quot;&quot;</span>    <span class="ow">=</span> <span class="kt">Failture</span>
<span class="nf">f</span>   <span class="s">&quot;cat&quot;</span> <span class="ow">=</span> <span class="kt">OK</span> <span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="nf">f</span>   <span class="s">&quot;dog&quot;</span> <span class="ow">=</span> <span class="kt">OK</span> <span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="nf">f</span>   <span class="kr">_</span>     <span class="ow">=</span> <span class="kt">OK</span> <span class="mf">3.3</span>


<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">isGoodCity</span> <span class="kt">PaloAlto</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">isGoodCity</span> <span class="kt">Sunnyvale</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">ok</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="s">&quot;cat&quot;</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">f</span> <span class="s">&quot;dog&quot;</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">safeDiv</span> <span class="mi">3</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">print</span> <span class="p">(</span><span class="n">safeDiv</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>

            <div class="mytitle">foldr and foldl in Haskell</div>
            <div class="cen">
            <img src="../image/fold.svg" width="50%" height="50%" /><br> 
            </div>
            <div class="highlight"><pre><span class="c1">-- folding examples</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">foldr</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">-- output 2</span>
        <span class="n">print</span><span class="p">(</span><span class="n">foldl</span> <span class="p">(</span><span class="o">-</span><span class="p">)</span> <span class="mi">1</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> <span class="c1">-- output -8 </span>

        <span class="kr">let</span> <span class="n">fr</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span><span class="n">concat</span><span class="p">[</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&quot;)&quot;</span><span class="p">])</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">map</span> <span class="n">show</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">fr</span><span class="p">)</span>
        <span class="c1">--output &quot;(2-(3-(4-1)))&quot;</span>

        <span class="kr">let</span> <span class="n">fl</span> <span class="ow">=</span> <span class="n">foldl</span> <span class="p">(</span><span class="nf">\</span><span class="n">x</span> <span class="n">y</span><span class="ow">-&gt;</span><span class="n">concat</span><span class="p">[</span><span class="s">&quot;(&quot;</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="s">&quot;)&quot;</span><span class="p">])</span> <span class="s">&quot;1&quot;</span> <span class="p">(</span><span class="n">map</span> <span class="n">show</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
        <span class="n">print</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span>
        <span class="c1">--output &quot;(((1-2)-3)-4)&quot;</span>
</pre></div>
 <br>
            <div class="highlight"><pre><span class="c1">// foldr (-) 1 [2, 3, 4]  output = 2 </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">foldr</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">4</span><span class="o">){</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span><span class="o">{</span>
            <span class="k">return</span> <span class="n">n</span> <span class="o">-</span> <span class="n">foldr</span><span class="o">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="c1">// foldl (-) 1 [2, 3, 4] output = -8 </span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">foldl</span><span class="o">(</span><span class="kt">int</span> <span class="n">n</span><span class="o">){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="o">){</span>
            <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span><span class="k">else</span><span class="o">{</span>
            <span class="k">return</span> <span class="n">foldl</span><span class="o">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">n</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
</pre></div>
 <br>
            <div class="cen">
            <img src="../image/fold2.svg" width="50%" height="50%" /><br> 
            </div>

            <div class="mytitle">
            Map and Foldr in Haskell<br>
            </div>
            <div class="mytext">
            Map can be defined by foldr, let's look at the definition of map in Haskell
            </div>
            <pre class="mycode">
            map::(a->b)->[a]->[b]
            map f (x:xs) = f x : map f xs

            foldr f a [n1, n2, n3] = n1 `f` (n2 `f` (a `f` n3))

            -- e.g.
            foldr (+) 1 [2, 3, 4] = 2 + (3 + (4 + 1))
            
            foldr ((:)) [] [2, 3, 4] = 2:3:4:[] = [2, 3, 4]

            map'::(a->b)->[a]->[b]
            map' f = foldr((:)) []

            -- remove brackets
            foldr (++) [] [["a", "b"], ["c"]]
            -- output ["a", "b", "c"]

            </pre>

            <div class="mytitle">let expressions and where causes local variable binding in Haskell</div>
            <div class="highlight"><pre><span class="c1">-- where cause and let binding in Haskell</span>
<span class="c1">--</span>
<span class="c1">-- let binding in Haskell</span>
<span class="c1">-- ax^2 + bx + c = 0</span>
<span class="c1">-- Find the root of the quadratic equation</span>

<span class="nf">roots</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="ow">=</span>
        <span class="kr">let</span> <span class="n">discriminant</span><span class="ow">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">4</span><span class="o">*</span><span class="n">a</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
        <span class="kr">in</span> <span class="p">(</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">+</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="n">b</span> <span class="o">-</span> <span class="n">discriminant</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>

<span class="nf">longest</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">longest</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">length</span> <span class="p">(</span><span class="n">longest</span> <span class="n">xs</span><span class="p">)</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="p">(</span><span class="n">longest</span> <span class="n">xs</span><span class="p">)</span>

<span class="nf">newlongest</span> <span class="kt">[]</span>     <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">newlongest</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">length</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">length</span> <span class="n">max</span> <span class="kr">then</span> <span class="n">x</span> <span class="kr">else</span> <span class="n">max</span> 
    <span class="kr">where</span> <span class="n">max</span> <span class="ow">=</span> <span class="n">newlongest</span> <span class="n">xs</span>

<span class="nf">main</span> <span class="ow">=</span>  <span class="kr">do</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">roots</span> <span class="mi">3</span> <span class="mi">9</span> <span class="mi">1</span><span class="p">)</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">longest</span> <span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span> 
        <span class="n">print</span> <span class="p">(</span><span class="n">newlongest</span> <span class="p">[</span><span class="kt">[]</span><span class="p">,[</span><span class="mi">1</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
</pre></div>

            <div class="mytitle">simple case in Haskell</div>
            <div class="mytext">
            Case in Haskell is like switch statement in Java, except it is more beautiful! 
            </div>
            <div class="highlight"><pre><span class="nf">suffixed</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">n</span> <span class="o">++</span> <span class="n">suffix</span>
    <span class="kr">where</span> 
        <span class="n">suffix</span>
            <span class="o">|</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">100</span> <span class="p">`</span><span class="n">div</span><span class="p">`</span> <span class="mi">10</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">=</span> <span class="s">&quot;th&quot;</span>
            <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">n</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">10</span> <span class="kr">of</span> 
                <span class="mi">1</span> <span class="ow">-&gt;</span> <span class="s">&quot;st&quot;</span>
                <span class="mi">2</span> <span class="ow">-&gt;</span> <span class="s">&quot;nd&quot;</span>
                <span class="mi">3</span> <span class="ow">-&gt;</span> <span class="s">&quot;rd&quot;</span>
                <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;th&quot;</span>

<span class="nf">result</span> <span class="ow">=</span> <span class="n">map</span> <span class="n">suffixed</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">40</span><span class="p">]</span>
</pre></div>
            <div class="mytitle">practical case in Haskell</div>
            <div class="highlight"><pre><span class="nf">fun</span> <span class="n">x</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="kr">of</span>
            <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="s">&quot;even&quot;</span>
            <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;odd&quot;</span>

<span class="nf">fun&#39;</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">answer</span> 
            <span class="kr">where</span> <span class="n">answer</span> 
                    <span class="o">|</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="ow">=</span> <span class="s">&quot;less then 10&quot;</span>
                    <span class="o">|</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">10</span> <span class="ow">=</span> <span class="s">&quot;equal 10&quot;</span>
                    <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">x</span> <span class="p">`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span> <span class="kr">of</span> 
                                        <span class="mi">0</span> <span class="ow">-&gt;</span> <span class="s">&quot;greater than 10 even&quot;</span> 
                                        <span class="kr">_</span> <span class="ow">-&gt;</span> <span class="s">&quot;greater than 10 and odd&quot;</span>
</pre></div>

            <div class="mytitle">First OpenGL Hello World in Haskell</div>
            <div class="highlight"><pre><span class="kn">import</span> <span class="nn">Graphics.UI.GLUT</span>

<span class="nl">myPoints:</span><span class="o">:[(</span><span class="n">GLfloat</span><span class="o">,</span> <span class="n">GLfloat</span><span class="o">,</span> <span class="n">GLfloat</span><span class="o">)]</span>
<span class="n">myPoints</span> <span class="o">=</span> <span class="o">[(</span><span class="n">sin</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="mi">12</span><span class="o">),</span> <span class="n">cos</span><span class="o">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">k</span><span class="o">/</span><span class="mi">12</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span> <span class="o">|</span> <span class="n">k</span> <span class="o">&lt;-</span> <span class="o">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">12</span><span class="o">]]</span>

<span class="nl">main:</span><span class="o">:</span><span class="n">IO</span><span class="o">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">_progName</span><span class="o">,</span> <span class="n">_args</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">getArgsAndInitialize</span>
    <span class="n">_window</span> <span class="o">&lt;-</span> <span class="n">createWindow</span> <span class="s">&quot;Hello World&quot;</span>
    <span class="n">displayCallback</span> <span class="n">$</span><span class="o">=</span> <span class="n">display</span>
    <span class="n">mainLoop</span>

<span class="nl">display:</span><span class="o">:</span><span class="n">DisplayCallback</span>
<span class="n">display</span> <span class="o">=</span> <span class="k">do</span>
    <span class="n">clear</span> <span class="o">[</span> <span class="n">ColorBuffer</span><span class="o">]</span>
    <span class="n">renderPrimitive</span> <span class="n">Triangles$</span> <span class="nf">mapM_</span> <span class="o">(</span><span class="err">\</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">vertex</span> <span class="n">$</span> <span class="n">Vertex3</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="o">)</span> <span class="n">myPoints</span>
    <span class="n">flush</span>
</pre></div>

            <div class="cen">
                <img src="../image/firstOpenGL.png" width="30%" height="30%" />
            </div>
            <div class="mytitle">OpenGL Vertex and Color in Haskell</div>
            <div class="highlight"><pre><span class="kn">import</span> <span class="nn">Graphics.UI.GLUT</span>

<span class="nl">main:</span><span class="o">:</span><span class="n">IO</span><span class="o">()</span>
<span class="n">main</span> <span class="o">=</span> <span class="k">do</span>
    <span class="o">(</span><span class="n">_progName</span><span class="o">,</span> <span class="n">_args</span><span class="o">)</span> <span class="o">&lt;-</span> <span class="n">getArgsAndInitialize</span>
    <span class="n">_window</span> <span class="o">&lt;-</span> <span class="n">createWindow</span> <span class="s">&quot;OpenGL Vertex and Color in Haskell&quot;</span>
    <span class="n">displayCallback</span> <span class="n">$</span><span class="o">=</span> <span class="n">display</span>
    <span class="n">mainLoop</span>

<span class="nl">display:</span><span class="o">:</span><span class="n">DisplayCallback</span>
<span class="n">display</span> <span class="o">=</span> <span class="k">do</span>
    <span class="n">let</span> <span class="n">color3f</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="o">=</span> <span class="n">color</span> <span class="n">$</span> <span class="n">Color3</span> <span class="n">r</span> <span class="nf">g</span> <span class="o">(</span><span class="n">b</span><span class="o">::</span><span class="n">GLfloat</span><span class="o">)</span>
        <span class="n">vertex3f</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="n">vertex</span> <span class="n">$</span> <span class="n">Vertex3</span> <span class="n">x</span> <span class="nf">y</span> <span class="o">(</span><span class="n">z</span><span class="o">::</span><span class="n">GLfloat</span><span class="o">)</span>
    <span class="n">clear</span> <span class="o">[</span><span class="n">ColorBuffer</span><span class="o">]</span>
    <span class="n">renderPrimitive</span> <span class="n">Quads</span> <span class="n">$</span>  <span class="k">do</span>
        <span class="n">color3f</span> <span class="mi">1</span> <span class="mi">1</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="mf">0.2</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="mi">0</span> <span class="mi">0</span> 

        <span class="n">color3f</span> <span class="mi">0</span> <span class="mi">1</span> <span class="mf">0.5</span> 
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="mf">0.2</span> <span class="mi">0</span> <span class="mi">0</span>

        <span class="n">color3f</span> <span class="mi">0</span> <span class="mf">0.5</span>  <span class="mi">1</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> <span class="mi">0</span> 

        <span class="n">color3f</span> <span class="mf">0.3</span> <span class="mf">0.3</span> <span class="mf">0.3</span> 
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="mi">0</span> <span class="mf">0.2</span> <span class="mi">0</span>
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mf">0.2</span> <span class="mi">0</span> 
        <span class="n">vertex3f</span> <span class="o">(-</span><span class="mf">0.2</span><span class="o">)</span> <span class="mi">0</span> <span class="mi">0</span> 
    <span class="n">flush</span>
</pre></div>
            <div class="cen">
                <img src="../image/openGLColor.png" width="30%" height="30%" />
            </div>
            <div class="mytitle">Map Examples in Haskell</div>
            <div class="mytext">
            Haskell Map Example<br>
            map::(a->b) -> [a] -> [b]<br>
            map f xs is the list obtained by apply f to each element of xs<br>
            map f [1..3] = [f(1) f(2) f(3)]<br>
            map f [x1, x2, ...] = [f(x1), f(x2), ...]<br>
            </div>
            <div class="highlight"><pre><span class="nf">f</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">f</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> 
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">+</span> <span class="mi">2</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 + 1) (2 + 2) (2 + 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="mi">2</span> <span class="o">-</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 - 1) (2 - 2) (2 - 2)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">((</span><span class="o">-</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>   <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 - 1) (2 - 2) (2 - 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">mod</span> <span class="mi">2</span><span class="p">)</span>   <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 mod 1) (2 mod 2) (2 mod 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(`</span><span class="n">mod</span><span class="p">`</span> <span class="mi">2</span><span class="p">)</span> <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (1 mod 2) (2 mod 2) (3 mod 2)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 / 1) (2 / 2) (2 / 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="o">*</span> <span class="mi">2</span><span class="p">)</span>     <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (2 * 1) (2 * 2) (2 * 3)</span>

        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(</span><span class="n">f</span> <span class="mi">10</span><span class="p">)</span>    <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (10 - 1) (10 - 2) (10 - 3)</span>
        <span class="n">print</span><span class="p">(</span><span class="n">map</span> <span class="p">(`</span><span class="n">f</span><span class="p">`</span> <span class="mi">10</span><span class="p">)</span>  <span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">])</span> <span class="c1">-- (1 - 10) (2 - 10) (3 - 10)</span>
</pre></div>
            <div class="mytitle">Unwrap Monad, Find Index and SubString in Haskell</div>
            <div class="mytext">
            1. Unwrap the Maybe Monad<br>
            2. Find the Index of Char in a String<br>
            3. SubString of two Indexes of string<br><br>
            Similar Haskell functions<br>
            </div>
            <div class="mytext">
            "abc" !! 1               -> 'b'<br>
            elemIndex 'a' "ba"       -> Just 1<br>
            isInfixOf "ab" "efab"    -> True<br>
            findIndex (== 'a') "bac" -> 1<br>
            findIndex (> 'a')  "bac" -> 2<br>
            </div>
            <div class="highlight"><pre><span class="c1">--unwrap Maybe</span>
<span class="nf">open</span><span class="ow">::</span><span class="kt">Maybe</span> <span class="n">a</span><span class="ow">-&gt;</span><span class="n">a</span>
<span class="nf">open</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;error&quot;</span>
<span class="nf">open</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=</span> <span class="n">a</span>

<span class="c1">-- find the index of Char</span>
<span class="nf">findChar</span><span class="ow">::</span><span class="kt">Char</span><span class="ow">-&gt;</span><span class="kt">String</span><span class="ow">-&gt;</span><span class="kt">Int</span>
<span class="nf">findChar</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="nf">findChar</span> <span class="n">a</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">a</span> <span class="o">/=</span> <span class="n">x</span> <span class="kr">then</span> <span class="p">((</span><span class="n">findChar</span> <span class="n">a</span> <span class="n">xs</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="kr">else</span> <span class="mi">0</span>

<span class="c1">-- substring from l to r</span>
<span class="nf">range</span><span class="ow">::</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">Int</span><span class="ow">-&gt;</span><span class="kt">String</span><span class="ow">-&gt;</span><span class="kt">String</span>
<span class="nf">range</span> <span class="n">l</span> <span class="n">r</span> <span class="n">str</span> <span class="ow">=</span> <span class="kr">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="n">str</span> <span class="o">||</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="n">str</span> <span class="kr">then</span> <span class="kt">[]</span> <span class="kr">else</span> <span class="p">(</span><span class="kr">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="kr">then</span> <span class="n">str</span> <span class="o">!!</span> <span class="n">l</span> <span class="kt">:[]</span> <span class="o">++</span> <span class="n">range</span> <span class="p">(</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="n">r</span> <span class="n">str</span> <span class="kr">else</span> <span class="kt">[]</span><span class="p">)</span>
</pre></div>
            <div class="mytitle">Regular Expression in Haskell</div>
            <div class="highlight"><pre><span class="nf">mymatch</span> <span class="n">regex</span> <span class="n">f</span> <span class="n">s</span> <span class="ow">=</span> 
        <span class="kr">case</span> <span class="n">matchRegexAll</span> <span class="n">regex</span> <span class="n">s</span> <span class="kr">of</span> 
            <span class="kt">Nothing</span><span class="ow">-&gt;</span><span class="n">s</span>
            <span class="kt">Just</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">matched</span><span class="p">,</span> <span class="n">after</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span><span class="ow">-&gt;</span><span class="n">before</span> <span class="o">++</span> <span class="n">f</span> <span class="n">l</span> <span class="o">++</span> <span class="n">after</span>

<span class="nf">t1</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="o">=~</span> <span class="s">&quot;is&quot;</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;this is it&quot;</span><span class="p">]</span> 
<span class="c1">-- [&quot;this is it&quot;]</span>
<span class="nf">ignoreCase</span> <span class="ow">=</span> <span class="n">makeRegexOpts</span><span class="p">(</span><span class="n">defaultCompOpt</span> <span class="o">.|.</span> <span class="n">compIgnoreCase</span><span class="p">)</span> <span class="n">defaultExecOpt</span>
<span class="nf">t3</span> <span class="ow">=</span> <span class="n">filter</span> <span class="p">(</span><span class="n">matchTest</span> <span class="o">$</span> <span class="n">ignoreCase</span> <span class="s">&quot;apple&quot;</span><span class="p">)</span> <span class="p">[</span><span class="s">&quot;My Apple&quot;</span><span class="p">]</span> 
<span class="c1">-- [&quot;My Apple&quot;]</span>
<span class="nf">t4</span> <span class="ow">=</span> <span class="n">subRegex</span><span class="p">(</span><span class="n">mkRegex</span> <span class="s">&quot;p+&quot;</span><span class="p">)</span> <span class="s">&quot;apple sucks&quot;</span> <span class="s">&quot;PP&quot;</span> 
<span class="c1">-- aPPle sucks</span>
<span class="nf">t5</span> <span class="ow">=</span> <span class="n">mymatch</span><span class="p">(</span><span class="n">mkRegex</span> <span class="s">&quot;man([0-9])&quot;</span><span class="p">)</span> <span class="p">(</span><span class="nf">\</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="ow">-&gt;</span><span class="s">&quot;woman&quot;</span> <span class="o">++</span> <span class="n">n</span><span class="p">)</span> <span class="s">&quot;/cat/man3/dog.txt&quot;</span>
<span class="c1">-- &quot;/cat/woman3/dog.txt&quot;</span>
</pre></div>
</div>

</body>
</html>

