#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />
** Reference in C and C++
    #+BEGIN_SRC c++
       int num = 3;
       int* ptr = &num
       printf("%d", *ptr); // 3
    #+END_SRC
** Function return by reference
    + Return a reference if a variable is not local to the function.
    #+BEGIN_SRC c++
       int num = 3;
       int& test(){
         return num;
       }       
       test() = 5;
       printf("%d", num); // num => 5
    #+END_SRC

    
** Get a pointer to ~std::vector~
    #+BEGIN_SRC c++
      class Pt{
	int x;
	int y;
	public Pt(int x, int y){
           this.x = x;
           this.y = y;
	}
      }
      std::vector<Pt> vect;
      vect.push_back(new Pt(1, 2));
      int* ptr = &vect;
      // ptr will point to vect.
    #+END_SRC
** Get a pointer to ~std::vector~ data
    + Get a pointer to the first address of the data.
      [[https://bitbucket.org/zsurface/cpplibtest/src/master/CppLibTest/CppLibTest/main.cpp][Test Example]]
    #+BEGIN_SRC c++
        class Pt{
        public:
            int x;
            int y;
        public:
            Pt(){}
            Pt(int x_, int y_){
                x = x_;
                y = y_;
            }
        };
        std::vector<Pt> vect;
        Pt p1;
        p1.x = 1;
        p1.y = 2;
        Pt p2;
        p2.x = 3;
        p2.y = 4;

        vect.push_back(p1);
        vect.push_back(p2);
        int expected[] = {
            1, 2, 3, 4
        };
        int* ptrToData = (int*) vect.data();
        REQUIRE(compareArray(ptrToData, expected, 4) == true);
    #+END_SRC

** Convert String to digit.
    #+BEGIN_SRC c++
      #include 
      #include 

      // convert string to digits
      //
      // gcc -o try1 try1.c   on MacOSX
      // Fri Jul 13 00:14:39 PDT 2018
      //  
      // 
      int main () {
	char str[30] = "2030300 This 444 is test";
	char *ptr;
	long ret;

	ret = strtol(str, &ptr, 10);
	printf("The number(unsigned long integer) is %ld\n", ret);
	printf("String part is [%s]", ptr);

	return(0);
      }
    #+END_SRC
** Initialize Array in C and C++
    #+BEGIN_SRC c++
      //C and C++ initialize array
      int array[] = {1, 2, 3};    
    #+END_SRC
** Pointer points to array
    #+BEGIN_SRC c++
      // now pointer pt points to array
      int* pt = array; 
    #+END_SRC

** C++ print out array
    #+BEGIN_SRC c++
    // print out the array
    for(int i=0; i<3; i++){
        cout<<"["<<i<<"]="<<pt[i]<<endl;
    }
    #+END_SRC
** Print out array with pointer.
    #+BEGIN_SRC c++
    // print out using the pointer
    for(int i=0; i<3; i++){
        cout<<"["<<i<<"]="<<*(pt+i)<<endl;
    }
    #+END_SRC
** Allocate memory in C dynamically.
    #+BEGIN_SRC c
    // dynamically allocate memory in C
    int size = 3;
    int* pt1 = (int*)malloc(sizeof(int)*size);

    // dellocate memory in C
    free(pt1);
    #+END_SRC
** Allocate memory in C++/Cpp dynamically.
    #+BEGIN_SRC c++
    // dynamically allocate memory in C++
    int *pt2 = new int[3];

    // dellocate memory in C++
    delete pt2;
    #+END_SRC
** Allocate two dimensions array in C
    #+BEGIN_SRC c
	// allocate two dimension array in C
	int col = 4;
	int row = 3;
	int** ppt;

	// this is trick part
	ppt = (int**)malloc(sizeof(int*)*col);
	for(int j=0; j<col; j++){
	    ppt[j] = (int*)malloc(sizeof(int)*row);
	}
	int c = 0;
	for(int i=0; i < col; i++){
	    for(int j=0; j < row; j++){
		ppt[i][j] = c++;
	    }
	}

      // Deallocate memory 2 dimensions.
      for(int j=0; j < col; j++){
	  free(ppt[j]);
      }
    #+END_SRC
    #+ATTR_HTML: width="100px"
    [[../image/malloc.svg]]				     
** Inheritence
    + Polygon, Rectangle and Triangle examples.
    #+BEGIN_SRC C++
	  class Polygon{
      protected:
	  int m;
	  int n;
      public:
	  Polygon(){
	      m = 0;
	      n = 0;
	  }
	  Polygon(int m, int n){
	      this -> m = m;
	      this -> n = n;
	  }
      };

      class Rectangle : public Polygon{
      public:
	  Rectangle(){}
	  Rectangle(int m, int n){
	      Polygon(m, n);
	  }
      public:
	  double area(){
	      return m*n;
	  }
      };

      class Triangle : public Polygon{
      public:
	  Triangle(){}
	  Triangle(int m, int n){
	      Polygon(m, n);
	  }
      public:
	  double area(){
	      return m*n/2;
	  }
      };


     Rectangle* pRect = new Rectangle(1, 2);
     cout<<"Rectangle Area"<<pRect->area();
     Triangle* pTri = new Triangle(1, 2);
     cout<<"Triangle Area"<<pTri->area();

    #+END_SRC
** Virtual Function, Pure Virtual.
** Smart pointer: unique pointer, shared pointer and weak pointer
   + What is smart pointer? [[https://stackoverflow.com/questions/12519812/how-do-i-pass-smart-pointers-into-functions][Smart Pointer]]
     + Smart pointer is all about *ownership*, who owns the object
       + Unique pointer only allows ONE *ownership*
       + Shared pointer allow more than one *ownership*.
       + Weak pointer has no *ownership*.
     + Smart pointer can automatically deallocate memory.
   + What is unique pointer?
     + As the name implies, make sure exactly only one copy of object exists.
     + Unique pointer can not be copied. \( \Rightarrow \) no ~use_count()~ function.
     + You can transfer the pointer to other unique pointer using ~std::move()~, then the origin unique pointer will be deleted.
   + What is shared pointer? [[https://en.cppreference.com/w/cpp/memory/shared_ptr/use_count][shared_ptr]]
     + Shared pointer is based on reference counting and can be used to store and pass reference beyond the current scope.
       #+BEGIN_SRC c++
	 class MyClass{
         public:
              MyClass(){}
         public:
              shared_pt<int> fun(){
                  shared_pt<int> pt(new int(9));
                  cout<<"fun pt.use_count()=" <<pt.use_count()<<endl; // pt.use_count() == 1
                  return pt;
              }
	 }

         // main
         MyClass* cpt = new MyClass();
         shared_pt<int> pt1 = cpt -> fun();
         cout<<"main pt1.use_count()=" << pt1.use_count()<<endl;  // pt1.use_count() == 1

       #+END_SRC
   + What is weak pointer?
