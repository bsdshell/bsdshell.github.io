#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-dark.min.css" />
** Monad
   1. Monad is monoid over the *endofunctor*
   2. endofunctor is just domain and image are both same functor
** definition of Monad
   η :: I → T  \\
   μ :: T × T → T
  
   	\begin{align*}
	 \mu &: T \times T \rightarrow T  \quad \text{ where } T \text{ is endofunctor}     \\ 
	 \mu T &: (T \times T) \times T \rightarrow T^2  \\
	 T \mu &: T \times (T \times T) \rightarrow T^2  \quad \text{Associativity law in Monoid}\\
	 \mu T &= T \mu  \quad \text{from commutative diagram} \\
	 T \mu \mu   &= T \\
	 \mu T \mu &= T \\
	 T \mu \mu &= \mu T \mu \\
	 \eta &: I  \rightarrow T              \\ 
	 \mu_a &: T \times T a \rightarrow T a \\ 
	 \eta_a &: I a \rightarrow T a     \quad \text{ where } I \text{ identity endofunctor }    \\ 
	\end{align*}
 
** urls: [[http://localhost/html/indexWhatisMonadinHaskell.html][Monad]]  
   #+BEGIN_SRC latex
	  f(x) = x² + x³
	  A = B → B ∘ μ η
	  C  E   F = f(9) = 4
   #+END_SRC

   Matrix
   \[
    A= \begin{bmatrix}
    \cos(\beta) & -\sin(\beta)\\
    \sin(\beta) & \cos(\beta)
    \end{bmatrix} + 
    B = \begin{bmatrix}
       \cos \beta & -\sin \beta \\
       \sin \beta &  \cos \beta
       \end{bmatrix}
    \]
    Matrix multiplication
    1. Matrix addition
       2. matrix division
   #+BEGIN_SRC haskell
     f::(Monad m)=> m a -> (a -> m b) -> m b

     transpose::[[a]] -> [[a]]
     transpose [] -> repeat []
     transpose (x:cs) = zipWith(:) x $ transpose cs
   #+END_SRC

** What is Functor
   1. The definition of *Functor* in Haskell.
      Functor is the type class with two methods,
      #+BEGIN_SRC haskell
	class Functor f where
	fmap::(a -> b) -> f a -> f b
      #+END_SRC
      The instance of *Functor* has to satisfy following two laws:
      #+BEGIN_SRC haskell
	fmap id = id
        fmap (f . g) = (fmap f) . (fmap g)
      #+END_SRC
	2. What is the difference between Functor and Monad
	   Monad is the subtype of Functor

** What is Monad
   1. What is the definition of Monad?
      Monad is *Monoid* over the *endofunctor*
      #+BEGIN_SRC haskell -n 1
	class Applicative m => Monad m where
	  return:: a -> m a
          return = pure
	  (>>=)::(Monad m) => m a -> (a -> m b) -> m b
      #+END_SRC
   2. When to use Monad?

** What is Monoid and Monad
   1. What is the difference between Monad and Monoid?
      There are couple *axioms* for *Monoid*
      1. id ⊗ m = m ⊗ id = m
      2. m1 ⊗ m2 ⊗ m3 = m1 ⊗ (m2 ⊗ m3)
   2. The mathematic definition of *Monad*   
      1. μ :: I → T    	 
      2. η :: T ⊗ T → T
      3. T is the endofunctor which means from a category to itself. (T : C → C)
   4. The domain and co-domain of η are both *Functor*
	+ ⊗ is *Functor* composition
	+ e.g. ~if T = m a then T ⊗ T = m (m a)~
	+ e.g. ~T = [] then T ⊗ T = [[]]~
	+ In Haskell, type constructor is like a *Functor*
      #+BEGIN_SRC haskell
	class Applicative f => Monad f where
	  return :: a -> f a
	  join f (f a) -> f a
	  fmap f (a -> b) -> (f a -> f b) -- f = (a -> m b)

	-- definition in GHC
	class Applicative m => Monad m where
	  return :: a -> m a
	  (>>=)::m a -> (a -> m b) -> m b

        -- f = (a -> m b)
	m >>= f = join $ fmap (a -> m b) m b
	m >>= f = join $ fmap f $ m b
	m >>= f = join $ m (f b)
	m >>= f = join $ m (m b)
      #+END_SRC
      Use join and fmap represents ~(>>=)~
      #+BEGIN_SRC haskell
	-- f = (a -> m b)                          
	m >>= f = join $ fmap f m b       
	m >>= f = join $ fmap f $ m b              
        m >>= f = join $ m (f b)                   
	m >>= f = join $ m (m b)                   
      #+END_SRC
      3. Maybe is Monad
      #+BEGIN_SRC haskell
	     instance Monad Maybe where
	       return Nothing = Nothing
	       (>>=) (Just a) f = Just f a

	       addMaybe::Maybe Int -> Maybe Int -> Maybe Int
	       addMaybe Nothing _ = Nothing
	       addMaybe _ Nothing = Nothing
	       addMaybe (Just a) (Just b) = Just (a + b)

	       -- other implementation
	       addMaybe::Maybe Int -> Maybe Int -> Maybe Int
	       addMaybe m1 m2 = do
		       a <- m1
		       b <- m2
		       return (a + b)
       #+END_SRC

** Applicative
   1. How to use Applicative 
   2. What is Applicative
   3. What is the difference between Monad and Applicative
   #+BEGIN_SRC haskell
     class Functor f => Applicative f where
       pure:: a -> f a
      (<*>):: f (a -> b) -> f a -> f b

     class Applicative f => Monad f where
       return:: a -> f a
       (>>=)::m a -> (a -> m b) -> m b

   #+END_SRC
      
      
      
   
   




	  



    
		 

   
   
