#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />
*** The defintion of Monoid
   + Monoid is similar to a *Group*, but it does not need an inverse for each element.
   + Monoid can be formed by $(M, \otimes)$ and satified following laws:
     + If $\forall m \in M$, then there exists an identity $I$ such as $I \otimes m = m \otimes I = m$
     + If $\forall m_1, m_2, m_3 \in M$, then $(m_1 \otimes m_2) \otimes m_3 = m_1 \otimes (m_2 \otimes m_3)$
*** The definition of Category
   + Category is a set including objects and morphisms/arrow
   + Each object has a morphism from category $C$ to category $D$
*** Monad
   1. A monad is a monoid in a category of *endofunctor*
   2. What does it mean?
      + functors are as elements in category. 
        + $T \in C$
      + The operation is functor composition  
        + $T \otimes T = T$
      + Each functor $T$ has an identity functor $I$ such that 
        + $I \otimes T = T \otimes I = T$	  
      + The operation satisfied Associativity law because monoid satisfied associativity law.
	+ $T \otimes T \otimes T = T \otimes (T \otimes T)$
*** definition of Monad
   \begin{align*}
      \mu &: T \times T \rightarrow T  \quad \text{ where } T \text{ is endofunctor}     \\ 
      \mu T &: (T \times T) \times T \rightarrow T^2  \\
      T \mu &: T \times (T \times T) \rightarrow T^2  \quad \text{Associativity law in Monoid}\\
      \mu T &= T \mu  \quad \text{from commutative diagram} \\
      T \mu \mu   &= T \\
      \mu T \mu &= T \\
      T \mu \mu &= \mu T \mu \\
      \eta &: I  \rightarrow T              \\ 
      \mu_a &: T \times T a \rightarrow T a \\ 
      \eta_a &: I a \rightarrow T a     \quad \text{ where } I \text{ identity endofunctor }    \\ 
    \end{align*}
  
*** urls: [[http://localhost/html/indexWhatisMonadinHaskell.html][Monad]]  
   #+BEGIN_SRC latex
	  f(x) = x² + x³
	  A = B → B ∘ μ η
	  C  E   F = f(9) = 4
   #+END_SRC

   Matrix
   \[
    A= \begin{bmatrix}
    \cos(\beta) & -\sin(\beta)\\
    \sin(\beta) & \cos(\beta)
    \end{bmatrix} + 
    B = \begin{bmatrix}
       \cos \beta & -\sin \beta \\
       \sin \beta &  \cos \beta
       \end{bmatrix}
    \]
    Matrix multiplication
    1. Matrix addition
       2. matrix division
   #+BEGIN_SRC haskell
     f::(Monad m)=> m a -> (a -> m b) -> m b

     transpose::[[a]] -> [[a]]
     transpose [] -> repeat []
     transpose (x:cs) = zipWith(:) x $ transpose cs
   #+END_SRC

*** What is Functor
   + The definition of *Functor* in Haskell.
      Functor is the type class with two methods,
      #+BEGIN_SRC haskell
	class Functor f where
	fmap::(a -> b) -> f a -> f b
      #+END_SRC
      + Other way to think about it is as following:
      + \( F(a \rightarrow b) \rightarrow F(a) \rightarrow F(b) \)
      + $F$ is a functor and transform a *function* $g:a \rightarrow b$ to a new *function* $F(a) \rightarrow F(b)$
      + If $g$ function is from type *Int* to type $String$ and the functor is *Maybe*, 
        then the new function is from Maybe(Int) \rightarrow Maybe(String)
	
      + The instance of *Functor* has to satisfy following two laws:
      #+BEGIN_SRC haskell
	fmap id = id
        fmap (f . g) = (fmap f) . (fmap g)
      #+END_SRC
   + What is the difference between Functor and Monad.
     + Monad is the subtype of Functor
   + Vector and matrix forms a category?
     + [[http://xfido.com/image/vector_space_to_category.jpg][Vector and Matrix => Category]]
*** What is Monad
   1. What is the definition of Monad?
      Monad is *Monoid* over the *endofunctor*
      #+BEGIN_SRC haskell -n 1
	class Applicative m => Monad m where
	  return:: a -> m a
          return = pure
	  (>>=)::(Monad m) => m a -> (a -> m b) -> m b
      #+END_SRC
   2. When to use Monad?

*** What is Monoid and Monad
   1. What is the difference between Monad and Monoid?
      There are couple *axioms* for *Monoid*
      1. id ⊗ m = m ⊗ id = m
      2. m1 ⊗ m2 ⊗ m3 = m1 ⊗ (m2 ⊗ m3)
   2. The mathematic definition of *Monad*   
      1. μ :: I → T    	 
      2. η :: T ⊗ T → T
      3. T is the endofunctor which means from a category to itself. (T : C → C)
   4. The domain and co-domain of η are both *Functor*
	+ ⊗ is *Functor* composition
	+ e.g. ~if T = m a then T ⊗ T = m (m a)~
	+ e.g. ~T = [] then T ⊗ T = [[]]~
	+ In Haskell, type constructor is like a *Functor*
      #+BEGIN_SRC haskell
	class Applicative f => Monad f where
	  return :: a -> f a
	  join f (f a) -> f a
	  fmap f (a -> b) -> (f a -> f b) -- f = (a -> m b)

	-- definition in GHC
	class Applicative m => Monad m where
	  return :: a -> m a
	  (>>=)::m a -> (a -> m b) -> m b

        -- f = (a -> m b)
	m >>= f = join $ fmap (a -> m b) m b
	m >>= f = join $ fmap f $ m b
	m >>= f = join $ m (f b)
	m >>= f = join $ m (m b)
      #+END_SRC
      Use join and fmap represents ~(>>=)~
      #+BEGIN_SRC haskell
	-- f = (a -> m b)                          
	m >>= f = join $ fmap f m b       
	m >>= f = join $ fmap f $ m b              
        m >>= f = join $ m (f b)                   
	m >>= f = join $ m (m b)                   
      #+END_SRC
      3. Maybe is Monad
      #+BEGIN_SRC haskell
	     instance Monad Maybe where
	       return Nothing = Nothing
	       (>>=) (Just a) f = Just f a

	       addMaybe::Maybe Int -> Maybe Int -> Maybe Int
	       addMaybe Nothing _ = Nothing
	       addMaybe _ Nothing = Nothing
	       addMaybe (Just a) (Just b) = Just (a + b)

	       -- other implementation
	       addMaybe::Maybe Int -> Maybe Int -> Maybe Int
	       addMaybe m1 m2 = do
		       a <- m1
		       b <- m2
		       return (a + b)
       #+END_SRC

*** Applicative
   1. How to use Applicative 
   2. What is Applicative
   3. What is the difference between Monad and Applicative
   #+BEGIN_SRC haskell
     class Functor f => Applicative f where
       pure:: a -> f a
      (<*>):: f (a -> b) -> f a -> f b

     class Applicative f => Monad f where
       return:: a -> f a
       (>>=)::m a -> (a -> m b) -> m b

   #+END_SRC
      
      
      
   
   




	  



    
		 

   
   
